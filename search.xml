<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>JavaScript基础(一)</title>
      <link href="/2019/02/26/JavaScript%E5%9F%BA%E7%A1%80-%E4%B8%80/"/>
      <content type="html"><![CDATA[<h1 id="JS基础-一"><a href="#JS基础-一" class="headerlink" title="JS基础(一)"></a>JS基础(一)</h1><ul><li>JS是一款运行在客户端的网页编程语言。<h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2></li><li>ecmascript js标准</li><li>dom 通过js操作网页元素</li><li>bom 通过api操作浏览器</li></ul><a id="more"></a><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>简单易用</li><li>解释执行<ul><li>编译执行: java c# 转化为.dll可执行文件，然后电脑读取.dll可执行文件 </li></ul></li><li>基于对象:相对于面向对象而言没有封装和多态，特点更少更简单<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2></li><li>表单验证</li><li>轮播特效</li><li>开发游戏</li></ul><h2 id="javascript与html之间的关系"><a href="#javascript与html之间的关系" class="headerlink" title="javascript与html之间的关系"></a>javascript与html之间的关系</h2><ul><li>html:是用来制作网页，简单来说就是编写网页结构</li><li>javascript:实现网页与客户之间互动的桥梁，让网页具有丰富的生命力</li></ul><h2 id="js书写位置"><a href="#js书写位置" class="headerlink" title="js书写位置"></a>js书写位置</h2><ul><li>内嵌式<ul><li>推荐将JS代码写在html结束标签后面<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">alert(&quot;Hello JS&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>外链式<ul><li>先创建一个外部Js文件</li><li>通过src将外部js文件调用</li><li>写js代码的时候，分号不能省略</li><li>推荐将js代码写在html结束标签后边，将多个js文件合成为一个js文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="输出消息的几种方式"><a href="#输出消息的几种方式" class="headerlink" title="输出消息的几种方式"></a>输出消息的几种方式</h2><ul><li><code>alert()</code> 在页面弹出框，早期js调试使用。</li><li><code>confirm()</code> 在页面中弹出对话框，js调试，多了一个取消按钮。</li><li><code>console.log()</code> 将信息输入到控制台。</li><li><code>prompt()</code> 弹出对话框，用于接收用户输入的信息。</li><li><code>document.write()</code>  在页面输出消息，不仅能输出信息，还能输出标签。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\&quot; 转双引号</span><br><span class="line">\&apos; 转单引号</span><br><span class="line">\n  换行</span><br><span class="line">\r 回车</span><br></pre></td></tr></table></figure><h2 id="js注释"><a href="#js注释" class="headerlink" title="js注释"></a>js注释</h2><ul><li>快捷键 <code>ctrl+/</code></li><li>单行注释 <code>//</code></li><li>多上注释 <code>/****/</code></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>会变化的量，变量是用来储存数据的容器。</li></ul><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><ul><li><code>var wukong;</code></li></ul><h3 id="给变量赋值"><a href="#给变量赋值" class="headerlink" title="给变量赋值"></a>给变量赋值</h3><ul><li><code>wukong=123;</code></li></ul><h2 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h2><ol><li>不能以数字或者纯数字开头</li><li>不推荐使用中文来定义变量名</li><li>不能使用特殊符号或者特殊符号开头(下划线除外)</li><li>不能使用关键字、保留字定义变量名。</li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h3><ul><li>数据类型 number<ul><li>正数 负数 小数</li></ul></li><li>数据类型的表达方法<ul><li>十进制表示法</li><li>十六进制表示法 以0x开头<ul><li>0-9 a(A)-f(F)</li></ul></li><li>八进制表示法<ul><li>0开头，0-7组成</li></ul></li></ul></li><li>字符串类型 string<ul><li>凡是用双引号或者单引号引起来的都是字符串</li></ul></li></ul><h3 id="布尔数据类型-Boolean"><a href="#布尔数据类型-Boolean" class="headerlink" title="布尔数据类型 Boolean"></a>布尔数据类型 Boolean</h3><ul><li>true</li><li>false</li></ul><h3 id="undefined-变量为初始化"><a href="#undefined-变量为初始化" class="headerlink" title="undefined 变量为初始化"></a>undefined 变量为初始化</h3><ul><li>定义了变量，没有给变量赋值，变量在内存中是存在的</li></ul><h3 id="null-变量未引用-值为空"><a href="#null-变量未引用-值为空" class="headerlink" title="null 变量未引用 值为空"></a>null 变量未引用 值为空</h3><ul><li>在内存中找不到这个变量</li></ul><h4 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h4><ul><li><code>typeof()</code> 判断数据的数据类型</li></ul><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><code>&lt;,&gt;,&lt;=,&gt;=,==,!=</code></p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><ul><li><code>+</code>加<ul><li>两个数字类型的的变量相加，得到的是一个数字类型。</li><li>一个数字类型和一个字符串相加，得到的是一个字符串。</li></ul></li><li><code>-</code>减<ul><li>两个数字类型的变量相减，得到的是一个数字类型。</li><li>一个数字类型和一个数字字符串相减，得到的是一个数字类型。</li><li>一个数字类型和一个非数字的字符串相减，得到的是NaN(not a number),是数字类型。</li></ul></li><li><p><code>/</code>除</p><ul><li>两个数字类型的变量相除，得到的是一个数字类型。</li><li>一个数字类型和一个数字类型的字符串相除，得到的是一个数字类型。</li><li>一个数字类型和一个非数字字符串相除，得到的是NaN，是一个数字类型。</li><li>如果两个数字类型的变量相除，除数是0，得到的结果是Infinity(无限大)，是一个数字类型。</li></ul></li><li><p><code>%</code>取余</p></li><li><p>优先级 有()先计算()里面的</p></li></ul><h2 id="带操作的运算符"><a href="#带操作的运算符" class="headerlink" title="带操作的运算符"></a>带操作的运算符</h2><table><thead><tr><th>运算符</th><th>示例</th><th>等价于</th></tr></thead><tbody><tr><td>+=</td><td>a+=b</td><td>a=a+b</td></tr><tr><td>-=</td><td>a-=b</td><td>a=a-b</td></tr><tr><td>*=</td><td>a*=b</td><td>a=a*b</td></tr><tr><td>/=</td><td>a/=b</td><td>a=a/b</td></tr></tbody></table>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Web前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Android开发艺术探索』笔记(二)</title>
      <link href="/2019/02/19/%E3%80%8EAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8F%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
      <content type="html"><![CDATA[<h1 id="『Android开发艺术探索』笔记之View的滑动"><a href="#『Android开发艺术探索』笔记之View的滑动" class="headerlink" title="『Android开发艺术探索』笔记之View的滑动"></a>『Android开发艺术探索』笔记之View的滑动</h1><p>View的滑动实现方式有三种；</p><ol><li>通过View本身提供的scrollTo/scrollBy方法来实现滑动；</li><li>通过动画给View施加平移效果来实现滑动；</li><li>通过改变View的LayoutParams使得View重新布局从而实现滑动。</li></ol><a id="more"></a><h2 id="使用scrollTo-scrollBy"><a href="#使用scrollTo-scrollBy" class="headerlink" title="使用scrollTo/scrollBy"></a>使用scrollTo/scrollBy</h2><p>&nbsp;为了实现View的滑动，View提供了专门的方法来实现这个功能，那就是scrollTo和scrollBy，我们先来看看这两个方法的实现，如下所示:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void scrollTo(int x,int y)&#123;</span><br><span class="line">     if(mScrollX!=x||mScrollY!=y)&#123;</span><br><span class="line">          int oldX=mScrollX;</span><br><span class="line">          int oldY=mScrollY;</span><br><span class="line">          mScrollX=x;</span><br><span class="line">          mScrollY=y;</span><br><span class="line">          invalidateParentCaches();</span><br><span class="line">          onScrollChanged(mScrollX,mScrollY,oldX,oldY);</span><br><span class="line">          if(!awakenScrollBars())&#123;</span><br><span class="line">              postInvalidateOnAnimation();</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void scrollBy(int x,int y)&#123;</span><br><span class="line">    scrollTo(mScrollX+x,mScrollY+y);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&nbsp;从上面的源码可以看出，scrollBy实际上也是使用了scrollTo方法，它实现了基于当前位置的相对滑动，而scrollTo则实现了基于所传递参数的绝对滑动，而scrollTo则实现了基于所传递参数的绝对滑动，这个不难理解。利用scrollTo和scrollBy来实现View滑动，这不是一件困难的事，但是我们要明白滑动过程中View内部的两个属性mScrollX和mScrollY的改变规则，这两个属性可以通过getScrollX和getScrollY方法分别得到。<br><br>&nbsp;在滑动过程中，mScrollX的值总是等于View左边缘和View内容左边缘在水平方向的距离，而mScrollY的值总是等于View上边缘和View内容上边缘在竖直方向的距离。<br><br>&nbsp;View边缘是指View的位置，又四个顶点组成，而View内容边缘是指View中的内容的边缘，scrollTo和scrollBy只能改变View内容的位置而不能改变View在布局中的位置。<br><br>&nbsp;mScrollX和mScrollY的单位为像素，并且当View左边缘在View内容左边缘的右边时，mScrollX为正值，反之为负值；当View上边缘在View内容上边缘的下边时，mScrollY为正值，反之为负值。换句话说，如果从左向右滑动，那么mScrollX为负值，反之为正值；如果从上往下滑动，那么mScrollY为负值，反之为正值。<br><br>&nbsp;为了更好地理解这个问题，下面举个例子，如下图，在图中假设水平和竖直方向的滑动距离都为100像素，针对图中各种滑动情况，都给出了对应的mScrollX和mScrollY的值。根据上面的分析，可以知道，使用scrollTo和scrollBy来实现View的滑动，只能将View的内容进行移动，并不能将View本身进行移动，也就是说，不管怎么滑动，也不能将当前View滑动到附近View所在区域。<br></p><p><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/%E8%87%AA%E5%AE%9A%E4%B9%89View/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190219095933.jpg" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/%E8%87%AA%E5%AE%9A%E4%B9%89View/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190219095933.jpg"></p><h2 id="使用动画"><a href="#使用动画" class="headerlink" title="使用动画"></a>使用动画</h2><p>&nbsp;通过使用动画，我们能让一个View进行平移，而平移就是一种滑动。使用动画来移动View,主要是操作View的translationX和translationY属性，即可以采用传统的View动画，也可以采用属性动画，如果采用属性动画的话，为了兼容3.0以下的版本，需要采用开源动画库nineoldandroids<br></p><h3 id="View动画"><a href="#View动画" class="headerlink" title="View动画"></a>View动画</h3><p>&nbsp;采用View动画的代码，如下所示。此动画可以在100ms内将一个View从原始位置向右下角移动100个像素。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:fillAfter=&quot;true&quot;</span><br><span class="line">android:zAdustment=&quot;normal&quot;&gt;</span><br><span class="line">&lt;translate</span><br><span class="line">    android:duration=&quot;100&quot;</span><br><span class="line">    android:fromXDelta=&quot;0&quot;</span><br><span class="line">    android:fromYDelta=&quot;0&quot;</span><br><span class="line">    android:interpolator=&quot;@android:anim/linear_interpolator&quot;</span><br><span class="line">    android:toXDelta=&quot;100&quot;</span><br><span class="line">    android:toYDelta=&quot;100&quot;/&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure><h3 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h3><p>&nbsp;如果采用属性动画的话，就更简单了，以下代码可以将一个View在100ms内从原始位置向右平移100像素。<br><br><code>ObjectAnimator.ofFloat(targetView,&quot;translationX&quot;,0,100).setDuration(100).start();</code></p><h2 id="改变布局参数"><a href="#改变布局参数" class="headerlink" title="改变布局参数"></a>改变布局参数</h2><p>&nbsp;改变布局参数，即改变LayoutParams。这个就比较好理解了，比如我们想把一个Button向右平移100px,我们只需要将这个Button的LayoutParams里的marginLeft参数值增加100px即可，是不是很简单呢？还有一种情形，为了达到移动Button的目的，我们可以在Button的左边放置一个空的View,这个空的View默认宽度为0，当我们需要向右移动Button时，只需要重新设置空View的宽度即可，当空View的宽度增大时(假设Button的父容器是水平方向的LinearLayout),Button就被自动挤向右边，即实现了向右平移的效果。如何重新设置一个View的LayoutParams呢？很简单，如下所示。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MarginLayoutParams params=(MarginLayoutParams)mButton1.getLayoutParams();</span><br><span class="line">params.with+=100;</span><br><span class="line">params.leftMargin+=100;</span><br><span class="line">mButton1.requestLayout();</span><br><span class="line">//或者mButton1.setLayoutParams(params);</span><br></pre></td></tr></table></figure></p><p>&nbsp;通过改变LayoutParams的方式去实现View的滑动同样是一种很灵活的方法，需要根据不同情况去做不同的处理。<br></p><h2 id="三种滑动方式的对比"><a href="#三种滑动方式的对比" class="headerlink" title="三种滑动方式的对比"></a>三种滑动方式的对比</h2><ul><li>scrollTo/scrollBy:操作简单，适合对View内容的滑动；</li><li>动画:操作简单，主要适用于没有交互的View和实现复杂的动画效果；</li><li>改变布局参数:操作稍微复杂，适用于有交互的View;</li></ul>]]></content>
      
      <categories>
          
          <category> View的事件体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 自定义View </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Android开发艺术探索』笔记</title>
      <link href="/2019/02/18/%E3%80%8EAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8F%E7%AC%94%E8%AE%B0/"/>
      <content type="html"><![CDATA[<h1 id="『Android开发艺术探索』笔记之View的基础知识"><a href="#『Android开发艺术探索』笔记之View的基础知识" class="headerlink" title="『Android开发艺术探索』笔记之View的基础知识"></a>『Android开发艺术探索』笔记之View的基础知识</h1><blockquote><p>本文内容来自『Android开发艺术探索』一书，以及博客:<a href="https://blog.csdn.net/harvic880925/article/details/39520901" target="_blank" rel="noopener">https://blog.csdn.net/harvic880925/article/details/39520901</a></p></blockquote><h2 id="什么是View"><a href="#什么是View" class="headerlink" title="什么是View?"></a>什么是View?</h2><ul><li>View是Android中所有控件的基类，不管是简单的Button和TextView还是复杂的RelativeLayout和ListView，它们共同的基类都是View。</li><li>View是一种界面层的控件的一种抽象，它代表了一个控件。除了View，还有ViewGroup,ViewGroup也继承了View，这意味着View本身就可以是单个控件也可以是由多个控件组成的一组控件。</li></ul><a id="more"></a><h2 id="View的位置参数"><a href="#View的位置参数" class="headerlink" title="View的位置参数"></a>View的位置参数</h2><ul><li>View的位置主要由它的四个点来决定，分别对应于View的四个属性:top、left、right、bottom，其中top是左上角的纵坐标，left是左上角的横坐标，right是右下角的横坐标，bottom是右下角的纵坐标。</li></ul><p><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/%E8%87%AA%E5%AE%9A%E4%B9%89View/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190216110003.jpg" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/%E8%87%AA%E5%AE%9A%E4%B9%89View/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190216110003.jpg"></p><ul><li><p>根据上图，我们很容易得出View的宽高与坐标的关系:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">width=right-left</span><br><span class="line">height=bottom-top</span><br></pre></td></tr></table></figure></li><li><p>如何得到View的这top、left、right、bottom这四个参数呢？方法如下:</p><ul><li>Left=getLeft();</li><li>Right=getRight();</li><li>Top=getTop();</li><li>Bottom=getBottom();</li></ul></li></ul><ul><li>从Android3.0开始，View增加了额外的几个参数:x、y、translationX和translationY,其中，x和y是View左上角的坐标，而translationX和translationY是View左上角相对父容器的偏移量。这几个参数也是相对于父容器的坐标，并且translationX和translationY的默认值是0，他们之间的关系如下:<ul><li>x=left+translationX</li><li>y=top+translationY</li></ul></li><li>注意:View在平移的过程中，top和left表示的是原始左上角的位置信息，其值并不会发生改变，此时改变的是x,y,translationX和translationY这四个参数。</li></ul><h2 id="MotionEvent和TouchSlop"><a href="#MotionEvent和TouchSlop" class="headerlink" title="MotionEvent和TouchSlop"></a>MotionEvent和TouchSlop</h2><h3 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent"></a>MotionEvent</h3><ul><li>在手指接触屏幕后所产生的一系列事件中，典型的事件类型有如下几种:<ul><li>ACTION_DOWN:手指刚接触屏幕</li><li>ACTION_MOVE:手指在屏幕上移动</li><li>ACTION_UP:手指从屏幕上松开的一瞬间</li></ul></li><li><p>正常情况下，一次手指触摸屏幕的行为会触发一系列点击事件，考虑如下几种情况:</p><ul><li>点击屏幕后离开松开，事件序列为DOWN-&gt;UP</li><li>点击屏幕滑动一会儿在松开，事件序列为DOWN-&gt;MOVE-&gt;…-&gt;MOVE-&gt;UP</li></ul></li><li><p>上述三种典型的事件序列，同时通过MotionEvent对象我们可以得到点击事件发生的X和Y坐标。为此，系统提供了两组方法:getX/getY和getRawX/getRawY。它们的区别其实很简单，getX/Y返回的是当前View左上角的x和y坐标，而getRawX/getRawY返回的相对于手机屏幕左上角的x和y坐标。</p></li></ul><h3 id="TouchSlop"><a href="#TouchSlop" class="headerlink" title="TouchSlop"></a>TouchSlop</h3><ul><li>TouchSlop是系统所能识别出的认为是滑动的最小距离，话句话说，当手机在屏幕上滑动时，如果两次滑动之间的距离小于这个常量，那么系统就不会认为你是在进行滑动操作。</li><li>这个常量可以通过<code>ViewConfiguration.get(getContext()).getScaledTouchSlop()</code>获得。</li><li>有了这个常量后，当我们在处理滑动时，可以利用这个常量来做一些过滤，比如当两次滑动事件的滑动距离小于这个值，我们就可以认为未达到滑动距离的临界值，因此就可以认为它们不是滑动，这样做可以有更好的用户体验。</li></ul><h2 id="VelocityTracker-GestureDetector和Scroller"><a href="#VelocityTracker-GestureDetector和Scroller" class="headerlink" title="VelocityTracker,GestureDetector和Scroller"></a>VelocityTracker,GestureDetector和Scroller</h2><h3 id="VelocityTracker"><a href="#VelocityTracker" class="headerlink" title="VelocityTracker"></a>VelocityTracker</h3><ul><li><p>VelocityTracker是一个追踪速度的类，用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。它的使用过程很简单，首先，在View的onTouchEvent方法中追踪当前单击事件的速度:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VelocityTracker velocityTracker=VelocityTracker.obtain();</span><br><span class="line">velocityTracker.addMovement(event);</span><br></pre></td></tr></table></figure></li><li><p>接着，当我们想知道当前的滑动速度时，这个时候可以采用如下方法来获得当前的速度:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">velocityTracker.computeCurrentVelocity(1000);</span><br><span class="line">int xVelocity=(int)velocityTracker.getXVelocity();</span><br><span class="line">int yVelocity=(int)velocityTracker.getYVelocity();</span><br></pre></td></tr></table></figure></li><li><p>注意:</p><ul><li>获取速度之前必须先计算速度，即getXVelocity()和getYVelocity()这两个方法的前面必须要调用computeCurrentVelocity()方法.</li><li>这里的速度是指一段时间内手指所滑过的像素数，比如将时间间隔设为1000ms时，在1s内，手指在水平方向从左向右滑过100像素，那么水平速度就是100,注意速度可以为负值，当手指从右往左滑动时，水平方向速度即为负值，速度的计算可以用如下公式来表示:<code>速度=(终点位置-起点位置)/时间段</code></li></ul></li><li><p>最后，当不需要使用它的时候，需要调用clear方法来重置回收内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">velocityTracker.clear();</span><br><span class="line">velocityTracker.recycle();</span><br></pre></td></tr></table></figure></li></ul><h3 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h3><ul><li>GestureDetector手势识别类，当用户触摸屏幕的时候，会产生很多手势，例如down,up,scroll,filing等等。</li><li>一般情况下，我们知道View类有个View.OnTouchListener内部类接口，通过重写它的onTouch(View v,MotionEvent event)方法，我们可以处理一些touch事件，但是这个方法太过简单，如果需要处理一些复杂的手势，用这个接口就会很麻烦(因为我们要自己根据用户触摸的轨迹去判断是什么手势)。</li><li>Android SDK给我们提供了GestureDetector类，通过这个类我们可以识别很多的手势，主要是通过他的onTouchEvent(event)方法完成了不同手势的识别。虽然他能识别手势，但是不同的手势要怎么处理，应该是提供给程序员实现的。</li><li>GestureDetector这个类对外提供了两个接口和一个外部类<ul><li>接口:OnGestureListener，OnDoubleTapListener</li><li>内部类:SimpleOnGestureListener</li><li>这个内部类，其实是两个接口中所有函数的集成，它包含了这两个接口里所有必须要实现的函数而且都已经重写，但所有的方法体都是空的；不同点在于，该类是static class,可以在外部类集成这个类，重新里面的手势处理方法</li></ul></li></ul><h4 id="OnGestureListener接口"><a href="#OnGestureListener接口" class="headerlink" title="OnGestureListener接口"></a>OnGestureListener接口</h4><ul><li><p>如果我们写一个类并implements OnGestureListener，会提示有几个必须重写的函数，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class GestureListener implements GestureDetector.OnGestureListener &#123;</span><br><span class="line">    private Context context;</span><br><span class="line"></span><br><span class="line">    public GestureListener(Context context) &#123;</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 按下屏幕就会触发</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onDown(MotionEvent motionEvent) &#123;</span><br><span class="line">        Log.i(&quot;MyGesture&quot;, &quot;onDown&quot;);</span><br><span class="line">        Toast.makeText(context, &quot;onDown&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 按下的时候没有松开或者拖动会触发</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void onShowPress(MotionEvent motionEvent) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 一次单独的轻击操作</span><br><span class="line">     * 点击一下非常快（不滑动）：</span><br><span class="line">     * onDown-&gt;onSingleTapUp-&gt;onSingleTapConfirmed</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 点击一下稍微慢点（不滑动）：</span><br><span class="line">     * onDown-&gt;onShowPress-&gt;onSingleTapConfirmed</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onSingleTapUp(MotionEvent motionEvent) &#123;</span><br><span class="line">        Log.i(&quot;MyGesture&quot;, &quot;onSingleTapUp&quot;);</span><br><span class="line">        Toast.makeText(context, &quot;onSingleTapUp&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在屏幕上拖动事件。无论是用手拖动view，或者是以抛的动作，都会多次触发这个方法，在ACTION_MOVE动作发生时就会触发</span><br><span class="line">     *</span><br><span class="line">     * 滑屏:手指触动屏幕后，稍微滑动后立即松开</span><br><span class="line">     * onDown--&gt;onScroll--&gt;onScroll--&gt;onScroll--&gt;...--&gt;onFling</span><br><span class="line">     *</span><br><span class="line">     * 拖动</span><br><span class="line">     * onDown--&gt;onScroll--&gt;onScroll--&gt;onFiling</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123;</span><br><span class="line">        Log.i(&quot;MyGesture22&quot;, &quot;onScroll:&quot; + (e2.getX() - e1.getX()) + &quot;   &quot; + distanceX);</span><br><span class="line">        Toast.makeText(context, &quot;onScroll&quot;, Toast.LENGTH_LONG).show();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 长按屏幕超过一定时间就会触发</span><br><span class="line">     * 触发顺序：onDown--》onShowPress--》onLongPress</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void onLongPress(MotionEvent motionEvent) &#123;</span><br><span class="line">        Log.i(&quot;MyGesture&quot;, &quot;onLongPress&quot;);</span><br><span class="line">        Toast.makeText(context, &quot;onLongPress&quot;, Toast.LENGTH_LONG).show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 滑屏：手指触摸屏幕后，稍微滑动后立即松开</span><br><span class="line">     * onDown-&gt;onScroll-&gt;...-&gt;onFling</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 拖动</span><br><span class="line">     * onDown-&gt;onScroll-&gt;...-&gt;onFling</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onFling(MotionEvent motionEvent, MotionEvent motionEvent1, float v, float v1) &#123;</span><br><span class="line">        Log.i(&quot;MyGesture&quot;, &quot;onFling&quot;);</span><br><span class="line">        Toast.makeText(context, &quot;onFling&quot;, Toast.LENGTH_LONG).show();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>如上，总共重写了六个函数，这些函数在设呢么情况下触发，已经在上面代码中一一注释</p></li></ul><h5 id="使用GestureDetector步骤如下"><a href="#使用GestureDetector步骤如下" class="headerlink" title="使用GestureDetector步骤如下:"></a>使用GestureDetector步骤如下:</h5><ul><li><p>一，使用构造实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">GestureDetector.OnGestureListener listener = new GestureDetector.OnGestureListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onDown(MotionEvent motionEvent) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onShowPress(MotionEvent motionEvent) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onSingleTapUp(MotionEvent motionEvent) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onScroll(MotionEvent motionEvent, MotionEvent motionEvent1, float v, float v1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onLongPress(MotionEvent motionEvent) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onFling(MotionEvent motionEvent, MotionEvent motionEvent1, float v, float v1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>也可以构造类，如上GestureListener代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class GestureListener implements GestureDetector.OnGestureListener &#123;</span><br><span class="line">(略)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二，在Activity的onCreate方法中 <strong>创建GestureDetector实例mGestureDetector</strong></p><ul><li>构造函数有下面三个，根据需要选择:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GestureDetector gestureDetector=new GestureDetector(GestureDetector.OnGestureListener listener);</span><br><span class="line">GestureDetector gestureDetector=new GestureDetector(Context context,GestureDetector.OnGestureListener listener);</span><br><span class="line">GestureDetector gestureDetector=new GestureDetector(Context context,GestureDetector.SimpleOnGestureListener listener);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>三，onTouch(View v,MotionEvent event)中拦截:</p><ul><li>先让Activity implements View.OnTouchListener接口，重写onTouch方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouch(View v, MotionEvent event) &#123;</span><br><span class="line">return mGestureDetector.onTouchEvent(event);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>四，绑定控件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TextView tv = (TextView)findViewById(R.id.tv);</span><br><span class="line">tv.setOnTouchListener(this);</span><br></pre></td></tr></table></figure></li><li><p>布局中的设置一个TextView(代码略)</p></li><li>Activity中代码如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity implements View.OnTouchListener &#123;</span><br><span class="line"></span><br><span class="line">    private TextView tvText;</span><br><span class="line">    private GestureDetector gestureDetector;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        tvText = findViewById(R.id.tv_text);</span><br><span class="line">        gestureDetector = new GestureDetector(new GestureListener(MainActivity.this));</span><br><span class="line">        tvText.setOnTouchListener(this);</span><br><span class="line">        tvText.setFocusable(true);</span><br><span class="line">        tvText.setClickable(true);</span><br><span class="line">        tvText.setLongClickable(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouch(View view, MotionEvent event) &#123;</span><br><span class="line">        return gestureDetector.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="OnDoubleTapListener接口"><a href="#OnDoubleTapListener接口" class="headerlink" title="OnDoubleTapListener接口"></a>OnDoubleTapListener接口</h4><h5 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class doubleTapListener implements GestureDetector.OnDoubleTapListener &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 单击事件</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onSingleTapConfirmed(MotionEvent motionEvent) &#123;</span><br><span class="line">        Log.i(&quot;MyGesture&quot;, &quot;onSingleTapConfirmed&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onDoubleTap(MotionEvent motionEvent) &#123;</span><br><span class="line">        Log.i(&quot;MyGesture&quot;, &quot;onDoubleTap&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onDoubleTapEvent(MotionEvent motionEvent) &#123;</span><br><span class="line">        Log.i(&quot;MyGesture&quot;, &quot;onDoubleTapEvent&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>onSingleTapConfirmed(MotionEvent e):单击事件。用来判定该次点击是SingleTap而不是DoubleTap，如果连续点击两次就是DoubleTap手势，如果只点击一次，系统等待一段时间后没有收到第二次点击则判定该次点击为SingleTap而不是DoubleTap，然后触发SingleTapConfirmed事件。触发顺序是：OnDown-&gt;OnsingleTapUp-&gt;OnsingleTapConfirmed</li><li>onDoubleTap(MotionEvent e)：双击事件</li><li>onDoubleTapEvent(MotionEvent e)：双击间隔中发生的动作。</li></ul><h5 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity implements View.OnTouchListener &#123;</span><br><span class="line"></span><br><span class="line">    private TextView tvText;</span><br><span class="line">    private GestureDetector gestureDetector;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        tvText = findViewById(R.id.tv_text);</span><br><span class="line">        gestureDetector = new GestureDetector(new GestureListener(MainActivity.this));</span><br><span class="line">        gestureDetector.setOnDoubleTapListener(new doubleTapListener());</span><br><span class="line">        tvText.setOnTouchListener(this);</span><br><span class="line">        tvText.setFocusable(true);</span><br><span class="line">        tvText.setClickable(true);</span><br><span class="line">        tvText.setLongClickable(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouch(View view, MotionEvent event) &#123;</span><br><span class="line">        return gestureDetector.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SimpleOnGestureListener类"><a href="#SimpleOnGestureListener类" class="headerlink" title="SimpleOnGestureListener类"></a>SimpleOnGestureListener类</h4><ul><li>它与前面两个不同的是:</li></ul><ol><li>这是一个类，在它基础上新建类的话，要用extends派生而不是用implement继承。</li><li>OnGestureListener和OnDoubleTapListener接口里面的函数都是强制必须重写的，即使用不到也要重写出来一个空函数但在SimpleOnGestureListener类的实例或派生类中不必如此，可以根据情况，用到哪个函数就重写哪个函数，因为SimpleOnGestureListener类本身已经实现了这两个接口的所有函数，只是里面全是空的而已。</li></ol><ul><li>下面利用SimpleOnGestureListener类来实现上面几个效果，代码如下:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity implements View.OnTouchListener &#123;</span><br><span class="line"></span><br><span class="line">    private TextView tvText;</span><br><span class="line">    private GestureDetector gestureDetector;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        tvText = findViewById(R.id.tv_text);</span><br><span class="line">        gestureDetector=new GestureDetector(new simpleGestureListener());</span><br><span class="line">        tvText.setOnTouchListener(this);</span><br><span class="line">        tvText.setFocusable(true);</span><br><span class="line">        tvText.setClickable(true);</span><br><span class="line">        tvText.setLongClickable(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouch(View view, MotionEvent event) &#123;</span><br><span class="line">        return gestureDetector.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private class simpleGestureListener extends GestureDetector.SimpleOnGestureListener &#123;</span><br><span class="line">        /*****OnGestureListener的函数*****/</span><br><span class="line">        @Override</span><br><span class="line">        public boolean onDown(MotionEvent e) &#123;</span><br><span class="line">            Log.i(&quot;MyGesture&quot;, &quot;onDown&quot;);</span><br><span class="line">            Toast.makeText(MainActivity.this, &quot;onDown&quot;, Toast.LENGTH_SHORT)</span><br><span class="line">                    .show();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onShowPress(MotionEvent e) &#123;</span><br><span class="line">            Log.i(&quot;MyGesture&quot;, &quot;onShowPress&quot;);</span><br><span class="line">            Toast.makeText(MainActivity.this, &quot;onShowPress&quot;, Toast.LENGTH_SHORT)</span><br><span class="line">                    .show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean onSingleTapUp(MotionEvent e) &#123;</span><br><span class="line">            Log.i(&quot;MyGesture&quot;, &quot;onSingleTapUp&quot;);</span><br><span class="line">            Toast.makeText(MainActivity.this, &quot;onSingleTapUp&quot;,</span><br><span class="line">                    Toast.LENGTH_SHORT).show();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean onScroll(MotionEvent e1, MotionEvent e2,</span><br><span class="line">                                float distanceX, float distanceY) &#123;</span><br><span class="line">            Log.i(&quot;MyGesture&quot;, &quot;onScroll:&quot; + (e2.getX() - e1.getX()) + &quot;   &quot;</span><br><span class="line">                    + distanceX);</span><br><span class="line">            Toast.makeText(MainActivity.this, &quot;onScroll&quot;, Toast.LENGTH_LONG)</span><br><span class="line">                    .show();</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onLongPress(MotionEvent e) &#123;</span><br><span class="line">            Log.i(&quot;MyGesture&quot;, &quot;onLongPress&quot;);</span><br><span class="line">            Toast.makeText(MainActivity.this, &quot;onLongPress&quot;, Toast.LENGTH_LONG)</span><br><span class="line">                    .show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,</span><br><span class="line">                               float velocityY) &#123;</span><br><span class="line">            Log.i(&quot;MyGesture&quot;, &quot;onFling&quot;);</span><br><span class="line">            Toast.makeText(MainActivity.this, &quot;onFling&quot;, Toast.LENGTH_LONG)</span><br><span class="line">                    .show();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*****OnDoubleTapListener的函数*****/</span><br><span class="line">        @Override</span><br><span class="line">        public boolean onSingleTapConfirmed(MotionEvent e) &#123;</span><br><span class="line">            Log.i(&quot;MyGesture&quot;, &quot;onSingleTapConfirmed&quot;);</span><br><span class="line">            Toast.makeText(MainActivity.this, &quot;onSingleTapConfirmed&quot;,</span><br><span class="line">                    Toast.LENGTH_LONG).show();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean onDoubleTap(MotionEvent e) &#123;</span><br><span class="line">            Log.i(&quot;MyGesture&quot;, &quot;onDoubleTap&quot;);</span><br><span class="line">            Toast.makeText(MainActivity.this, &quot;onDoubleTap&quot;, Toast.LENGTH_LONG)</span><br><span class="line">                    .show();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean onDoubleTapEvent(MotionEvent e) &#123;</span><br><span class="line">            Log.i(&quot;MyGesture&quot;, &quot;onDoubleTapEvent&quot;);</span><br><span class="line">            Toast.makeText(MainActivity.this, &quot;onDoubleTapEvent&quot;,</span><br><span class="line">                    Toast.LENGTH_LONG).show();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="OnFiling应用-识别向左滑还是向右滑"><a href="#OnFiling应用-识别向左滑还是向右滑" class="headerlink" title="OnFiling应用-(识别向左滑还是向右滑)"></a>OnFiling应用-(识别向左滑还是向右滑)</h5><ul><li><p>我们利用OnFiling函数来识别当前用户是向左滑还是向右滑，先看一下OnFiling参数:</p><ul><li>boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,float velocityY)<ul><li>e1:第一个ACTION_DOWN MotionEvent</li><li>e2:最后一个ACTION_MOVE MotionEvent</li><li>velocityX：X轴上的移动速度，像素/秒</li><li>velocityY：Y轴上的移动速度，像素/秒</li></ul></li></ul></li><li><p>代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity implements OnTouchListener &#123;</span><br><span class="line"> </span><br><span class="line">private GestureDetector mGestureDetector;   </span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">mGestureDetector = new GestureDetector(new simpleGestureListener());</span><br><span class="line"></span><br><span class="line">TextView tv = (TextView)findViewById(R.id.tv);</span><br><span class="line">    tv.setOnTouchListener(this);</span><br><span class="line">    tv.setFocusable(true);   </span><br><span class="line">    tv.setClickable(true);   </span><br><span class="line">    tv.setLongClickable(true); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean onTouch(View v, MotionEvent event) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return mGestureDetector.onTouchEvent(event);   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private class simpleGestureListener extends</span><br><span class="line">GestureDetector.SimpleOnGestureListener &#123;</span><br><span class="line"></span><br><span class="line">/*****OnGestureListener的函数*****/</span><br><span class="line"> </span><br><span class="line">final int FLING_MIN_DISTANCE = 100, FLING_MIN_VELOCITY = 200;  </span><br><span class="line"></span><br><span class="line">// 触发条件 ：   </span><br><span class="line">        // X轴的坐标位移大于FLING_MIN_DISTANCE，且移动速度大于FLING_MIN_VELOCITY个像素/秒   </span><br><span class="line">       </span><br><span class="line">// 参数解释：   </span><br><span class="line">        // e1：第1个ACTION_DOWN MotionEvent   </span><br><span class="line">        // e2：最后一个ACTION_MOVE MotionEvent   </span><br><span class="line">        // velocityX：X轴上的移动速度，像素/秒   </span><br><span class="line">        // velocityY：Y轴上的移动速度，像素/秒   </span><br><span class="line">public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,</span><br><span class="line">float velocityY) &#123;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        if (e1.getX() - e2.getX() &gt; FLING_MIN_DISTANCE  </span><br><span class="line">                &amp;&amp; Math.abs(velocityX) &gt; FLING_MIN_VELOCITY) &#123;  </span><br><span class="line">            // Fling left   </span><br><span class="line">            Log.i(&quot;MyGesture&quot;, &quot;Fling left&quot;);  </span><br><span class="line">            Toast.makeText(MainActivity.this, &quot;Fling Left&quot;, Toast.LENGTH_SHORT).show();  </span><br><span class="line">        &#125; else if (e2.getX() - e1.getX() &gt; FLING_MIN_DISTANCE  </span><br><span class="line">                &amp;&amp; Math.abs(velocityX) &gt; FLING_MIN_VELOCITY) &#123;  </span><br><span class="line">            // Fling right   </span><br><span class="line">            Log.i(&quot;MyGesture&quot;, &quot;Fling right&quot;);  </span><br><span class="line">            Toast.makeText(MainActivity.this, &quot;Fling Right&quot;, Toast.LENGTH_SHORT).show();  </span><br><span class="line">        &#125;  </span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> View的事件体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 自定义View </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android动画（二）</title>
      <link href="/2018/12/22/Android%E5%8A%A8%E7%94%BB%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <content type="html"><![CDATA[<h1 id="Android属性动画-Property"><a href="#Android属性动画-Property" class="headerlink" title="Android属性动画(Property)"></a>Android属性动画(Property)</h1><h2 id="ObjectAnimator类"><a href="#ObjectAnimator类" class="headerlink" title="ObjectAnimator类"></a>ObjectAnimator类</h2><p>ObjectAnimator类提供了ofFloat()方法来实现我们的动画效果，方法中包含三个参数Object target,String propertyName,float…values</p><br><p>Object target第一个参数是我们动画作用的对象</p><br><p>String propertyName是动画是何种属性，移动、旋转、还是渐变等，translationX表示水平方向移动，translationY表示垂直方向移动，rotation表示旋转</p><br><p>float…values 接收两个两float类型的常量，第一个float常量表示起始位置，第二float常量表示位移的距离或者旋转的角度等值</p><a id="more"></a><p>水平X轴 移动200F</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(ivImg, &quot;translationX&quot;, 0F, 200F).setDuration(2000).start();</span><br></pre></td></tr></table></figure><br><br><p>水平Y轴移动200F</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(ivImg, &quot;translationY&quot;, 0F, 200F).setDuration(2000).start();</span><br></pre></td></tr></table></figure><br><br><p>旋转360度</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(ivImg, &quot;rotation&quot;, 0F, 360F).setDuration(2000).start();</span><br></pre></td></tr></table></figure><br><br><p>多个动画属性同时作用</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(ivImg, &quot;translationX&quot;, 0F, 360F).setDuration(2000).start();</span><br><span class="line">                ObjectAnimator.ofFloat(ivImg, &quot;translationY&quot;, 0F, 360F).setDuration(2000).start();</span><br><span class="line">                ObjectAnimator.ofFloat(ivImg, &quot;rotation&quot;, 0F, 360F).setDuration(2000).start();</span><br></pre></td></tr></table></figure><br><br><p>多个动画属性同时作用(相对于上面的写法，更高效)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PropertyValuesHolder p1 = PropertyValuesHolder.ofFloat(&quot;rotation&quot;, 0, 360F);</span><br><span class="line">                PropertyValuesHolder p2 = PropertyValuesHolder.ofFloat(&quot;translationX&quot;, 0, 360F);</span><br><span class="line">                PropertyValuesHolder p3 = PropertyValuesHolder.ofFloat(&quot;translationY&quot;, 0, 360F);</span><br><span class="line">                ObjectAnimator.ofPropertyValuesHolder(ivImg, p1, p2, p3).setDuration(1000).start();</span><br></pre></td></tr></table></figure><h3 id="AnimatorSet用法"><a href="#AnimatorSet用法" class="headerlink" title="AnimatorSet用法"></a>AnimatorSet用法</h3><p>AnimatorSet作用多各动画属性的时候，可以有选择的改变每个动画的先后执行顺序<br><br></p><p>同时执行效果:</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator animator1 = ObjectAnimator.ofFloat(ivImg, &quot;rotation&quot;, 0F, 360F);</span><br><span class="line">ObjectAnimator animator2 = ObjectAnimator.ofFloat(ivImg, &quot;translationX&quot;, 0F, 360F);</span><br><span class="line">ObjectAnimator animator3 = ObjectAnimator.ofFloat(ivImg, &quot;translationY&quot;, 0F, 360F);</span><br><span class="line">AnimatorSet set = new AnimatorSet();</span><br><span class="line">//动画效果作用在一起</span><br><span class="line">set.playTogether(animator1, animator2, animator3);</span><br><span class="line">set.setDuration(1000);</span><br><span class="line">set.start();</span><br></pre></td></tr></table></figure><br><br><p>依次执行的效果:</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator anim1 = ObjectAnimator.ofFloat(ivImg, &quot;rotation&quot;, 0F, 360F);</span><br><span class="line">ObjectAnimator anim2 = ObjectAnimator.ofFloat(ivImg, &quot;translationX&quot;, 0F, 360F);</span><br><span class="line">ObjectAnimator anim3 = ObjectAnimator.ofFloat(ivImg, &quot;translationY&quot;, 0F, 360F);</span><br><span class="line">AnimatorSet animatorSet = new AnimatorSet();</span><br><span class="line">//动画依次执行</span><br><span class="line">animatorSet.playSequentially(anim1, anim2, anim3);</span><br><span class="line">animatorSet.setDuration(1000);</span><br><span class="line">animatorSet.start();</span><br></pre></td></tr></table></figure><br><br><p>自定义顺序:</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator a1 = ObjectAnimator.ofFloat(ivImg, &quot;rotation&quot;, 0F, 360F);</span><br><span class="line"> ObjectAnimator a2 = ObjectAnimator.ofFloat(ivImg, &quot;translationX&quot;, 0F, 360F);</span><br><span class="line"> ObjectAnimator a3 = ObjectAnimator.ofFloat(ivImg, &quot;translationY&quot;, 0F, 360F);</span><br><span class="line"> AnimatorSet animator = new AnimatorSet();</span><br><span class="line"> //自定义动画顺序</span><br><span class="line"> animator.play(a2).with(a3);</span><br><span class="line"> animator.play(a1).after(a2);</span><br><span class="line"> animator.setDuration(1000);</span><br><span class="line"> animator.start();</span><br></pre></td></tr></table></figure><br><br><p>动画的监听事件</p><br><p>ObjectAnimator的监听事件有两种，一种是Animator.AnimatorListener()，另一种是AnimatorListenerAdapter()，第一种监听事件要重新父类的onAnimationStart，onAnimationEnd，onAnimationCancel，onAnimationRepeat的全部方法，有时候我们只需要用到其中某一个方法，这种情况下，就显得不太简洁，而AnimatorListenerAdapter()则很好的解决了这个问题，不用重写全部，只需要选择需要重写的方法，代码如下:</p><p>Animator.AnimatorListener()</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 0F, 1F);</span><br><span class="line">animator.setDuration(1000);</span><br><span class="line">animator.start();</span><br><span class="line">//animator 的监听事件</span><br><span class="line">animator.addListener(new Animator.AnimatorListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onAnimationStart(Animator animator) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onAnimationEnd(Animator animator) &#123;</span><br><span class="line">        //动画结束的监听</span><br><span class="line">        Toast.makeText(Main3Activity.this, &quot;end&quot;, Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onAnimationCancel(Animator animator) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onAnimationRepeat(Animator animator) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><br><p>AnimatorListenerAdapter()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 0F, 1F);</span><br><span class="line">animator.setDuration(1000);</span><br><span class="line">animator.start();</span><br><span class="line">        animator.addListener(new AnimatorListenerAdapter() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">        super.onAnimationEnd(animation);</span><br><span class="line">        //动画结束的监听</span><br><span class="line">        Toast.makeText(Main3Activity.this, &quot;end&quot;, Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h3><h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h4><ul><li>translationX\translationY<ul><li>X轴\Y轴方向移动的距离</li></ul></li><li>rotation、rotationX\rotationY<ul><li>沿中心点旋转\沿X轴翻转\沿Y轴翻转</li></ul></li><li>scaleX\scaleY<ul><li>沿X轴\Y轴翻转</li></ul></li><li>X\Y<ul><li>移动到X\Y轴坐标点</li></ul></li><li>alpha<ul><li>渐变透明度变化</li></ul></li></ul><h4 id="常用方法、类"><a href="#常用方法、类" class="headerlink" title="常用方法、类"></a>常用方法、类</h4><ul><li>ValueAnimator<ul><li>数值发生器，可以实现很多很灵活的动画效果</li></ul></li><li>ObjectAnimator<ul><li>ValueAnimator的子类，封装了ValueAnimator，让我们更轻松的使用动画框架</li></ul></li><li>AnimatorUpdateListener，AnimatorListenerAdapter<ul><li>动画的监听事件</li></ul></li><li>PropertyValuesHolder<ul><li>控制动画的显示效果、速度相关</li></ul></li><li>AnimatorSet<ul><li>控制动画显示的顺序</li></ul></li><li>TypeEvaluators<ul><li>值计算器，控制值的变化规律和变化状态</li></ul></li><li>Interpolators<ul><li>差值计算器，控制值的变化规律和变化状态</li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Android </tag>
            
            <tag> 动画 </tag>
            
            <tag> 属性动画 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android动画（一）</title>
      <link href="/2018/12/18/Android%E5%8A%A8%E7%94%BB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <content type="html"><![CDATA[<h1 id="Android动画之视图动画"><a href="#Android动画之视图动画" class="headerlink" title="Android动画之视图动画"></a>Android动画之视图动画</h1><ul><li>Android动画主要有：</li></ul><a id="more"></a><table><thead><tr><th>动画种类</th><th>说明</th></tr></thead><tbody><tr><td>视图动画（View动画，补间（Tween）动画）</td><td>视图动画在Android古老的版本中已经有了，使用简单，效果丰富，缺点是不具备交互性，当某个元素发生视图动画后，其响应事件的位置还依然在动画前的地方</td></tr><tr><td>属性动画(Property 动画)</td><td>Android3.0以后推出，功能强大可以自定义任何类型和属性的动画</td></tr><tr><td>帧动画（Frame动画，Drawable动画）</td><td>专门用来一个一个的显示Drawable的resources，就像放幻灯片一样</td></tr></tbody></table><h2 id="视图动画"><a href="#视图动画" class="headerlink" title="视图动画"></a>视图动画</h2><ul><li>平移动画（TranslateAnimation）</li><li>旋转动画（RotateAnimation）</li><li>缩放动画（ScaleAnimation）</li><li>渐变动画（AlphaAnimation）</li><li>动画集合（AnimationSet）</li></ul><h3 id="视图动画的实现方式"><a href="#视图动画的实现方式" class="headerlink" title="视图动画的实现方式"></a>视图动画的实现方式</h3><ul><li>视图动画的实现方式主要有两种，一种是xml实现，首先在res/anim目录下定义动画的xml文件，之后再在代码中用AnimationUtils.loadAnimation()加载</li><li>代码实现，直接new对应的动画实例来实现动画</li></ul><h4 id="xml方式来实现视图动画"><a href="#xml方式来实现视图动画" class="headerlink" title="xml方式来实现视图动画"></a>xml方式来实现视图动画</h4><h5 id="在res-anim文件夹分别定义渐变、平移、旋转、缩放四个动画文件："><a href="#在res-anim文件夹分别定义渐变、平移、旋转、缩放四个动画文件：" class="headerlink" title="在res/anim文件夹分别定义渐变、平移、旋转、缩放四个动画文件："></a>在res/anim文件夹分别定义渐变、平移、旋转、缩放四个动画文件：</h5><ul><li><strong>渐变动画，名称为alpha.xml</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:startOffset=&quot;1000&quot;</span><br><span class="line">    android:fromAlpha=&quot;1.0&quot;</span><br><span class="line">    android:toAlpha=&quot;0.0&quot;</span><br><span class="line">    android:duration=&quot;2000&quot;&gt;</span><br><span class="line">&lt;/alpha&gt;</span><br></pre></td></tr></table></figure><ul><li>startOffset：表示动画开始的延迟时间，点开后1000毫秒（1秒）后开始执行，单位是毫秒。</li><li>fromAlpha：表示动画开始的透明度（1.0表示完全不透明，0.0表示完全透明）</li><li>toAlpha：表示动画结束的透明度（1.0表示完全不透明，0.0表示完全透明）</li><li>duration：表示动画持续的时间，单位为毫秒</li><li><p><strong>平移动画，名称为translate.xml</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:duration=&quot;3000&quot;</span><br><span class="line">    android:fromXDelta=&quot;0&quot;</span><br><span class="line">    android:fromYDelta=&quot;0&quot;</span><br><span class="line">    android:toXDelta=&quot;100%p&quot;</span><br><span class="line">    android:toYDelta=&quot;100%p&quot;&gt;</span><br><span class="line">&lt;/translate&gt;</span><br></pre></td></tr></table></figure></li><li><p>fromXDelta：表示动画开始时，x轴坐标</p></li><li>fromYDelta：表示动画开始时，y轴坐标</li><li>toXDelta：表示动画结束时，x轴坐标</li><li>toYDelta：表示动画结束时，y轴坐标</li></ul><blockquote><p>关于toXDelta，toYDelta的值，需要注意的是，可以设置三种类型的值，例如设置50：表示50个像素<br>50%：表示自身大小的一半，记住这里是可以设置百分号的，他等于0.5，如果设置0.5表示绝对值0.5<br>50%p：表示父元素大小的一半，p是相对于父元素</p></blockquote><ul><li><p><strong>缩放动画，名称为scale.xml</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:duration=&quot;3000&quot;</span><br><span class="line">    android:fromXScale=&quot;1&quot;</span><br><span class="line">    android:fromYScale=&quot;1&quot;</span><br><span class="line">    android:toXScale=&quot;2&quot;</span><br><span class="line">    android:toYScale=&quot;2&quot;</span><br><span class="line">    android:pivotX=&quot;50%&quot;</span><br><span class="line">    android:pivotY=&quot;0%&quot;&gt;</span><br><span class="line">&lt;/scale&gt;</span><br></pre></td></tr></table></figure></li><li><p>fromXScale，fromYScale：表示动画开始时x,y的缩放大小</p></li><li>toXScale，toYScale：表示动画结束时x,y的缩放大小</li><li>1表示本身，数值越大，缩放比例越大</li><li>pivotX，piovtY：缩放的中心坐标位置，可以设置值与平移动画可以设置的类似<blockquote><p>50： 表示50个像素，是绝对值<br>50%： 表示自身中心位置<br>50%p ：表示父元素的中心位置，p表示相对于父元素</p></blockquote></li></ul><ul><li><strong>旋转动画，名称为rotate.xml</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:duration=&quot;3000&quot;</span><br><span class="line">    android:fromDegrees=&quot;0&quot;</span><br><span class="line">    android:toDegrees=&quot;360&quot;</span><br><span class="line">    android:pivotX=&quot;50%&quot;</span><br><span class="line">    android:pivotY=&quot;50%&quot;&gt;</span><br><span class="line">&lt;/rotate&gt;</span><br></pre></td></tr></table></figure><ul><li>fromDegrees：表示动画开始的角度</li><li>toDegrees：表示动画结束的角度，正数为顺时针，负数为逆时针</li><li>pivotX，pivotY：表示旋转的中心坐标位置，设置方式与缩放相似</li></ul><h5 id="在java代码中引用"><a href="#在java代码中引用" class="headerlink" title="在java代码中引用"></a>在java代码中引用</h5><ul><li>xml文件定义好后，我们就需要在代码中进行使用，可以先定义一个View,之后在界面中find出来，之后view设置动画。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 旋转动画</span><br><span class="line"> */</span><br><span class="line">private void rotate() &#123;</span><br><span class="line">    Animation rotate = AnimationUtils.loadAnimation(this, R.anim.rotate);</span><br><span class="line">    ivImg.startAnimation(rotate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 缩放动画</span><br><span class="line"> */</span><br><span class="line">private void scale() &#123;</span><br><span class="line">    Animation scale = AnimationUtils.loadAnimation(this, R.anim.scale);</span><br><span class="line">    ivImg.startAnimation(scale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 平移动画</span><br><span class="line"> */</span><br><span class="line">private void translate() &#123;</span><br><span class="line">    Animation translate = AnimationUtils.loadAnimation(this, R.anim.translate);</span><br><span class="line">    ivImg.startAnimation(translate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 渐变动画</span><br><span class="line"> */</span><br><span class="line">private void alpha() &#123;</span><br><span class="line">    Animation alpha = AnimationUtils.loadAnimation(this, R.anim.alpha);</span><br><span class="line">    ivImg.startAnimation(alpha);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java代码来实现"><a href="#Java代码来实现" class="headerlink" title="Java代码来实现"></a>Java代码来实现</h4><ul><li>接下来我们用代码来实现这个四种动画</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 旋转动画</span><br><span class="line"> */</span><br><span class="line">private void rotate()&#123;</span><br><span class="line">    RotateAnimation rotate = new RotateAnimation(0,360, Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);</span><br><span class="line">    rotate.setDuration(3000);</span><br><span class="line">    ivImg.startAnimation(rotate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 缩放动画</span><br><span class="line"> */</span><br><span class="line">private void scale()&#123;</span><br><span class="line">    ScaleAnimation scale = new ScaleAnimation(1, 2, 1, 2, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);</span><br><span class="line">    scale.setDuration(3000);</span><br><span class="line">    ivImg.startAnimation(scale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 平移动画</span><br><span class="line"> */</span><br><span class="line">private void translate()&#123;</span><br><span class="line">    TranslateAnimation translate = new TranslateAnimation(0, 200, 0, 0);</span><br><span class="line">    translate.setDuration(3000);</span><br><span class="line">    ivImg.startAnimation(translate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 渐变动画</span><br><span class="line"> */</span><br><span class="line">private void alpha()&#123;</span><br><span class="line">    AlphaAnimation alpha = new AlphaAnimation(1.0f, 0.0f);</span><br><span class="line">    alpha.setDuration(3000);</span><br><span class="line">    ivImg.startAnimation(alpha);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="给动画设置监听事件"><a href="#给动画设置监听事件" class="headerlink" title="给动画设置监听事件"></a>给动画设置监听事件</h5><ul><li>动画我们已经实现了，但是如果你需要在动画的执行过程中，做某些操作怎么办呐？比如在动画开始的时候提示一下动画的开始，在动画的结束时，我们提示动画的结束，这我们又能怎么做呐？</li><li>无论是rotate、scale、translate、alpha他们都有一个监听事件，如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rotate.setAnimationListener(new Animation.AnimationListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onAnimationStart(Animation animation) &#123;</span><br><span class="line">        //动画开始</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onAnimationEnd(Animation animation) &#123;</span><br><span class="line">        //动画结束</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onAnimationRepeat(Animation animation) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>根据不同的状态做相应的操作</li></ul><h4 id="组合动画"><a href="#组合动画" class="headerlink" title="组合动画"></a>组合动画</h4><ul><li>串行动画</li><li>并行动画</li><li>即串行又并行动画</li></ul><h5 id="xml方式实现组合动画"><a href="#xml方式实现组合动画" class="headerlink" title="xml方式实现组合动画"></a>xml方式实现组合动画</h5><ul><li><strong>定义一个flay.xml文件</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration=&quot;3000&quot;</span><br><span class="line">        android:fromXDelta=&quot;0&quot;</span><br><span class="line">        android:fromYDelta=&quot;0&quot;</span><br><span class="line">        android:toXDelta=&quot;0&quot;</span><br><span class="line">        android:toYDelta=&quot;-300&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;rotate</span><br><span class="line">        android:duration=&quot;3000&quot;</span><br><span class="line">        android:fromDegrees=&quot;0&quot;</span><br><span class="line">        android:pivotX=&quot;50%&quot;</span><br><span class="line">        android:pivotY=&quot;50%&quot;</span><br><span class="line">        android:startOffset=&quot;3000&quot;</span><br><span class="line">        android:toDegrees=&quot;-45&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;scale</span><br><span class="line">        android:duration=&quot;3000&quot;</span><br><span class="line">        android:fromXScale=&quot;1&quot;</span><br><span class="line">        android:fromYScale=&quot;1&quot;</span><br><span class="line">        android:pivotX=&quot;50%&quot;</span><br><span class="line">        android:pivotY=&quot;50%&quot;</span><br><span class="line">        android:startOffset=&quot;3000&quot;</span><br><span class="line">        android:toXScale=&quot;2&quot;</span><br><span class="line">        android:toYScale=&quot;2&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;alpha</span><br><span class="line">        android:duration=&quot;3000&quot;</span><br><span class="line">        android:fromAlpha=&quot;1.0&quot;</span><br><span class="line">        android:startOffset=&quot;3000&quot;</span><br><span class="line">        android:toAlpha=&quot;0.0&quot; /&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure><ul><li>代码加载上面的xml</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void Anim() &#123;</span><br><span class="line">    Animation animation = AnimationUtils.loadAnimation(this, R.anim.flay);</span><br><span class="line">    ivImg.startAnimation(animation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Java代码中实现组合动画"><a href="#Java代码中实现组合动画" class="headerlink" title="Java代码中实现组合动画"></a>Java代码中实现组合动画</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void anim() &#123;</span><br><span class="line">    AlphaAnimation alphaAnimation = new AlphaAnimation(1.0f, 0.0f);</span><br><span class="line">    alphaAnimation.setDuration(3000);</span><br><span class="line"></span><br><span class="line">    TranslateAnimation translateAnimation = new TranslateAnimation(0, 200, 0, 0);</span><br><span class="line">    translateAnimation.setDuration(3000);</span><br><span class="line"></span><br><span class="line">    ScaleAnimation scaleAnimation = new ScaleAnimation(1, 2, 1, 2, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);</span><br><span class="line">    scaleAnimation.setDuration(3000);</span><br><span class="line"></span><br><span class="line">    //true表示是否公用插值器</span><br><span class="line">    AnimationSet animationSet = new AnimationSet(true);</span><br><span class="line">    animationSet.addAnimation(alphaAnimation);</span><br><span class="line">    animationSet.addAnimation(translateAnimation);</span><br><span class="line">    animationSet.addAnimation(scaleAnimation);</span><br><span class="line">    ivImg.startAnimation(animationSet);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插值器（Interpolator）"><a href="#插值器（Interpolator）" class="headerlink" title="插值器（Interpolator）"></a>插值器（Interpolator）</h4><ul><li>通俗易懂的说，Interpolator负责控制动画变化的速率，使得基本的动画效果能够以匀速、加速、减速、抛物线速率等各种速率变化。</li></ul><h5 id="在xml中设置"><a href="#在xml中设置" class="headerlink" title="在xml中设置"></a>在xml中设置</h5><ul><li>在res/anim文件夹下，创建一个名为scale_interpolator.xml的文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:duration=&quot;3000&quot;</span><br><span class="line">    android:fromXScale=&quot;0.0&quot;</span><br><span class="line">    android:fromYScale=&quot;0.0&quot;</span><br><span class="line">    android:interpolator=&quot;@android:anim/overshoot_interpolator&quot;</span><br><span class="line">    android:pivotX=&quot;50%&quot;</span><br><span class="line">    android:pivotY=&quot;50%&quot;</span><br><span class="line">    android:toXScale=&quot;2&quot;</span><br><span class="line">    android:toYScale=&quot;2&quot;&gt;</span><br><span class="line">&lt;/scale&gt;</span><br></pre></td></tr></table></figure><ul><li>在java代码中引用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void Anim() &#123;</span><br><span class="line">     Animation animation = AnimationUtils.loadAnimation(this, R.anim.scale_interpolator);</span><br><span class="line">     ivImg.startAnimation(animation);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="直接在Java代码中设置插值器"><a href="#直接在Java代码中设置插值器" class="headerlink" title="直接在Java代码中设置插值器"></a>直接在Java代码中设置插值器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void Anim2() &#123;</span><br><span class="line">    //创建透明度动画的对象以及设置动画效果</span><br><span class="line">    AlphaAnimation alphaAnimation = new AlphaAnimation(1, 0);</span><br><span class="line">    alphaAnimation.setDuration(3000);</span><br><span class="line">    //创建对应插值器类对象</span><br><span class="line">    OvershootInterpolator overshootInterpolator = new OvershootInterpolator();</span><br><span class="line">    //给动画设置插值器</span><br><span class="line">    alphaAnimation.setInterpolator(overshootInterpolator);</span><br><span class="line">    //播放动画</span><br><span class="line">    ivImg.startAnimation(alphaAnimation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插值器的类型"><a href="#插值器的类型" class="headerlink" title="插值器的类型"></a>插值器的类型</h5><ul><li>Android内置了9种插值器的类型</li></ul><table><thead><tr><th>作用</th><th>资源ID</th><th>对应的java类</th></tr></thead><tbody><tr><td>动画加速进行</td><td>@android:anim/accelerate_interpolator</td><td>AccelerateInterpolator</td></tr><tr><td>快速完成动画，超出再回到结束样式</td><td>@android:anim/overshoot_interpolator</td><td>OvershootInterpolator</td></tr><tr><td>先加速再减速</td><td>@android:anim/accelerate_decelerate_interpolator</td><td>AccelerateDecelerateInterpolator</td></tr><tr><td>先退后再加速前进</td><td>@android:anim/anticipate_interpolator</td><td>AnticipateInterpolator</td></tr><tr><td>先退后再加速前进，超出终点后再回终点</td><td>@android:anim/anticipate_overshoot_interpolator</td><td>AnticipateOvershootInterpolator</td></tr><tr><td>最后阶段弹球效果</td><td>@android:anim/bounce_interpolator</td><td>BounceInterpolator</td></tr><tr><td>周期运动</td><td>@android:anim/cycle_interpolator</td><td>CycleInterpolator</td></tr><tr><td>减速</td><td>@android:anim/decelerate_interpolator</td><td>DecelerateInterpolator</td></tr><tr><td>匀速</td><td>@android:anim/linear_interpolator</td><td>LinearInterpolator</td></tr></tbody></table><ul><li>使用时：<ul><li>当在XML文件设置插值器时，只需传入对应的插值器资源ID即可</li><li>当在Java代码设置插值器时，只需创建对应的插值器对象即可</li><li>系统默认的插值器是AccelerateDecelerateInterpolator，即先加速后减速</li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Android </tag>
            
            <tag> 动画 </tag>
            
            <tag> 视图动画 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rxjava2.0教程（九）</title>
      <link href="/2018/11/29/Rxjava2-0%E6%95%99%E7%A8%8B%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
      <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><blockquote><p>本文只作为转载，<strong>著作权归原作者(Season_zlc)所有</strong>，原文地址:<a href="https://www.jianshu.com/p/36e0f7f43a51" target="_blank" rel="noopener">https://www.jianshu.com/p/36e0f7f43a51</a></p></blockquote><a id="more"></a><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><ul><li>先来回顾一下上上节，我们讲Flowable的时候，说它采用了 <strong>响应式拉</strong>的方式，我们还举了个 <strong>叶问打小日本</strong>的例子，再来回顾一下吧，我们说把 <strong>上游</strong>看成 <strong>小日本</strong>, 把 <strong>下游</strong>当作 <strong>叶问</strong>, 当调用<code>Subscription.request(1)</code>时, <strong>叶问</strong>就说 <strong>我要打一个!</strong> 然后 <strong>小日本</strong>就拿出 <strong>一个鬼子</strong>给叶问, 让他打, 等叶问打死这个鬼子之后, 再次调用<code>request(10)</code>, 叶问就又说 <strong>我要打十个!</strong> 然后小日本又派出 <strong>十个鬼子</strong>给叶问, 然后就在边上看热闹, 看叶问能不能打死十个鬼子, 等叶问打死十个鬼子后再继续要鬼子接着打。</li><li>但是不知道大家有没有发现，在我们前两节中的例子中，我们口中声称的响应式拉并没有完全体现出来，比如这个例子：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, &quot;emit 1&quot;);</span><br><span class="line">        e.onNext(1);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit 2&quot;);</span><br><span class="line">        e.onNext(2);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit 3&quot;);</span><br><span class="line">        e.onNext(3);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit complete&quot;);</span><br><span class="line">        e.onComplete();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.ERROR).subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">                mSucription = s;</span><br><span class="line">                s.request(1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line"></span><br><span class="line">            public void onNext(Integer integer) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onNext: &quot; + integer);</span><br><span class="line">                mSucription.request(1);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable t) &#123;</span><br><span class="line">                Log.w(TAG, &quot;onError: &quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">                Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li>虽然我们在下游中是每次处理掉了一个事件之后才调用request(1)去请求下一个事件，也就是说叶问的确是在打死了一个鬼子之后才继续打下一个鬼子，可是上游呢？上游真的是每次当下游请求一个才拿出一个吗？从上上篇文章中我们知道并不是这样的，上游仍然是一开始就发送了所有的事件，也就是说小日本并没有等叶问打死一个才拿出一个，而是一开始就拿出了所有的鬼子，这些鬼子从一开始就在这儿排队等着被打死。</li><li>有个故事是这么说的：<blockquote><p>楚人有卖盾与矛者，先誉其盾之坚，曰：“吾盾之坚，物莫能陷也。”俄而又誉其矛之利，曰：“吾矛之利，万物莫不陷也。”市人诘之曰：”以子之矛陷子之盾，何如？”其人弗能应也。众皆笑之。</p></blockquote></li><li>没错，我们前后所说的就是自相矛盾了，这说明了什么呢，说明我们的实现并不是一个完整的实现，那么，究竟怎样的实现才是完整的呢？</li><li>我们先自己来想一想，在下游中调用Subscription.request(n)就可以告诉上游，下游能够处理多少个事件，那么上游要根据下游的处理能力正确的去发送事件，那么上游是不是应该知道下游的处理能力是多少啊，对吧，不然，一个巴掌拍不响啊，这种事情得你情我愿才行。</li><li>那么上游从哪里得知下游的处理能力呢？我们来看看上游最重要的部分，肯定就是FlowableEmitter了啊，我们就是通过它来发送事件的啊，来看看它的源码吧(别紧张，它的代码灰常简单)：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface FlowableEmitter&lt;T&gt; extends Emitter&lt;T&gt; &#123; </span><br><span class="line"> void setDisposable(Disposable s); </span><br><span class="line"> void setCancellable(Cancellable c); </span><br><span class="line"> /** </span><br><span class="line">  * The current outstanding request amount.</span><br><span class="line">  * &lt;p&gt;This method is thread-safe.</span><br><span class="line">  * @return the current outstanding request amount</span><br><span class="line">  */ </span><br><span class="line"> long requested(); </span><br><span class="line"> boolean isCancelled(); </span><br><span class="line"> FlowableEmitter&lt;T&gt; serialize(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>FlowableEmitter是个接口，继承Emitter，Emitter里面就是我们的onNext(),onComplete()和onError()三个方法。我们看到FlowableEmitter中有这么一个方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long requested();</span><br></pre></td></tr></table></figure><ul><li>方法注释的意思就是当前外部请求的数量，哇哦，这好像就是我们要找的答案呢. 我们还是实际验证一下吧.</li><li>先来看同步的情况吧：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, &quot;current requested: &quot; + e.requested());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.ERROR)</span><br><span class="line">        .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onSubscription&quot;);</span><br><span class="line">                mSucription = s;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Integer integer) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onNext: &quot; + integer);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable t) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onError: &quot;, t);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">                Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li>这个例子中，我们在上游中打印出当前的request数量，下游什么也不做。</li><li>我们先猜测一下结果，下游没有调用request()，说明当前下游的处理能力为0，那么上游得到的requested也应该是0，是不是呢？</li><li>来看看运行结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D/TAG: onSubscribe</span><br><span class="line">D/TAG: current requested: 0</span><br></pre></td></tr></table></figure><ul><li>哈哈，结果果然是0，说明我们的结论基本上是对的。</li><li>那下游要是调用了request()呢，来看看：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, &quot;current requested: &quot; + e.requested());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.ERROR).subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Subscription s) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">        mSucription = s;</span><br><span class="line">        //我要打十个</span><br><span class="line">        s.request(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(Integer integer) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onNext: &quot; + integer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable t) &#123;</span><br><span class="line">        Log.w(TAG, &quot;onError: &quot;, t);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>这次在下游中调用了request(10)，告诉上游我要打十个，看看运行结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">D/TAG: onSubscribe</span><br><span class="line">D/TAG: current requested: 10</span><br></pre></td></tr></table></figure><ul><li>果然！上游的requested的确是根据下游的请求来决定的，那要是下游多次请求呢？比如这样：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Flowable</span><br><span class="line">        .create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">                Log.d(TAG, &quot;current requested: &quot; + e.requested());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, BackpressureStrategy.ERROR).subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Subscription s) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">        mSucription = s;</span><br><span class="line">        //我要打十个</span><br><span class="line">        s.request(10);</span><br><span class="line">        //我要打一百个</span><br><span class="line">        s.request(100);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(Integer integer) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onNext: &quot; + integer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable t) &#123;</span><br><span class="line">        Log.w(TAG, &quot;onError: &quot;, t);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>下游先调用了request(10), 然后又调用了request(100)，来看看运行结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D/TAG: onSubscribe</span><br><span class="line">D/TAG: current requested: 110</span><br></pre></td></tr></table></figure><ul><li>看来多次调用也没问题，做了加法。</li><li>诶加法？对哦，只是做加法，那什么时候做减法呢？</li><li>当然是发送事件啦！</li><li>来看个例子吧：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Flowable</span><br><span class="line">        .create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">                Log.d(TAG, &quot;before emit requested = &quot; + e.requested());</span><br><span class="line"></span><br><span class="line">                Log.d(TAG, &quot;emit 1&quot;);</span><br><span class="line">                e.onNext(1);</span><br><span class="line">                Log.d(TAG, &quot;after emit 1,requested = &quot; + e.requested());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                Log.d(TAG, &quot;emit 2&quot;);</span><br><span class="line">                e.onNext(2);</span><br><span class="line">                Log.d(TAG, &quot;after emit 2,requested =&quot; + e.requested());</span><br><span class="line"></span><br><span class="line">                Log.d(TAG, &quot;emit 3&quot;);</span><br><span class="line">                e.onNext(3);</span><br><span class="line">                Log.d(TAG, &quot;after emit 3,requested =&quot; + e.requested());</span><br><span class="line"></span><br><span class="line">                Log.d(TAG, &quot;emit complete&quot;);</span><br><span class="line">                e.onComplete();</span><br><span class="line"></span><br><span class="line">                Log.d(TAG, &quot;after emit complete ,requested = &quot; + e.requested());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, BackpressureStrategy.ERROR)</span><br><span class="line">        .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">                mSucription = s;</span><br><span class="line">                s.request(10);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Integer integer) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onNext: &quot; + integer);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable t) &#123;</span><br><span class="line">                Log.w(TAG, &quot;onError&quot;, t);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">                Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li>代码很简单，来看看运行结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D/TAG: onSubscribe </span><br><span class="line">D/TAG: before emit, requested = 10 </span><br><span class="line">D/TAG: emit 1 D/TAG: onNext: 1 </span><br><span class="line">D/TAG: after emit 1, requested = 9 </span><br><span class="line">D/TAG: emit 2 D/TAG: onNext: 2 </span><br><span class="line">D/TAG: after emit 2, requested = 8 </span><br><span class="line">D/TAG: emit 3 D/TAG: onNext: 3 </span><br><span class="line">D/TAG: after emit 3, requested = 7 </span><br><span class="line">D/TAG: emit complete </span><br><span class="line">D/TAG: onComplete </span><br><span class="line">D/TAG: after emit complete, requested = 7</span><br></pre></td></tr></table></figure><ul><li>大家应该能看出端倪了吧，下游调用request(n) 告诉上游它的处理能力，上游每发送一个next事件之后，requested就减一，注意是next事件，complete和error事件不会消耗requested，当减到0时，则代表下游没有处理能力了，这个时候你如果继续发送事件，会发生什么后果呢？当然是MissingBackpressureException啦，试一试：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Flowable</span><br><span class="line">        .create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">                Log.d(TAG, &quot;before emit , requested = &quot; + e.requested());</span><br><span class="line"></span><br><span class="line">                Log.d(TAG, &quot;emit 1&quot;);</span><br><span class="line">                e.onNext(1);</span><br><span class="line">                Log.d(TAG, &quot;after emit 1, requested =&quot; + e.requested());</span><br><span class="line"></span><br><span class="line">                Log.d(TAG, &quot;emit 2&quot;);</span><br><span class="line">                e.onNext(2);</span><br><span class="line">                Log.d(TAG, &quot;after emit 2, requested =&quot; + e.requested());</span><br><span class="line"></span><br><span class="line">                Log.d(TAG, &quot;emit 3&quot;);</span><br><span class="line">                e.onNext(3);</span><br><span class="line">                Log.d(TAG, &quot;after emit 3, requested = &quot; + e.requested());</span><br><span class="line"></span><br><span class="line">                Log.d(TAG, &quot;emit complete&quot;);</span><br><span class="line">                e.onComplete();</span><br><span class="line"></span><br><span class="line">                Log.d(TAG, &quot;after emit complete ,requested =&quot; + e.requested());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, BackpressureStrategy.ERROR).subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Subscription s) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">        mSucription = s;</span><br><span class="line">        s.request(2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(Integer integer) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onNext: &quot; + integer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable t) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onError: &quot;, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>还是这个例子，只不过这次只request(2), 看看运行结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">D/TAG: onSubscribe </span><br><span class="line">D/TAG: before emit, requested = 2 </span><br><span class="line">D/TAG: emit 1 D/TAG: onNext: 1 </span><br><span class="line">D/TAG: after emit 1, requested = 1 </span><br><span class="line">D/TAG: emit 2 </span><br><span class="line">D/TAG: onNext: 2 </span><br><span class="line">D/TAG: after emit 2, requested = 0 </span><br><span class="line">D/TAG: emit 3 </span><br><span class="line">W/TAG: onError: io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests </span><br><span class="line">at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:411) </span><br><span class="line">at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:377) </span><br><span class="line">at zlc.season.rxjava2demo.demo.ChapterNine$4.subscribe(ChapterNine.java:80) </span><br><span class="line">at io.reactivex.internal.operators.flowable.FlowableCreate.subscribeActual(FlowableCreate.java:72) </span><br><span class="line">at io.reactivex.Flowable.subscribe(Flowable.java:12218) </span><br><span class="line">at zlc.season.rxjava2demo.demo.ChapterNine.demo2(ChapterNine.java:89) </span><br><span class="line">at zlc.season.rxjava2demo.MainActivity$2.onClick(MainActivity.java:36) </span><br><span class="line">at android.view.View.performClick(View.java:4780) </span><br><span class="line">at android.view.View$PerformClick.run(View.java:19866) </span><br><span class="line">at android.os.Handler.handleCallback(Handler.java:739) </span><br><span class="line">at android.os.Handler.dispatchMessage(Handler.java:95) </span><br><span class="line">at android.os.Looper.loop(Looper.java:135) </span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:5254) </span><br><span class="line">at java.lang.reflect.Method.invoke(Native Method) </span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:372) </span><br><span class="line">at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903) </span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698) </span><br><span class="line">D/TAG: after emit 3, requested = 0 </span><br><span class="line">D/TAG: emit complete </span><br><span class="line">D/TAG: after emit complete, requested = 0</span><br></pre></td></tr></table></figure><ul><li>到目前为止我们一直在说同步的订阅，现在同步说完了，我们先用一张图来总结一下同步的情况：<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava32.png" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava32.png"></div></li></ul><ul><li>这张图的意思就是当上下游在同一个线程中的时候，在下游调用request(n)就会直接改变上游中的requested的值，多次调用便会叠加这个值，而上游每发送一个事件之后便会去减少这个值，当这个值减少至0的时候，继续发送事件便会抛异常了。</li><li>我们再来说说异步的情况，异步和同步会有区别吗？会有什么区别呢？带着这个疑问我们继续来探究。</li><li>同样的先来看一个基本的例子：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Flowable</span><br><span class="line">        .create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">                Log.d(TAG, &quot;current requested: &quot; + e.requested());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, BackpressureStrategy.ERROR).subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">                mSucription = s;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Integer integer) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onNext: &quot; + integer);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable t) &#123;</span><br><span class="line">                Log.w(TAG, &quot;onError: &quot;, t);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">                Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li>这次是异步的情况，上游啥也不做，下游也啥也不做，来看看运行结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D/TAG: onSubscribe</span><br><span class="line">D/TAG: current requested: 128</span><br></pre></td></tr></table></figure><ul><li>哈哈，又是128，看了我前几篇文章的朋友肯定很熟悉这个数字啊！这个数字为什么和我们之前所说的默认的水缸大小一样啊，莫非？</li><li>带着这个疑问我们继续来研究一下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Flowable</span><br><span class="line">        .create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">                Log.d(TAG, &quot;current requested: &quot; + e.requested());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, BackpressureStrategy.ERROR)</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">                mSucription = s;</span><br><span class="line">                //我要打1000个</span><br><span class="line">                s.request(1000);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Integer integer) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onNext: &quot; + integer);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable t) &#123;</span><br><span class="line">                Log.w(TAG, &quot;onError: &quot; + t);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">                Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li>这次我们在下游调用了request（1000）告诉上游我要打1000个，按照之前我们说的，这次的运行结果应该是1000，来看看运行结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D/TAG: onSubscribe</span><br><span class="line">D/TAG: current requested: 128</span><br></pre></td></tr></table></figure><ul><li>卧槽，你确定你没贴错代码？</li><li>是的，真相就是这样，就是128，蜜汁128。。。</li><li>为了答疑解惑，我就直接上图了：<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava33.png" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava33.png"></div></li></ul><ul><li>可以看到，当上下游工作在不同的线程里时，每一个线程里都有一个requested，而我们调用request（1000）时，实际上改变的是下游主线程中的requested，而上游中的requested的值是由RxJava内部调用request(n)去设置的，这个调用会在合适的时候自动触发。</li><li>现在我们就能理解为什么没有调用request，上游中的值是128了，因为下游在一开始就在内部调用了request(128)去设置了上游中的值，因此即使下游没有调用request()，上游也能发送128个事件，这也可以解释之前我们为什么说Flowable中默认的水缸大小是128，其实就是这里设置的。</li><li>刚才同步的时候我们说了，上游每发送一个事件，requested的值便会减一，对于异步来说同样如此，那有人肯定有疑问了，一开始上游的requested的值是128，那这128个事件发送完了不就不能继续发送了吗？</li><li>刚刚说了，设置上游requested的值的这个内部调用会在合适的时候自动触发，那到底什么时候是合适的时候呢？是发完128个事件才去调用吗？还是发送了一半才去调用呢？</li><li>带着这个疑问我们来看下一段代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 点击request</span><br><span class="line"> */</span><br><span class="line">public void request(View view) &#123;</span><br><span class="line">    mSucription.request(96);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void testRxjava9() &#123;</span><br><span class="line">    Flowable</span><br><span class="line">            .create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">                    Log.d(TAG, &quot;First requested = &quot; + e.requested());</span><br><span class="line">                    boolean flag;</span><br><span class="line">                    for (int i = 0; ; i++) &#123;</span><br><span class="line">                        flag = false;</span><br><span class="line">                        while (e.requested() == 0) &#123;</span><br><span class="line">                            if (!flag) &#123;</span><br><span class="line">                                Log.d(TAG, &quot;Oh No I can&apos;t emit value!&quot;);</span><br><span class="line">                                flag = true;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        e.onNext(i);</span><br><span class="line">                        Log.d(TAG, &quot;emit &quot; + i + &quot;,requested = &quot; + e.requested());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, BackpressureStrategy.ERROR)</span><br><span class="line">            .subscribeOn(Schedulers.io())</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                    Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">                    mSucription = s;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onNext(Integer integer) &#123;</span><br><span class="line">                    Log.d(TAG, &quot;onNext: &quot; + integer);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onError(Throwable t) &#123;</span><br><span class="line">                    Log.w(TAG, &quot;onError: &quot;, t);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onComplete() &#123;</span><br><span class="line">                    Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这次的上游稍微复杂了一点点，首先仍然是个无限循环发事件，但是是有条件的，只有当上游的requested != 0的时候才会发事件，然后我们调用request（96）去消费96个事件（为什么是96而不是其他的数字先不要管），来看看运行结果吧：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">D/TAG: onSubscribe </span><br><span class="line">D/TAG: First requested = 128 </span><br><span class="line">D/TAG: emit 0 , requested = 127 </span><br><span class="line">D/TAG: emit 1 , requested = 126 </span><br><span class="line">D/TAG: emit 2 , requested = 125</span><br><span class="line"> ... </span><br><span class="line">D/TAG: emit 124 , requested = 3 </span><br><span class="line">D/TAG: emit 125 , requested = 2 </span><br><span class="line">D/TAG: emit 126 , requested = 1 </span><br><span class="line">D/TAG: emit 127 , requested = 0 </span><br><span class="line">D/TAG: Oh no! I can&apos;t emit value!</span><br></pre></td></tr></table></figure><ul><li>首先运行之后上游便会发送完128个事件，之后便不做任何事情，从打印的结果中我们也可以看出这一点。</li><li>然后我们调用request(96)，这会让下游去消费96个事件，来看看运行结果吧：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">D/TAG: onNext: 0 </span><br><span class="line">D/TAG: onNext: 1</span><br><span class="line">... </span><br><span class="line">D/TAG: onNext: 92 </span><br><span class="line">D/TAG: onNext: 93 </span><br><span class="line">D/TAG: onNext: 94 </span><br><span class="line">D/TAG: onNext: 95 </span><br><span class="line">D/TAG: emit 128 , requested = 95 </span><br><span class="line">D/TAG: emit 129 , requested = 94 </span><br><span class="line">D/TAG: emit 130 , requested = 93 </span><br><span class="line">D/TAG: emit 131 , requested = 92</span><br><span class="line">... </span><br><span class="line">D/TAG: emit 219 , requested = 4 </span><br><span class="line">D/TAG: emit 220 , requested = 3 </span><br><span class="line">D/TAG: emit 221 , requested = 2 </span><br><span class="line">D/TAG: emit 222 , requested = 1 </span><br><span class="line">D/TAG: emit 223 , requested = 0 </span><br><span class="line">D/TAG: Oh no! I can&apos;t emit value!</span><br></pre></td></tr></table></figure><ul><li>可以看到，当下游消费掉第96个事件之后，上游又开始发事件了，而且可以看到当前上游的requested的值是96(打印出来的95是已经发送了一个事件减一之后的值)，最终发出了第223个事件之后又进入了等待区，而223-127 正好等于 96。</li><li>这是不是说明当下游每消费96个事件便会自动触发内部的request()去设置上游的requested的值啊！没错，就是这样，而这个新的值就是96。</li><li>朋友们可以手动试试请求95个事件，上游是不会继续发送事件的。</li><li>至于这个96是怎么得出来的（肯定不是我猜的蒙的啊），感兴趣的朋友可以自行阅读源码寻找答案，对于初学者而言应该没什么必要，管它内部怎么实现的呢对吧。</li><li>好了今天的教程就到这里了！通过本节的学习，大家应该知道如何正确的去实现一个完整的响应式拉取了，在某一些场景下，可以在发送事件前先判断当前的requested的值是否大于0，若等于0则说明下游处理不过来了，则需要等待。</li></ul><p><a href="https://pan.baidu.com/s/1k5IWCHU6WRY0LxpAe7XpHA" target="_blank" rel="noopener">(Demo地址)</a></p>]]></content>
      
      <categories>
          
          <category> Rxjava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 转载 </tag>
            
            <tag> Rxjava </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rxjava2.0教程（八）</title>
      <link href="/2018/11/29/Rxjava2-0%E6%95%99%E7%A8%8B%EF%BC%88%E5%85%AB%EF%BC%89/"/>
      <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><blockquote><p>本文只作为转载，<strong>著作权归原作者(Season_zlc)所有</strong>，原文地址:<a href="https://www.jianshu.com/p/a75ecf461e02" target="_blank" rel="noopener">https://www.jianshu.com/p/a75ecf461e02</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>在上一节中, 我们学习了FLowable的一些基本知识, 同时也挖了许多坑, 这一节就让我们来填坑吧.</li></ul><a id="more"></a><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><ul><li>在上一节中最后我们有个例子, 当上游一次性发送128个事件的时候是没有任何问题的, 一旦超过128就会抛出<code>MissingBackpressureException</code>异常, 提示你上游发太多事件了, 下游处理不过来, 那么怎么去解决呢?</li><li>我们先来思考一下, 发送128个事件没有问题是因为<code>FLowable</code>内部有一个大小为128的水缸, 超过128就会装满溢出来, 那既然你水缸这么小, 那我给你换一个 <strong>大水缸</strong>如何, 听上去很有道理的样子, 来试试:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            Log.d(TAG, &quot;emit &quot; + i);</span><br><span class="line">            e.onNext(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.BUFFER).subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">                mSubscription = s;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Integer integer) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onNext: &quot; + integer);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable t) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onError&quot;, t);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">                Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li>这次我们直接让上游发送了1000个事件,下游仍然不调用request去请求, 与之前不同的是, 这次我们用的策略是<code>BackpressureStrategy.BUFFER</code>, 这就是我们的 <strong>新水缸</strong>啦, 这个水缸就比原来的水缸牛逼多了,如果说原来的水缸是95式步枪, 那这个新的水缸就好比黄金AK , 它没有大小限制, 因此可以存放许许多多的事件.</li><li>所以这次的运行结果就是:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">zlc.season.rxjava2demo D/TAG: onSubscribe </span><br><span class="line">zlc.season.rxjava2demo D/TAG: emit 0 </span><br><span class="line">zlc.season.rxjava2demo D/TAG: emit 1 </span><br><span class="line">zlc.season.rxjava2demo D/TAG: emit 2</span><br><span class="line"> ... </span><br><span class="line">zlc.season.rxjava2demo D/TAG: emit 997 </span><br><span class="line">zlc.season.rxjava2demo D/TAG: emit 998 </span><br><span class="line">zlc.season.rxjava2demo D/TAG: emit 999</span><br></pre></td></tr></table></figure><ul><li>不知道大家有没有发现, 换了水缸的FLowable和Observable好像是一样的嘛…</li><li>不错, 这时的FLowable表现出来的特性的确和Observable一模一样, 因此, 如果你像这样单纯的使用FLowable, 同样需要注意OOM的问题, 例如下面这个例子:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        for (int i = 0; ; i++) &#123;</span><br><span class="line">            Log.d(TAG, &quot;emit &quot; + i);</span><br><span class="line">            e.onNext(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.BUFFER).subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">                mSubscription = s;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Integer integer) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onNext: &quot; + integer);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable t) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onError&quot;, t);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">                Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li>按照我们以前学习Observable一样, 让上游无限循环发送事件, 下游一个也不去处理, 来看看运行结果吧:</li></ul><p><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava27.gif" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava27.gif"></div></p><ul><li>同样可以看到, 内存迅速增长, 直到最后抛出OOM. 所以说不要迷恋FLowable, 它只是个传说.<blockquote><p>可能有朋友也注意到了, 之前使用Observable测试的时候内存增长非常迅速, 几秒钟就OOM, 但这里增长速度却比较缓慢, 可以翻回去看之前的文章中的GIF图进行对比, 这也看出FLowable相比Observable, 在性能方面有些不足, 毕竟FLowable内部为了实现响应式拉取做了更多的操作, 性能有所丢失也是在所难免, 因此单单只是说因为FLowable是新兴产物就盲目的使用也是不对的, 也要具体分场景,</p></blockquote></li><li>那除了给FLowable换一个大水缸还有没有其他的办法呢, 因为更大的水缸也只是缓兵之计啊, 动不动就OOM给你看.</li><li>想想看我们之前学习Observable的时候说到的如何解决上游发送事件太快的, 有一招叫从数量上取胜, 同样的FLowable中也有这种方法, 对应的就是BackpressureStrategy.DROP和BackpressureStrategy.LATEST这两种策略.</li><li>从名字上就能猜到它俩是干啥的, Drop就是直接把存不下的事件丢弃,Latest就是只保留最新的事件, 来看看它们的实际效果吧.</li><li>先来看看Drop:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * 点击request按钮</span><br><span class="line">  */</span><br><span class="line">public void request(View view) &#123;</span><br><span class="line">     mSubscription.request(128);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> private void testRxjava3() &#123;</span><br><span class="line">     Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">             for (int i = 0; ; i++) &#123;</span><br><span class="line">                 e.onNext(i);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;, BackpressureStrategy.DROP).subscribeOn(Schedulers.io())</span><br><span class="line">             .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">             .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">                 @Override</span><br><span class="line">                 public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                     Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">                     mSubscription = s;</span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 @Override</span><br><span class="line">                 public void onNext(Integer integer) &#123;</span><br><span class="line">                     Log.d(TAG, &quot;onNext: &quot; + integer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 @Override</span><br><span class="line">                 public void onError(Throwable t) &#123;</span><br><span class="line">                     Log.w(TAG, &quot;onError: &quot;, t);</span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 @Override</span><br><span class="line">                 public void onComplete() &#123;</span><br><span class="line">                     Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>我们仍然让上游无限循环发送事件, 这次的策略选择了Drop, 同时把Subscription保存起来, 待会我们在外部调用request(128)时, 便可以看到运行的结果.</li><li><p>我们先来猜一下运行结果, 这里为什么request(128)呢, 因为之前不是已经说了吗, FLowable内部的默认的水缸大小为128, 因此, 它刚开始肯定会把0-127这128个事件保存起来, 然后丢弃掉其余的事件, 当我们request(128)的时候,下游便会处理掉这128个事件, 那么上游水缸中又会重新装进新的128个事件, 以此类推, 来看看运行结果吧:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava28.gif" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava28.gif"></div></p></li><li><p>从运行结果中我们看到的确是如此, 第一次request的时候, 下游的确收到的是0-127这128个事件, 但第二次request的时候就不确定了, 因为上游一直在发送事件. 内存占用也很正常, drop的作用相信大家也很清楚了.</p></li><li>再来看看Latest吧:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 点击request按钮</span><br><span class="line"> */</span><br><span class="line">public void request(View view) &#123;</span><br><span class="line">    mSubscription.request(128);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * LATEST</span><br><span class="line"> */</span><br><span class="line">private void testRxjava4() &#123;</span><br><span class="line">    Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">            for (int i = 0; ; i++) &#123;</span><br><span class="line">                e.onNext(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, BackpressureStrategy.LATEST).subscribeOn(Schedulers.io())</span><br><span class="line">            .subscribeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                    Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">                    mSubscription = s;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onNext(Integer integer) &#123;</span><br><span class="line">                    Log.d(TAG, &quot;onNext: &quot; + integer);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onError(Throwable t) &#123;</span><br><span class="line">                    Log.d(TAG, &quot;onError&quot;, t);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onComplete() &#123;</span><br><span class="line">                    Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>同样的, 上游无限循环发送事件, 策略选择Latest, 同时把Subscription保存起来, 方便在外部调用request(128).来看看这次的运行结果:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava29.gif" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava29.gif"></div></p></li><li><p>诶, 看上去好像和Drop差不多啊, Latest也首先保存了0-127这128个事件, 等下游把这128个事件处理了之后才进行之后的处理, 光从这里没有看出有任何区别啊…</p><blockquote><p>古人云，师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师，其为惑也，终不解矣．</p></blockquote></li><li>作为初学者的 <strong>入门导师</strong>, 是不能给大家留下一点点疑惑的, 来让我们继续揭开这个疑问.</li><li>我们把上面两段代码改良一下, 先来看看DROP的改良版:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            e.onNext(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.DROP).subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">                mSubscription = s;</span><br><span class="line">                //一开始就处理128个事件</span><br><span class="line">                s.request(128);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Integer integer) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onNext:&quot; + integer);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable t) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onError:&quot;, t);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">                Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li><p>这段代码和之前有两点不同, 一是上游只发送了10000个事件, 二是下游在一开始就立马处理掉了128个事件, 然后我们在外部再调用request(128)试试, 来看看运行结果:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava30.gif" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava30.gif"></div></p></li><li><p>这次可以看到, 一开始下游就处理掉了128个事件, 当我们再次request的时候, 只得到了第3317的事件, 后面的事件直接被抛弃了.</p></li><li>再来看看Latest的运行结果吧:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava31.gif" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava31.gif"></div></li><li>从运行结果中可以看到, 除去前面128个事件, 与Drop不同, Latest总是能获取到最后最新的事件, 例如这里我们总是能获得最后一个事件9999.</li><li>好了, 关于FLowable的策略我们也讲完了, 有些朋友要问了, 这些FLowable是我自己创建的, 所以我可以选择策略, 那面对有些FLowable并不是我自己创建的, 该怎么办呢? 比如RxJava中的interval操作符, 这个操作符并不是我们自己创建的, 来看下面这个例子吧:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Flowable.interval(1, TimeUnit.MICROSECONDS)</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(new Subscriber&lt;Long&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">                mSubscription = s;</span><br><span class="line">                s.request(Long.MAX_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Long aLong) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onNext:&quot; + aLong);</span><br><span class="line">                try &#123;</span><br><span class="line">                    //延时一秒</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable t) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onError&quot;, t);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">                Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li>interval操作符发送Long型的事件, 从0开始, 每隔指定的时间就把数字加1并发送出来, 在这个例子里, 我们让它每隔1毫秒就发送一次事件, 在下游延时1秒去接收处理, 不用猜也知道结果是什么:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zlc.season.rxjava2demo D/TAG: onSubscribe </span><br><span class="line">zlc.season.rxjava2demo W/TAG: onError: io.reactivex.exceptions.MissingBackpressureException: Can&apos;t deliver value 128 due to lack of requests </span><br><span class="line">at io.reactivex.internal.operators.flowable.FlowableInterval$IntervalSubscriber.run(FlowableInterval.java:87) </span><br><span class="line">at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:428) </span><br><span class="line">at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:278) </span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:273) </span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133) </span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607) </span><br><span class="line">at java.lang.Thread.run(Thread.java:761)</span><br></pre></td></tr></table></figure><ul><li>一运行就抛出了MissingBackpressureException异常, 提醒我们发太多了, 那么怎么办呢, 这个又不是我们自己创建的FLowable啊…</li><li>别慌, 虽然不是我们自己创建的, 但是RxJava给我们提供了其他的方法:<ul><li>onBackpressureBuffer()</li><li>onBackpressureDrop()</li><li>onBackpressureLatest()</li></ul></li><li>熟悉吗? 这跟我们上面学的策略是一样的, 用法也简单, 拿刚才的例子现学现用:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Flowable.interval(1, TimeUnit.MICROSECONDS)</span><br><span class="line">        .onBackpressureDrop()</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(new Subscriber&lt;Long&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">                mSubscription = s;</span><br><span class="line">                s.request(Long.MAX_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Long aLong) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onNext: &quot; + aLong);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable t) &#123;</span><br><span class="line">                Log.w(TAG, &quot;onError: &quot;, t);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">                Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li>其余的我就不一一列举了.</li><li>好了, 今天的教程就到这里吧, 这一节我们学习了如何使用内置的BackpressureStrategy来解决上下游事件速率不均衡的问题. 这些策略其实之前我们将Observable的时候也提到过, 其实大差不差, 只要理解了为什么会上游发事件太快, 下游处理太慢这一点, 你就好处理了, FLowable无非就是给你封装好了, 确实对初学者友好一点, 但是很多初学者往往只知道How, 却不知道Why, 最重要的其实是知道why, 而不是How.</li></ul>]]></content>
      
      <categories>
          
          <category> Rxjava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 转载 </tag>
            
            <tag> Rxjava </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rxjava2.0教程（七）</title>
      <link href="/2018/11/29/Rxjava2-0%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><blockquote><p>本文只作为转载，<strong>著作权归原作者(Season_zlc)所有</strong>，原文地址:<a href="https://www.jianshu.com/p/9b1304435564" target="_blank" rel="noopener">https://www.jianshu.com/p/9b1304435564</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>上一节里我们学习了只使用<code>Observable</code>如何去解决上下游流速不均衡的问题, 之所以学习这个是因为<code>Observable</code>还是有很多它使用的场景, 有些朋友自从听说了<code>Flowable</code>之后就觉得<code>Flowable</code>能解决任何问题, 甚至有抛弃<code>Observable</code>这种想法, 这是万万不可的, 它们都有各自的优势和不足.</li><li>在这一节里我们先来学习如何使用<code>Flowable</code>, 它东西比较多, 也比较繁琐, 解释起来也比较麻烦, 但我还是尽量用通俗易懂的话来说清楚, 毕竟, 这是一个通俗易懂的教程.</li></ul><a id="more"></a><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><ul><li>我们还是以两根水管举例子:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava25.png" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava25.png"></div></li><li>之前我们所的上游和下游分别是<code>Observable</code>和<code>Observer</code>, 这次不一样的是上游变成了<code>Flowable</code>, 下游变成了<code>Subscriber</code>, 但是水管之间的连接还是通过<code>subscribe()</code>, 我们来看看最基本的用法吧:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Flowable&lt;Integer&gt; upstream = Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, &quot;emit 1&quot;);</span><br><span class="line">        e.onNext(1);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit 2&quot;);</span><br><span class="line">        e.onNext(2);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit 3&quot;);</span><br><span class="line">        e.onNext(3);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit complete&quot;);</span><br><span class="line">        e.onComplete();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //增加了一个参数</span><br><span class="line">&#125;, BackpressureStrategy.ERROR);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Subscriber&lt;Integer&gt; downstream = new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Subscription s) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">        //注意这句代码</span><br><span class="line">        s.request(Long.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(Integer integer) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onNext: &quot; + integer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable t) &#123;</span><br><span class="line">        Log.w(TAG, &quot;onError:&quot;, t);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">upstream.subscribe(downstream);</span><br></pre></td></tr></table></figure><ul><li>这段代码中，分别创建了一个上游<code>Flowable</code>和下游<code>Subscriber</code>，上下游工作在同一个线程中，和之前的<code>Observable</code>的使用方式只有一点点区别，先来看看运行结果吧:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D/TAG: onSubscribe</span><br><span class="line">D/TAG: emit 1</span><br><span class="line">D/TAG: onNext: 1</span><br><span class="line">D/TAG: emit 2</span><br><span class="line">D/TAG: onNext: 2</span><br><span class="line">D/TAG: emit 3</span><br><span class="line">D/TAG: onNext: 3</span><br><span class="line">D/TAG: emit complete</span><br><span class="line">D/TAG: onComplete</span><br></pre></td></tr></table></figure><ul><li>结果也和我们预期一样的.</li><li>我们注意到这次和<code>Observable</code>有些不同，首先是创建<code>Flowable</code>的时候增加了一个参数，这个参数是用来选择背压，也就是出现上下游流速不均衡的时候应该怎么处理的方法，这里我们直接用<code>BackpressureStrategy.ERROR</code>这种方式，这种方式会出现在上下游流速不均衡的时候直接抛出一个异常，这个异常就是著名的<code>MissingBackpressureException</code>,其余的策略后面再来讲解.</li><li>另外的一个区别是在下游的<code>onSubscribe</code>方法中传给我们的不再是<code>Disposable</code>了，而是<code>Subscription</code>,他们俩有什么区别呢？首先都是上下游中间的一个开关，之前我们说调用<code>Disposable.dispose()</code>方法可以切断水管，同样调用<code>Subscription.cancel()</code>也可以切断水管，不同的地方在于<code>Subscription</code>增加了一个<code>void request(long n)</code>方法，这个方法有什么作用呢，在上面的代码中也有这么一句代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.request(Long.MAX_VALUE);</span><br></pre></td></tr></table></figure><ul><li>这句代码有什么用呢，不要它可以吗？我们来试试:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">         Log.d(TAG, &quot;emit 1&quot;);</span><br><span class="line">         e.onNext(1);</span><br><span class="line">         Log.d(TAG, &quot;emit 2&quot;);</span><br><span class="line">         e.onNext(2);</span><br><span class="line">         Log.d(TAG, &quot;emit 3&quot;);</span><br><span class="line">         e.onNext(3);</span><br><span class="line">         Log.d(TAG, &quot;emit complete&quot;);</span><br><span class="line">         e.onComplete();</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;, BackpressureStrategy.ERROR).subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void onSubscribe(Subscription s) &#123;</span><br><span class="line">         Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void onNext(Integer integer) &#123;</span><br><span class="line">         Log.d(TAG, &quot;onNext:&quot; + integer);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void onError(Throwable t) &#123;</span><br><span class="line">         Log.w(TAG, &quot;onError:&quot;, t);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void onComplete() &#123;</span><br><span class="line">         Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><ul><li>这次我们取消了<code>request</code>这句代码，来看看运行效果:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">2018-11-29 09:47:28.161 9122-9122/com.tianer.ast.learnrxjava2 D/TAG: onSubscribe</span><br><span class="line">2018-11-29 09:47:28.161 9122-9122/com.tianer.ast.learnrxjava2 D/TAG: emit 1</span><br><span class="line">2018-11-29 09:47:28.163 9122-9122/com.tianer.ast.learnrxjava2 W/TAG: onError:</span><br><span class="line">    io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests</span><br><span class="line">        at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:411)</span><br><span class="line">        at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:377)</span><br><span class="line">        at com.tianer.ast.learnrxjava2.SevenActivity$4.subscribe(SevenActivity.java:99)</span><br><span class="line">        at io.reactivex.internal.operators.flowable.FlowableCreate.subscribeActual(FlowableCreate.java:72)</span><br><span class="line">        at io.reactivex.Flowable.subscribe(Flowable.java:12218)</span><br><span class="line">        at com.tianer.ast.learnrxjava2.SevenActivity.testRxjava2(SevenActivity.java:108)</span><br><span class="line">        at com.tianer.ast.learnrxjava2.SevenActivity.onCreate(SevenActivity.java:30)</span><br><span class="line">        at android.app.Activity.performCreate(Activity.java:6848)</span><br><span class="line">        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1119)</span><br><span class="line">        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2697)</span><br><span class="line">        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2805)</span><br><span class="line">        at android.app.ActivityThread.-wrap12(ActivityThread.java)</span><br><span class="line">        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1538)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:102)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:165)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:6354)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:883)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:773)</span><br><span class="line">2018-11-29 09:47:28.163 9122-9122/com.tianer.ast.learnrxjava2 D/TAG: emit 2</span><br><span class="line">2018-11-29 09:47:28.163 9122-9122/com.tianer.ast.learnrxjava2 D/TAG: emit 3</span><br><span class="line">2018-11-29 09:47:28.163 9122-9122/com.tianer.ast.learnrxjava2 D/TAG: emit complete</span><br></pre></td></tr></table></figure><ul><li>哎哎哎, 大兄弟, 怎么一言不合就抛异常?</li><li>从运行结果中可以看到, 在上游发送第一个事件之后, 下游就抛出了一个著名的MissingBackpressureException异常, 并且下游没有收到任何其余的事件. 可是这是一个同步的订阅呀, 上下游工作在同一个线程, 上游每发送一个事件应该会等待下游处理完了才会继续发事件啊, 不可能出现上下游流速不均衡的问题呀.</li><li>带着这个疑问, 我们再来看看异步的情况:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, &quot;emit 1&quot;);</span><br><span class="line">        e.onNext(1);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit 2&quot;);</span><br><span class="line">        e.onNext(2);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit 3&quot;);</span><br><span class="line">        e.onNext(3);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit complete&quot;);</span><br><span class="line">        e.onComplete();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.ERROR).subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">                mSubscription = s;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Integer integer) &#123;</span><br><span class="line">                Log.d(TAG, &quot;&quot; + integer);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable t) &#123;</span><br><span class="line">                Log.w(TAG, &quot;onError:&quot;, t);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">                Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li>这次我们同样去掉了request这句代码, 但是让上下游工作在不同的线程, 来看看运行结果:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D/TAG: onSubscribe</span><br><span class="line">D/TAG: emit 1</span><br><span class="line">D/TAG: emit 2</span><br><span class="line">D/TAG: emit 3</span><br><span class="line">D/TAG: emit complete</span><br></pre></td></tr></table></figure><ul><li>哎, 这次上游正确的发送了所有的事件, 但是下游一个事件也没有收到. 这是因为什么呢?</li><li>这是因为<code>Flowable</code>在设计的时候采用了一种新的思路也就是 <strong>响应式拉取</strong>的方式来更好的解决上下游流速不均衡的问题, 与我们之前所讲的 <strong>控制数量</strong>和 <strong>控制速度</strong>不太一样, 这种方式用通俗易懂的话来说就好比是 <strong>叶问打鬼子</strong>, 我们把 <strong>上游</strong>看成 <strong>小日本</strong>, 把 <strong>下游</strong>当作 <strong>叶问</strong>, 当调用<code>Subscription.request(1)</code>时, 叶问就说 <strong>我要打一个!</strong> 然后 <strong>小日本</strong>就拿出 <strong>一个鬼子</strong>给叶问, 让他打, 等叶问打死这个鬼子之后, 再次调用<code>request(10)</code>, 叶问就又说 <strong>我要打十个!</strong>然后小日本又派出 <strong>十个鬼子</strong>给叶问, 然后就在边上看热闹, 看叶问能不能打死十个鬼子, 等叶问打死十个鬼子后再继续要鬼子接着打…</li><li>所以我们把request当做是一种能力, 当成 <strong>下游处理事件</strong>的能力, 下游能处理几个就告诉上游我要几个, 这样只要上游根据下游的处理能力来决定发送多少事件, 就不会造成一窝蜂的发出一堆事件来, 从而导致OOM. 这也就完美的解决之前我们所学到的两种方式的缺陷, 过滤事件会导致事件丢失, 减速又可能导致性能损失. 而这种方式既解决了事件丢失的问题, 又解决了速度的问题, 完美 !</li><li>但是太完美的东西也就意味着陷阱也会很多, 你可能只是被它的外表所迷惑, 失去了理智, 如果你滥用或者不遵守规则, 一样会吃到苦头.</li><li>比如这里需要注意的是, 只有当 <strong>上游正确的实现了</strong>如何 <strong>根据下游的处理能力</strong>来发送事件的时候, 才能达到这种效果, 如果上游根本不管下游的处理能力, 一股脑的瞎他妈发事件, 仍然会产生上下游流速不均衡的问题, 这就好比小日本管他叶问要打几个, 老子直接拿出1万个鬼子, 这尼玛有种打死给我看看? 那么 <strong>如何正确的去实现上游</strong>呢, 这里先卖个关子, 之后我们再来讲解.</li><li>学习了request, 我们就可以解释上面的两段代码了.</li><li>首先第一个同步的代码, 为什么上游发送第一个事件后下游就抛出了<code>MissingBackpressureException</code>异常, 这是因为下游没有调用request, 上游就认为下游没有处理事件的能力, 而这又是一个同步的订阅, 既然下游处理不了, 那上游不可能一直等待吧, 如果是这样, 万一这两根水管工作在主线程里, 界面不就卡死了吗, 因此只能抛个异常来提醒我们. 那如何解决这种情况呢, 很简单啦, 下游直接调用request(Long.MAX_VALUE)就行了, 或者根据上游发送事件的数量来request就行了, 比如这里request(3)就可以了.</li><li>然后我们再来看看第二段代码, 为什么上下游没有工作在同一个线程时, 上游却正确的发送了所有的事件呢? 这是因为在<code>Flowable</code>里默认有一个 <strong>大小为128</strong>的水缸, 当上下游工作在不同的线程中时, 上游就会先把事件发送到这个水缸中, 因此, 下游虽然没有调用request, 但是上游在水缸中保存着这些事件, 只有当下游调用request时, 才从水缸里取出事件发给下游.</li><li>是不是这样呢, 我们来验证一下:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public class SevenActivity extends AppCompatActivity &#123;</span><br><span class="line">    private String TAG = &quot;TAG&quot;;</span><br><span class="line">    private Subscription mSubscription;</span><br><span class="line"></span><br><span class="line">    private Button bt_request;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_seven);</span><br><span class="line">        testRxjava4();</span><br><span class="line">        bt_request=findViewById(R.id.bt_request);</span><br><span class="line">        bt_request.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View view) &#123;</span><br><span class="line">                request(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public  void request(long n) &#123;</span><br><span class="line">        mSubscription.request(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void testRxjava4() &#123;</span><br><span class="line">        Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">                Log.d(TAG, &quot;emit 1&quot;);</span><br><span class="line">                e.onNext(1);</span><br><span class="line">                Log.d(TAG, &quot;emit 2&quot;);</span><br><span class="line">                e.onNext(2);</span><br><span class="line">                Log.d(TAG, &quot;emit 3&quot;);</span><br><span class="line">                e.onNext(3);</span><br><span class="line">                Log.d(TAG, &quot;emit complete&quot;);</span><br><span class="line">                e.onComplete();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, BackpressureStrategy.ERROR).subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                        Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">                        mSubscription = s;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onNext(Integer integer) &#123;</span><br><span class="line">                        Log.d(TAG, &quot;onNext:&quot; + integer);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onError(Throwable t) &#123;</span><br><span class="line">                        Log.w(TAG, &quot;onError:&quot;, t);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onComplete() &#123;</span><br><span class="line">                        Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>这里我们把<code>Subscription</code>保存起来, 在界面上增加了一个按钮, 点击一次就调用<code>Subscription.request(1)</code>, 来看看运行结果:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava26.gif" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava26.gif"></div></li><li>结果似乎像那么回事, 上游发送了四个事件保存到了水缸里, 下游每request一个, 就接收一个进行处理.</li><li>刚刚我们有说到水缸的大小为128, 有朋友就问了, 你说128就128吗, 又不是唯品会周年庆, 我不信. 那就来验证一下:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        for (int i = 0; i &lt; 128; i++) &#123;</span><br><span class="line">                Log.d(TAG,&quot;emit&quot;+i);</span><br><span class="line">                e.onNext(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,BackpressureStrategy.ERROR).subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                Log.d(TAG,&quot;onSubscribe&quot;);</span><br><span class="line">                mSubscription=s;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Integer integer) &#123;</span><br><span class="line">                Log.d(TAG,&quot;onNext:&quot;+integer);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable t) &#123;</span><br><span class="line">                Log.w(TAG,&quot;onError:&quot;,t);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">                Log.d(TAG,&quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li>这里我们让上游一次性发送了128个事件, 下游一个也不接收, 来看看运行结果:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zlc.season.rxjava2demo D/TAG: onSubscribe </span><br><span class="line">zlc.season.rxjava2demo D/TAG: emit 0</span><br><span class="line"> ... </span><br><span class="line"> zlc.season.rxjava2demo D/TAG: emit 126 </span><br><span class="line"> zlc.season.rxjava2demo D/TAG: emit 127</span><br></pre></td></tr></table></figure><ul><li>这段代码的运行结果很正常, 没有任何错误和异常, 上游仅仅是发送了128个事件.</li><li>那来试试129个呢, 把上面代码中的128改成129试试:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2018-11-29 10:02:53.133 10144-10384/com.tianer.ast.learnrxjava2 D/TAG: emit0</span><br><span class="line">...</span><br><span class="line">2018-11-29 10:02:53.135 10144-10384/com.tianer.ast.learnrxjava2 D/TAG: emit127</span><br><span class="line">2018-11-29 10:02:53.135 10144-10384/com.tianer.ast.learnrxjava2 D/TAG: emit128</span><br><span class="line">2018-11-29 10:02:53.164 10144-10144/com.tianer.ast.learnrxjava2 W/TAG: onError:</span><br><span class="line">    io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests</span><br><span class="line">        at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:411)</span><br><span class="line">        at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:377)</span><br><span class="line">        at com.tianer.ast.learnrxjava2.SevenActivity$11.subscribe(SevenActivity.java:243)</span><br><span class="line">        at io.reactivex.internal.operators.flowable.FlowableCreate.subscribeActual(FlowableCreate.java:72)</span><br><span class="line">        at io.reactivex.Flowable.subscribe(Flowable.java:12218)</span><br><span class="line">        at io.reactivex.internal.operators.flowable.FlowableSubscribeOn$SubscribeOnSubscriber.run(FlowableSubscribeOn.java:82)</span><br><span class="line">        at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59)</span><br><span class="line">        at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51)</span><br><span class="line">        at java.util.concurrent.FutureTask.run(FutureTask.java:237)</span><br><span class="line">        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:272)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:760)</span><br></pre></td></tr></table></figure><ul><li>这次可以看到, 在上游发送了第129个事件的时候, 就抛出了MissingBackpressureException异常, 提醒我们发洪水啦. 当然了, 这个128也不是我凭空捏造出来的, Flowable的源码中就有这个buffersize的大小定义, 可以自行查看.</li><li>注意这里我们是把上游发送的事件全部都存进了水缸里, 下游一个也没有消费, 所以就溢出了, 如果下游去消费了事件,  <strong>可能</strong>就不会导致水缸溢出来了. 这里我们说的是可能不会, 这也很好理解, 比如刚才这个例子上游发了129个事件, 下游只要快速的消费了一个事件, 就不会溢出了, 但如果下游过了十秒钟再来消费一个, 那肯定早就溢出了.</li></ul>]]></content>
      
      <categories>
          
          <category> Rxjava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 转载 </tag>
            
            <tag> Rxjava </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rxjava2.0教程（六）</title>
      <link href="/2018/11/28/Rxjava2-0%E6%95%99%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><blockquote><p>本文只作为转载，<strong>著作权归原作者(Season_zlc)所有</strong>，原文地址:<a href="https://www.jianshu.com/p/e4c6d7989356" target="_blank" rel="noopener">https://www.jianshu.com/p/e4c6d7989356</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>在上一节中, 我们找到了上下游流速不均衡的源头 , 在这一节里我们将学习如何去治理它 . 可能很多看过其他人写的文章的朋友都会觉得只有<code>Flowable</code>才能解决 , 所以大家对这个<code>Flowable</code>都抱有很大的期许 , 其实呐 , 你们毕竟图样图森破 , 今天我们先抛开<code>Flowable</code>, 仅仅依靠我们自己的 <strong>双手和智慧</strong> , 来看看我们如何去治理 , 通过本节的学习之后我们再来看<code>Flowable</code>, 你会发现它其实并没有想象中那么牛叉, 它只是被其他人过度神化了.</li></ul><a id="more"></a><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><ul><li>我们接着来看上一节的这个例子:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        for (int i = 0; ; i++) &#123;</span><br><span class="line">            e.onNext(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                Log.d(TAG, &quot;&quot; + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li>上一节中我们看到了它的运行结果是直接爆掉了内存, 也明白它为什么就爆掉了内存, 那么我们能做些什么, 才能不让这种情况发生呢.</li><li>之前我们说了, 上游发送的所有事件都放到水缸里了, 所以瞬间水缸就满了, 那我们可以只放我们需要的事件到水缸里呀, 只放一部分数据到水缸里, 这样不就不会溢出来了吗, 因此, 我们把上面的代码修改一下:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">         for (int i = 0; ; i++) &#123;</span><br><span class="line">             e.onNext(i);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).subscribeOn(Schedulers.io())</span><br><span class="line">         .filter(new Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">             @Override</span><br><span class="line">             public boolean test(Integer integer) throws Exception &#123;</span><br><span class="line">                 return integer % 10 == 0;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;)</span><br><span class="line">         .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">         .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">             @Override</span><br><span class="line">             public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                 Log.d(TAG, &quot;&quot; + integer);</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure><ul><li>在这段代码中我们增加了一个<code>filter</code>, 只允许能被10整除的事件通过, 再来看看运行结果:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava20.gif" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava20.gif"></div></li><li>可以看到, 虽然内存依然在增长, 但是增长速度相比之前, 已经减少了太多了, 至少在我录完GIF之前还没有爆掉内存, 大家可以试着改成能被100整除试试.</li><li>可以看到, 通过减少进入水缸的事件数量的确可以缓解上下游流速不均衡的问题, 但是力度还不够, 我们再来看一段代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        for (int i = 0; ; i++) &#123;</span><br><span class="line">            e.onNext(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribeOn(Schedulers.io())</span><br><span class="line">        //Sample取样</span><br><span class="line">        .sample(2, TimeUnit.SECONDS)</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                Log.d(TAG, &quot;&quot; + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li><p>这里用了一个<code>sample</code>操作符, 简单做个介绍, 这个操作符每隔指定的时间就从上游中取出一个事件发送给下游. 这里我们让它每隔2秒取一个事件给下游, 来看看这次的运行结果吧:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava21.gif" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava21.gif"></div></p></li><li><p>这次我们可以看到, 虽然上游仍然一直在不停的发事件, 但是我们只是每隔一定时间取一个放进水缸里, 并没有全部放进水缸里, 因此这次内存仅仅只占用了5M.</p><blockquote><p>大家以后可以出去吹牛逼了: 我曾经通过技术手段去优化一个程序, 最终使得内存占用从300多M变成不到5M. (≧▽≦)/</p></blockquote></li><li>前面这两种方法归根到底其实就是减少放进水缸的事件的数量, 是以 <strong>数量</strong>取胜, 但是这个方法有个 <strong>缺点</strong>, 就是 <strong>丢失了大部分的事件</strong>.</li><li>那么我们换一个角度来思考, 既然上游发送事件的速度太快, 那我们就适当减慢发送事件的速度, 从 <strong>速度</strong>上取胜, 听上去不错, 我们来试试:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        for (int i = 0; ; i++) &#123;</span><br><span class="line">            e.onNext(i);</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                Log.d(TAG, &quot;&quot; + integer);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li><p>这次我们让上游每次发送完事件后都延迟2秒，来看看运行效果:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava22.gif" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava22.gif"></div></p></li><li><p>完美 ! 一切都是那么完美 !</p></li><li>可以看到, 我们给上游加上延时了之后, 瞬间一头发情的公牛就变得跟只小绵羊一样, 如此温顺, 如此平静, 如此平稳的内存线, 美妙极了. 而且事件也没有丢失, 上游通过适当的延时, 不但减缓了事件进入水缸的速度, 也可以让下游有充足的时间从水缸里取出事件来处理 , 这样一来, 就不至于导致大量的事件涌进水缸, 也就不会OOM啦.</li><li>到目前为止, 我们没有依靠任何其他的工具, 就轻易解决了上下游流速不均衡的问题.</li><li>因此我们总结一下, 本节中的治理的办法就两种:<ul><li>一是从数量上进行治理, 减少发送进水缸里的事件</li><li>二是从速度上进行治理, 减缓事件发送进水缸的速度</li></ul></li><li>大家一定没忘记, 在上一节还有个Zip的例子, 这个例子也爆了我们的内存, 现学现用, 我们用刚学到的办法来试试能不能惩奸除恶, 先来看看第一种办法.</li><li>先来减少进入水缸的事件的数量:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        for (int i = 0; ; i++) &#123;</span><br><span class="line">            e.onNext(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribeOn(Schedulers.io())</span><br><span class="line">        //进行Sample采样</span><br><span class="line">        .sample(2, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123;</span><br><span class="line">        e.onNext(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribeOn(Schedulers.io());</span><br><span class="line"></span><br><span class="line">Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String apply(Integer integer, String s) throws Exception &#123;</span><br><span class="line">        return integer + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(String s) throws Exception &#123;</span><br><span class="line">                Log.d(TAG, s);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, new Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Throwable throwable) throws Exception &#123;</span><br><span class="line">                Log.w(TAG, throwable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li><p>来看看运行效果:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava23.gif" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava23.gif"></div></p></li><li><p>哈哈, 成功了吧, 再来用第二种办法试试.</p></li><li>这次我们来减缓速度:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt;observable1=Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">           for (int i = 0; ; i++) &#123;</span><br><span class="line">               e.onNext(i);</span><br><span class="line">               Thread.sleep(2000);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;).subscribeOn(Schedulers.io());</span><br><span class="line"></span><br><span class="line">   Observable&lt;String&gt;observable2=Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123;</span><br><span class="line">           e.onNext(&quot;A&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;).subscribeOn(Schedulers.io());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public String apply(Integer integer, String s) throws Exception &#123;</span><br><span class="line">           return integer+s;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;).observeOn(AndroidSchedulers.mainThread()).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void accept(String s) throws Exception &#123;</span><br><span class="line">           Log.d(TAG, s);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;, new Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void accept(Throwable throwable) throws Exception &#123;</span><br><span class="line">           Log.w(TAG,throwable);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><ul><li><p>来看看运行结果吧:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava24.gif" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava24.gif"></div></p></li><li><p>果然也成功了, 这里只打印出了下游收到的事件, 所以只有一个. 如果你对这个结果看不懂, 请自觉掉头看前面几篇文章.</p></li><li>通过本节的学习, 大家应该对如何处理上下游流速不均衡已经有了基本的认识了, 大家也可以看到, 我们并没有使用<code>Flowable</code>, 所以很多时候仔细去分析问题, 找到问题的原因, 从源头去解决才是最根本的办法. 后面我们讲到<code>Flowable</code>的时候, 大家就会发现它其实没什么神秘的, 它用到的办法和我们本节所讲的基本上是一样的, 只是它稍微做了点封装.</li><li>好了, 今天的教程就到这里吧, 下一节中我们就会来学习你们喜闻乐见的<code>Flowable</code>.</li></ul>]]></content>
      
      <categories>
          
          <category> Rxjava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 转载 </tag>
            
            <tag> Rxjava </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rxjava2.0教程（五）</title>
      <link href="/2018/11/28/Rxjava2-0%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><blockquote><p>本文只作为转载，<strong>著作权归原作者(Season_zlc)所有</strong>，原文地址:<a href="https://www.jianshu.com/p/0f2d6c2387c9" target="_blank" rel="noopener">https://www.jianshu.com/p/0f2d6c2387c9</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>大家喜闻乐见的<code>Backpressure</code>来啦.</li><li>这一节中我们将来学习<code>Backpressure</code>. 我看好多吃瓜群众早已坐不住了, 别急, 我们先来回顾一下上一节讲的<code>Zip</code>.</li></ul><a id="more"></a><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><ul><li>上一节中我们说到<code>Zip</code>可以将多个上游发送的事件组合起来发送给下游, 那大家有没有想过一个问题, 如果其中一个水管A发送事件特别快, 而另一个水管B 发送事件特别慢, 那就可能出现这种情况, 发得快的水管A 已经发送了1000个事件了, 而发的慢的水管B 才发一个出来, 组合了一个之后水管A 还剩999个事件, 这些事件需要继续等待水管B 发送事件出来组合, 那么这么多的事件是放在哪里的呢? 总有一个地方保存吧? 没错, <code>Zip</code>给我们的每一根水管都弄了一个水缸 , 用来保存这些事件, 用通俗易懂的图片来表示就是:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava14.png" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava14.png"></div></li><li>如图中所示, 其中蓝色的框框就是<code>zip</code>给我们的水缸! 它将每根水管发出的事件保存起来, 等两个水缸都有事件了之后就分别从水缸中取出一个事件来组合, 当其中一个水缸是空的时候就处于等待的状态.</li><li>题外话: 大家来分析一下这个水缸有什么特点呢? 它是按顺序保存的, 先进来的事件先取出来, 这个特点是不是很熟悉呀? 没错, 这就是我们熟知的队列, 这个水缸在Zip内部的实现就是用的队列, 感兴趣的可以翻看源码查看.</li><li><p>好了回到正题上来, 这个水缸有大小限制吗? 要是一直往里存会怎样? 我们来看个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter e) throws Exception &#123;</span><br><span class="line">        //无限循环发事件</span><br><span class="line">        for (int i = 0; ; i++) &#123;</span><br><span class="line">            e.onNext(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribeOn(Schedulers.io());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter e) throws Exception &#123;</span><br><span class="line">        e.onNext(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribeOn(Schedulers.io());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String apply(Integer integer, String s) throws Exception &#123;</span><br><span class="line">        return integer + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).observeOn(AndroidSchedulers.mainThread()).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, new Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Throwable throwable) throws Exception &#123;</span><br><span class="line">        Log.w(TAG, throwable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>在这个例子中, 我们分别创建了两根水管, 第一根水管用机器指令的执行速度来无限循环发送事件, 第二根水管随便发送点什么, 由于我们没有发送<code>Complete</code>事件, 因此第一根水管会一直发事件到它对应的水缸里去, 我们来看看运行结果是什么样.</p></li><li>运行结果GIF图:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava15.gif" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava15.gif"></div></li><li>我勒个草, 内存占用以斜率为1的直线迅速上涨, 几秒钟就300多M , 最终报出了OOM:</li><li>出现这种情况肯定是我们不想看见的, 这里就可以引出我们的<code>Backpressure</code>了, 所谓的<code>Backpressure</code>其实就是为了控制流量, 水缸存储的能力毕竟有限, 因此我们还得从源头去解决问题, 既然你发那么快, 数据量那么大, 那我就想办法不让你发那么快呗.</li><li>那么这个源头到底在哪里, 究竟什么时候会出现这种情况, 这里只是说的Zip这一个例子, 其他的地方会出现吗? 带着这个问题我们来探究一下.</li><li>我们让事情变得简单一点, 从一个单一的<code>Observable</code>说起.</li><li><p>来看段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        for (int i = 0; ; i++) &#123;</span><br><span class="line">            e.onNext(i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        Log.d(TAG, &quot;&quot; + integer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>这段代码很简单, 上游同样无限循环的发送事件, 在下游每次接收事件前延时2秒. 上下游工作在 <strong>同一个线程</strong>里, 来看下运行结果:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava16.gif" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava16.gif"></div></p></li><li>哎卧槽, 怎么如此平静, 感觉像是走错了片场.</li><li><p>为什么呢, 因为上下游工作在 <strong>同一个线程</strong>呀骚年们! 这个时候上游每次调用<code>emitter.onNext(i)</code>其实就相当于直接调用了Consumer中的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void accept(Integer integer) throws Exception &#123;                       </span><br><span class="line">       Thread.sleep(2000);                                                      </span><br><span class="line">       Log.d(TAG, &quot;&quot; + integer);                                                </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>所以这个时候其实就是上游每延时2秒发送一次. 最终的结果也说明了这一切.</p></li><li><p>那我们加个线程呢, 改成这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        for (int i = 0; ; i++) &#123;</span><br><span class="line">            e.onNext(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;).subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">                Log.d(TAG,&quot;&quot;+integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li><li><p>这个时候把上游切换到了IO线程中去, 下游到主线程去接收, 来看看运行结果呢:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava17.gif" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava17.gif"></div></p></li><li>可以看到, 给上游加了个线程之后, 它就像脱缰的野马一样, 内存又爆掉了.</li><li>为什么不加线程和加上线程区别这么大呢, 这就涉及了 <strong>同步</strong>和 <strong>异步</strong>的知识了.</li><li>当上下游工作在 <strong>同一个线程</strong>中时, 这时候是一个 <strong>同步</strong>的订阅关系, 也就是说 <strong>上游</strong>每发送一个事件 <strong>必须</strong>等到 <strong>下游</strong>接收处理完了以后才能接着发送下一个事件.</li><li>当上下游工作在<strong> 不同的线程</strong>中时, 这时候是一个 <strong>异步</strong>的订阅关系, 这个时候 <strong>上游</strong>发送数据 <strong>不需要</strong>等待 <strong>下游</strong>接收, 为什么呢, 因为两个线程并不能直接进行通信, 因此上游发送的事件并不能直接到下游里去, 这个时候就需要一个田螺姑娘来帮助它们俩, 这个田螺姑娘就是我们刚才说的 <strong>水缸</strong> ! 上游把事件发送到水缸里去, 下游从水缸里取出事件来处理, 因此, 当上游发事件的速度太快, 下游取事件的速度太慢, 水缸就会迅速装满, 然后溢出来, 最后就OOM了.</li><li>这两种情况用图片来表示如下:</li><li>同步:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava18.png" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava18.png"></div></li><li>异步:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava19.png" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava19.png"></div></li><li>从图中我们可以看出, <strong>同步和异步</strong>的区别仅仅在于是否有<strong>水缸</strong>.</li><li>相信通过这个例子大家对线程之间的通信也有了比较清楚的认知和理解.</li><li>源头找到了, 只要有 <strong>水缸</strong>, 就会出现上下游发送事件速度不平衡的情况, 因此当我们以后遇到这种情况时, 仔细思考一下水缸在哪里, 找到水缸, 你就找到了解决问题的办法.</li></ul>]]></content>
      
      <categories>
          
          <category> Rxjava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 转载 </tag>
            
            <tag> Rxjava </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rxjava2.0教程（四）</title>
      <link href="/2018/11/28/Rxjava2-0%E6%95%99%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><blockquote><p>本文只作为转载，<strong>著作权归原作者(Season_zlc)所有</strong>，原文地址:<a href="https://www.jianshu.com/p/bb58571cdb64" target="_blank" rel="noopener">https://www.jianshu.com/p/bb58571cdb64</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>在上一节中, 我们提到了<code>Flowable</code> 和<code>Backpressure</code>背压, 本来这一节的确是想讲这两个东西的，可是写到一半感觉还是差点火候，感觉时机未到， 因此，这里先来做个准备工作， 先带大家学习zip这个操作符, 这个操作符也是比较牛逼的东西了， 涉及到的东西也比较多， 主要是一些细节上的东西太多， 通过学习这个操作符，可以为我们下一节的<code>Backpressure</code> 做个铺垫.</li></ul><a id="more"></a><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><ul><li>照惯例我们还是先贴上一下比较正式的解释吧.</li><li>Zip通过一个函数将多个Observable发送的事件结合到一起，然后发送这些组合到一起的事件. 它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个Observable一样多的数据.</li><li>我们再用通俗易懂的图片来解释一下:</li></ul><p><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava10.png" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava10.png"></div></p><ul><li>从这个图中可以看见，这次上游和以往不同的是，我们有两根水管了.</li><li>其中一根水管负责发送 <strong>圆形事件</strong>，另外一根水管负责发送 <strong>三角形事件</strong>，通过Zip操作符，使得 <strong>圆形事件</strong>和 <strong>三角形事件</strong>合并成为了一个 <strong>矩形事件</strong>。</li><li>下面我们再来看看动作分解:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava11.png" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava11.png"></div></li><li>通过动作分解，我们可以看出:</li><li>组合的过程是 <strong>分别从</strong> 两根水管里 <strong>各取出一个事件</strong> 来进行组合, 并且一个事件 <strong>只能被使用一次</strong>, 组合的顺序是严格 <strong>按照事件发送的顺利</strong> 来进行的, 也就是说不会出现 <strong>圆形1</strong> 事件和 <strong>三角形B</strong> 事件进行合并, 也不可能出现 <strong>圆形2</strong> 和 <strong>三角形A</strong> 进行合并的情况.</li><li>最终 <strong>下游收到的事件数量</strong> 是和 <strong>上游中发送事件最少的那一根水管的事件数量</strong> 相同. 这个也很好理解, 因为是从 <strong>每一根水管</strong> 里取一个事件来进行合并, <strong>最少的</strong> 那个肯定就 <strong>最先取完</strong> , 这个时候其他的水管 <strong>尽管还有事件</strong> , 但是已经没有足够的事件来组合了, 因此下游就不会收到剩余的事件了.</li><li><p>分析了大概的原理，我们还是劳逸结合，先来看看实际中的代码怎么写吧:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, &quot;emit 1&quot;);</span><br><span class="line">        e.onNext(1);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit 2&quot;);</span><br><span class="line">        e.onNext(2);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit 3&quot;);</span><br><span class="line">        e.onNext(3);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit 4&quot;);</span><br><span class="line">        e.onNext(4);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit complete1&quot;);</span><br><span class="line">        e.onComplete();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit A&quot;);</span><br><span class="line">        e.onNext(&quot;A&quot;);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit B&quot;);</span><br><span class="line">        e.onNext(&quot;B&quot;);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit C&quot;);</span><br><span class="line">        e.onNext(&quot;C&quot;);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit complete2&quot;);</span><br><span class="line">        e.onComplete();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String apply(Integer integer, String s) throws Exception &#123;</span><br><span class="line">        return integer + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Observer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(String value) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onNext:&quot; + value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onError&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>我们分别创建了两根上游水管，一个发送1、2、3、4、Complete，另外一个发送A、B、C、Complete、接着用Zip把发出的事件组合，来看看运行结果吧.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">D/TAG: onSubscribe</span><br><span class="line">D/TAG: emit 1</span><br><span class="line">D/TAG: emit 2</span><br><span class="line">D/TAG: emit 3</span><br><span class="line">D/TAG: emit 4</span><br><span class="line">D/TAG: emit complete1</span><br><span class="line">D/TAG: emit A</span><br><span class="line">D/TAG: onNext:1A</span><br><span class="line">D/TAG: emit B</span><br><span class="line">D/TAG: onNext:2B</span><br><span class="line">D/TAG: emit C</span><br><span class="line">D/TAG: onNext:3C</span><br><span class="line">D/TAG: emit complete2</span><br><span class="line">D/TAG: onComplete</span><br></pre></td></tr></table></figure></li><li><p>似乎结果是对的，但总感觉什么地方不对劲…</p></li><li><p>哪儿不对劲呢，为什么感觉是水管一发送完了之后，水管二才开始发送啊？到底是不是呢？我们来验证一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, &quot;emit 1&quot;);</span><br><span class="line">        e.onNext(1);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit 2&quot;);</span><br><span class="line">        e.onNext(2);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit 3&quot;);</span><br><span class="line">        e.onNext(3);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit 4&quot;);</span><br><span class="line">        e.onNext(4);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit complete1&quot;);</span><br><span class="line">        e.onComplete();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit A&quot;);</span><br><span class="line">        e.onNext(&quot;A&quot;);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit B&quot;);</span><br><span class="line">        e.onNext(&quot;B&quot;);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit C&quot;);</span><br><span class="line">        e.onNext(&quot;C&quot;);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit complete2&quot;);</span><br><span class="line">        e.onComplete();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String apply(Integer integer, String s) throws Exception &#123;</span><br><span class="line">        return integer + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Observer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(String value) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onNext:&quot; + value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onError&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>这次我们在每发送一个事件之后加入了一秒钟的延时，来看看运行结果吧，注意这是个gif图:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava12.gif" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava12.gif"></div></p></li><li>(贴心的我担心大家看不清楚，特意调成了老年字体呢)</li><li>阿西吧, 好像真的是先发送的水管一再发送的水管二呢, 为什么会有这种情况呢? 因为我们两根水管都是运行在同一个线程里, 同一个线程里执行代码肯定有先后顺序呀.</li><li><p>因此我们来稍微改一下, 不让他们在同一个线程, 不知道怎么切换线程的, 请掉头看前面几节.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, &quot;emit 1&quot;);</span><br><span class="line">        e.onNext(1);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit 2&quot;);</span><br><span class="line">        e.onNext(2);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit 3&quot;);</span><br><span class="line">        e.onNext(3);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit 4&quot;);</span><br><span class="line">        e.onNext(4);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit complete1&quot;);</span><br><span class="line">        e.onComplete();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribeOn(Schedulers.io());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit A&quot;);</span><br><span class="line">        e.onNext(&quot;A&quot;);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit B&quot;);</span><br><span class="line">        e.onNext(&quot;B&quot;);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit C&quot;);</span><br><span class="line">        e.onNext(&quot;C&quot;);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit complete2&quot;);</span><br><span class="line">        e.onComplete();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribeOn(Schedulers.io());</span><br><span class="line"></span><br><span class="line">Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String apply(Integer integer, String s) throws Exception &#123;</span><br><span class="line">        return integer + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Observer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(String value) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onNext:&quot; + value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onError&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>好了, 这次我们让水管都在IO线程里发送事件, 再来看看运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">D/TAG: onSubscribe</span><br><span class="line">D/TAG: emit 1</span><br><span class="line">D/TAG: emit A</span><br><span class="line">D/TAG: onNext:1A</span><br><span class="line">D/TAG: emit B</span><br><span class="line">D/TAG: emit 2</span><br><span class="line">D/TAG: onNext:2B</span><br><span class="line">D/TAG: emit C</span><br><span class="line">D/TAG: emit 3</span><br><span class="line">D/TAG: onNext:3C</span><br><span class="line">D/TAG: emit complete2</span><br><span class="line">D/TAG: emit 4</span><br><span class="line">D/TAG: onComplete</span><br></pre></td></tr></table></figure></li><li><p>GIF图:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava13.gif" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava13.gif"></div></p></li><li>诶! 这下就对了嘛, 两根水管同时开始发送, 每发送一个, Zip就组合一个, 再将组合结果发送给下游.</li><li>不对呀! 可能细心点的朋友又看出端倪了, 第一根水管明明发送了四个数据+一个Complete, 之前明明还有的, 为啥到这里没了呢?</li><li>这是因为我们之前说了, zip发送的事件数量跟上游中发送事件最少的那一根水管的事件数量是有关的, 在这个例子里我们第二根水管只发送了三个事件然后就发送了Complete, 这个时候尽管第一根水管还有事件4 和事件Complete 没有发送, 但是它们发不发送还有什么意义呢? 所以本着节约是美德的思想, 就干脆打断它的狗腿, 不让它发了.</li><li>至于前面的例子为什么会发送, 刚才不是已经说了是！在！同！一！个！线！程！里！吗！！！！再问老子打死你！</li><li>有好事的程序员可能又要问了， 那我不发送Complete呢？ 答案是显然的, 上游会继续发送事件, 但是下游仍然收不到那些多余的事件. 不信你可以试试.</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ul><li>学习了Zip的基本用法, 那么它在Android有什么用呢, 其实很多场景都可以用到Zip. 举个例子.</li><li>比如一个界面需要展示用户的一些信息, 而这些信息分别要从两个服务器接口中获取, 而只有当两个都获取到了之后才能进行展示, 这个时候就可以用Zip了:</li><li><p>首先分别定义这两个请求接口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Api &#123;</span><br><span class="line">    @GET</span><br><span class="line">    Observable&lt;UserBaseInfoResponse&gt; getUserBaseInfo(@Body UserBaseInfoRequest request);</span><br><span class="line"></span><br><span class="line">    @GET</span><br><span class="line">    Observable&lt;UserExtraInfoResponse&gt; getUserExtraInfo(@Body UserExtraInfoRequest request);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>RetrofitProvider类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class RetrofitProvider &#123;</span><br><span class="line">    private static final String ENDPOINT = &quot;https://api.douban.com/&quot;;</span><br><span class="line"></span><br><span class="line">    public static Retrofit get() &#123;</span><br><span class="line">        OkHttpClient.Builder builder = new OkHttpClient().newBuilder();</span><br><span class="line">        builder.readTimeout(10, TimeUnit.SECONDS);</span><br><span class="line">        builder.connectTimeout(9, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        return new Retrofit.Builder().baseUrl(ENDPOINT)</span><br><span class="line">                .client(builder.build())</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接着用Zip来打包请求:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">final Api api = RetrofitProvider.get().create(Api.class);</span><br><span class="line">Observable&lt;UserBaseInfoResponse&gt; observable1 =</span><br><span class="line">        api.getUserBaseInfo(new UserBaseInfoRequest()).subscribeOn(Schedulers.io());</span><br><span class="line"></span><br><span class="line">Observable&lt;UserExtraInfoResponse&gt; observable2 =</span><br><span class="line">        api.getUserExtraInfo(new UserExtraInfoRequest()).subscribeOn(Schedulers.io());</span><br><span class="line"></span><br><span class="line">Observable.zip(observable1, observable2,</span><br><span class="line">        new BiFunction&lt;UserBaseInfoResponse, UserExtraInfoResponse, UserInfo&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public UserInfo apply(UserBaseInfoResponse baseInfo,</span><br><span class="line">                                  UserExtraInfoResponse extraInfo) throws Exception &#123;</span><br><span class="line">                return new UserInfo(baseInfo, extraInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(new Consumer&lt;UserInfo&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(UserInfo userInfo) throws Exception &#123;</span><br><span class="line">                //do something;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> Rxjava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 转载 </tag>
            
            <tag> Rxjava </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rxjava2.0教程（三）</title>
      <link href="/2018/11/27/Rxjava2-0%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><blockquote><p>本文只作为转载，<strong>著作权归原作者(Season_zlc)所有</strong>，原文地址:<a href="https://www.jianshu.com/p/8818b98c44e2" target="_blank" rel="noopener">https://www.jianshu.com/p/8818b98c44e2</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>上一节讲解了线程调度，并且举了两个实际中的例子，其中有一个登录的例子，不知大家有没有想过这么一个问题，如果是一个新用户，必须先注册，等注册成功后在自动登录该怎么做呢？</li><li>很明显，这是一个嵌套的网络请求，首先需要去注册，待注册成功回调了再去请求登录的接口。</li><li>我们当然可以写成这样:</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private void login() &#123;</span><br><span class="line"></span><br><span class="line">    api.login()</span><br><span class="line">            //在io线程中进行网络请求</span><br><span class="line">            .subscribeOn(Schedulers.io())</span><br><span class="line">            //回到主线程中去处理请求结果</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(new Consumer&lt;LoginResponse&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void accept(LoginResponse loginResponse) throws Exception &#123;</span><br><span class="line">                    Toast.makeText(ThirdActivity.this, &quot;登录成功！&quot;, Toast.LENGTH_LONG);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, new Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void accept(Throwable throwable) throws Exception &#123;</span><br><span class="line">                    Toast.makeText(ThirdActivity.this, &quot;登录失败!&quot;, Toast.LENGTH_LONG);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void register() &#123;</span><br><span class="line">    api.register()</span><br><span class="line">            .subscribeOn(Schedulers.io())</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(new Consumer&lt;RegisterResponse&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void accept(RegisterResponse registerResponse) throws Exception &#123;</span><br><span class="line">                    Toast.makeText(ThirdActivity.this, &quot;注册成功！&quot;, Toast.LENGTH_LONG);</span><br><span class="line">                    //注册成功，调用登录的方法</span><br><span class="line">                    login();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, new Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void accept(Throwable throwable) throws Exception &#123;</span><br><span class="line">                    Toast.makeText(ThirdActivity.this, &quot;注册失败！&quot;, Toast.LENGTH_LONG);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样的代码能够工作，但不够优雅，通过本节的学习，可以让我们用一种更优雅的方式来解决这个问题</li></ul><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><ul><li>先来看看最简单的变换操作符map吧</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>map是Rxjava中最简单的一个变换操作符了，它的作用就是对上游发送的每一个事件应用一个函数，使得每一个事件都按照指定的函数去变化，用事件图表示如下:</li></ul><p><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava7.png" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava7.png"></div></p><ul><li><p>图中map中的函数作用是将圆形事件转换为矩形事件，从而导致下游接收到的事件就变为了矩形，用矩形来表示这个例子就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        e.onNext(1);</span><br><span class="line">        e.onNext(2);</span><br><span class="line">        e.onNext(3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).map(new Function&lt;Integer, String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String apply(Integer integer) throws Exception &#123;</span><br><span class="line">        return &quot;This is result：&quot; + integer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>在上游我们发送的是数字类型，而在下游我们接收的是String类型，中间起转换作用的就是map操作符，运算结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D/TAG: This is result 1 </span><br><span class="line">D/TAG: This is result 2 </span><br><span class="line">D/TAG: This is result 3</span><br></pre></td></tr></table></figure></li><li><p>通过map,可以将上游发来的事件转换为任意的类型，可以是一个Object,也可以是一个集合，如此强大的操作符你难道不想来试试？</p></li><li>接下来我们来看看另外一个广为人知的操作符flatMap.</li></ul><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><ul><li>flatMap是一个非常强大的操作符，先用一个比较难懂的概念说明一下:</li><li><code>flatMap</code>将一个发送事件的上游<code>Observable</code>变换为多个发送事件的<code>Observables</code>,然后将它们发射的事件合并后放进一个单独的<code>Observable</code>里</li><li>这句话比较难以理解，我们用先通俗易懂的图片来详细的讲解一下，首先来看看整体的一个图片:</li></ul><p><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava8.png" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava8.png"></div></p><ul><li>先看看上游，上游发送了三个事件，分别是1、2、3，注意它们的颜色.</li><li>中间的flatMap的作用是将圆形的事件转换为一个矩形事件和三角形事件的新的上游<code>Observable</code></li><li><p>还是不能理解？别急，再来看看分解动作:<br><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava9.png" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava9.png"></div></p></li><li><p>这样就很好理解了吧？!!!</p></li><li>上游每发送一个事件，<code>flatMap</code>都将创建一个新的水管，然后发送转换之后的事件，下游接收到的就是这些新的水管发送的数据， <strong>这里需要注意的是，flatMap并不保证事件的顺序</strong>，也就是图中所看到的，并不是事件1就在2的前面，如果需要保证顺序则需要使用<code>concatMap</code>.</li><li><p>说了原理，我们还是来看看实际中的代码如何吧:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        e.onNext(1);</span><br><span class="line">        e.onNext(2);</span><br><span class="line">        e.onNext(3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ObservableSource&lt;String&gt; apply(Integer integer) throws Exception &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            list.add(&quot;I am value:&quot; + integer);</span><br><span class="line">        &#125;</span><br><span class="line">        return Observable.fromIterable(list).delay(1000, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>如代码所示，我们在<code>flatMap</code>中将上游发来的每一个事件转换成一个新的发送三个<code>String</code>事件的水管，为了看到<code>flatMap</code>结果是无需的，所以加了1000毫秒的延时，来看看运行效果吧:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D/TAG: I am value 1 </span><br><span class="line">D/TAG: I am value 1 </span><br><span class="line">D/TAG: I am value 1 </span><br><span class="line">D/TAG: I am value 3 </span><br><span class="line">D/TAG: I am value 3 </span><br><span class="line">D/TAG: I am value 3 </span><br><span class="line">D/TAG: I am value 2 </span><br><span class="line">D/TAG: I am value 2 </span><br><span class="line">D/TAG: I am value 2</span><br></pre></td></tr></table></figure></li><li><p>结果也验证了我们之前所说.</p></li><li><p>这里也简单说一下，<code>concatMap</code>吧，它和flatMap的作用几乎一模一样，只是它的结果是严格按照上游发送的顺序来发送的，来看个代码吧.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        e.onNext(1);</span><br><span class="line">        e.onNext(2);</span><br><span class="line">        e.onNext(3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).concatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ObservableSource&lt;String&gt; apply(Integer integer) throws Exception &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            list.add(&quot;I am value : &quot; + integer);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return Observable.fromIterable(list).delay(10, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>只是将之前的flatMap改成了concatMap,其余原封不动，运行结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D/TAG: I am value 1 </span><br><span class="line">D/TAG: I am value 1 </span><br><span class="line">D/TAG: I am value 1 </span><br><span class="line">D/TAG: I am value 2 </span><br><span class="line">D/TAG: I am value 2 </span><br><span class="line">D/TAG: I am value 2 </span><br><span class="line">D/TAG: I am value 3 </span><br><span class="line">D/TAG: I am value 3 </span><br><span class="line">D/TAG: I am value 3</span><br></pre></td></tr></table></figure></li><li><p>可以看到，结果仍然是有序的.</p></li><li>好了关于RxJava的操作符最基本的使用就讲解到这里了, RxJava中内置了许许多多的操作符, 这里通过讲解map和flatMap只是起到一个抛砖引玉的作用, 关于其他的操作符只要大家按照本文的思路去理解, 再仔细阅读文档, 应该是没有问题的了, 如果大家有需要也可以将需要讲解的操作符列举出来, 我可以根据大家的需求讲解一下.</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ul><li>学习了FlatMap操作符, 我们就可以回答文章开头提出的那个问题了.</li><li><p>如何优雅的解决嵌套请求, 只需要用flatMap转换一下就行了.</p></li><li><p>Api接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface Api &#123;</span><br><span class="line"></span><br><span class="line">    @GET(&quot;app_appUserdoAppUserLogin&quot;)</span><br><span class="line">    Observable&lt;LoginResponse&gt; login();</span><br><span class="line"></span><br><span class="line">    @GET(&quot;app_appUserdoRegisterUser&quot;)</span><br><span class="line">    Observable&lt;RegisterResponse&gt; register();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>LoginResponse实体类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class LoginResponse &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * head : &#123;&quot;respCode&quot;:&quot;0000000&quot;,&quot;respContent&quot;:&quot;执行成功&quot;&#125;</span><br><span class="line">     * body : &#123;&quot;reply&quot;:&quot;登录成功！&quot;&#125;</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    private HeadBean head;</span><br><span class="line">    private BodyBean body;</span><br><span class="line"></span><br><span class="line">    public HeadBean getHead() &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHead(HeadBean head) &#123;</span><br><span class="line">        this.head = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BodyBean getBody() &#123;</span><br><span class="line">        return body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBody(BodyBean body) &#123;</span><br><span class="line">        this.body = body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class HeadBean &#123;</span><br><span class="line">        /**</span><br><span class="line">         * respCode : 0000000</span><br><span class="line">         * respContent : 执行成功</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        private String respCode;</span><br><span class="line">        private String respContent;</span><br><span class="line"></span><br><span class="line">        public String getRespCode() &#123;</span><br><span class="line">            return respCode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setRespCode(String respCode) &#123;</span><br><span class="line">            this.respCode = respCode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getRespContent() &#123;</span><br><span class="line">            return respContent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setRespContent(String respContent) &#123;</span><br><span class="line">            this.respContent = respContent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class BodyBean &#123;</span><br><span class="line">        /**</span><br><span class="line">         * reply : 登录成功！</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        private String reply;</span><br><span class="line"></span><br><span class="line">        public String getReply() &#123;</span><br><span class="line">            return reply;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setReply(String reply) &#123;</span><br><span class="line">            this.reply = reply;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>RegisterResponse实体类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class RegisterResponse &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * head : &#123;&quot;respCode&quot;:&quot;0000000&quot;,&quot;respContent&quot;:&quot;执行成功&quot;&#125;</span><br><span class="line">     * body : &#123;&quot;reply&quot;:&quot;注册成功！&quot;&#125;</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    private HeadBean head;</span><br><span class="line">    private BodyBean body;</span><br><span class="line"></span><br><span class="line">    public HeadBean getHead() &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHead(HeadBean head) &#123;</span><br><span class="line">        this.head = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BodyBean getBody() &#123;</span><br><span class="line">        return body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBody(BodyBean body) &#123;</span><br><span class="line">        this.body = body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class HeadBean &#123;</span><br><span class="line">        /**</span><br><span class="line">         * respCode : 0000000</span><br><span class="line">         * respContent : 执行成功</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        private String respCode;</span><br><span class="line">        private String respContent;</span><br><span class="line"></span><br><span class="line">        public String getRespCode() &#123;</span><br><span class="line">            return respCode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setRespCode(String respCode) &#123;</span><br><span class="line">            this.respCode = respCode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getRespContent() &#123;</span><br><span class="line">            return respContent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setRespContent(String respContent) &#123;</span><br><span class="line">            this.respContent = respContent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class BodyBean &#123;</span><br><span class="line">        /**</span><br><span class="line">         * reply : 注册成功！</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        private String reply;</span><br><span class="line"></span><br><span class="line">        public String getReply() &#123;</span><br><span class="line">            return reply;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setReply(String reply) &#123;</span><br><span class="line">            this.reply = reply;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>retrofit类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class retrofit &#123;</span><br><span class="line">    private static String BaseUrl=&quot;http://www.wanandroid.com/tools/mockapi/5919/&quot;;</span><br><span class="line"></span><br><span class="line">    public static Retrofit create()&#123;</span><br><span class="line">        OkHttpClient.Builder builder = new OkHttpClient().newBuilder();</span><br><span class="line">        builder.readTimeout(10, TimeUnit.SECONDS);</span><br><span class="line">        builder.connectTimeout(9, TimeUnit.SECONDS);</span><br><span class="line">        if (BuildConfig.DEBUG) &#123;</span><br><span class="line">            HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();</span><br><span class="line">            interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);</span><br><span class="line">            builder.addInterceptor(interceptor);</span><br><span class="line">        &#125;</span><br><span class="line">        return new Retrofit.Builder()</span><br><span class="line">                .baseUrl(BaseUrl)</span><br><span class="line">                .client(builder.build())</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以看到登录和注册返回的都是一个上游<code>Observable</code>, 而我们的<code>flatMap</code>操作符的作用就是把一个<code>Observable</code>转换为另一个<code>Observable</code>, 因此结果就很显而易见了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">final Api api = retrofit.create().create(Api.class);</span><br><span class="line">//发起注册请求</span><br><span class="line">api.register()</span><br><span class="line">        //在io线程中进行网络请求</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        //回到主线程中处理请求结果</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .doOnNext(new Consumer&lt;RegisterResponse&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(RegisterResponse registerResponse) throws Exception &#123;</span><br><span class="line">                String s = registerResponse.toString();</span><br><span class="line">                //先根据注册的响应结果去做一些操作</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        //回到IO线程去发起登录请求</span><br><span class="line">        .observeOn(Schedulers.io())</span><br><span class="line">        .flatMap(new Function&lt;RegisterResponse, ObservableSource&lt;LoginResponse&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public ObservableSource&lt;LoginResponse&gt; apply(RegisterResponse registerResponse) throws Exception &#123;</span><br><span class="line">                return api.login();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        //回到主线程去处理请求登录的结果</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(new Consumer&lt;LoginResponse&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(LoginResponse loginResponse) throws Exception &#123;</span><br><span class="line">                Toast.makeText(context, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, new Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Throwable throwable) throws Exception &#123;</span><br><span class="line">                Toast.makeText(context, &quot;登录失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li><li><p>从这个例子也可以看到我们切换线程是多么简单.</p></li></ul>]]></content>
      
      <categories>
          
          <category> Rxjava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 转载 </tag>
            
            <tag> Rxjava </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rxjava2.0教程（二）</title>
      <link href="/2018/11/24/Rxjava2-0%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><blockquote><p>本文只作为转载，<strong>著作权归原作者(Season_zlc)所有</strong>，原文地址:<a href="https://www.jianshu.com/p/8818b98c44e2" target="_blank" rel="noopener">https://www.jianshu.com/p/8818b98c44e2</a></p></blockquote><a id="more"></a><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><ul><li>还是之前的例子，两个水管:</li></ul><p><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava5.png" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava5.png"></div></p><ul><li>正常情况下，上游和下游是工作在同一个线程中的，也就是说上游在哪个线程发送事件，下游就在哪个线程中接收事件</li><li>如何去理解呢？以Android为例，一个Activity的所有动作默认都是在主线程中运行的，比如我们在onCreate中打出当前线程的名字:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">     super.onCreate(savedInstanceState);</span><br><span class="line">     setContentView(R.layout.activity_second);</span><br><span class="line">     Log.d(TAG, Thread.currentThread().getName());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>打印结果:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/TAG: main</span><br></pre></td></tr></table></figure><ul><li>回到Rxjava中，当我们在主线程中去创建一个上游的<code>Observable</code>来发送事件，则这个上游默认就在主线程发送事件</li><li>当我们在主线程中去创建一个下游<code>Observer</code>来接收事件，则这个下游默认就在主线程中接收事件，来看段代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_second);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 上游</span><br><span class="line">     */</span><br><span class="line">    Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">            Log.d(TAG, &quot;Observable thread is :&quot; + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">            Log.d(TAG, &quot;emit 1&quot;);</span><br><span class="line"></span><br><span class="line">            e.onNext(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 下游</span><br><span class="line">     */</span><br><span class="line">    Consumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">            Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">            Log.d(TAG, &quot;onNext:&quot; + integer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    observable.subscribe(consumer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在主线程中分别创建上游和下游，然后将他们连接再一起，同时分别打印出它们所在的线程，运行结果为:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D/TAG: Observable thread is:main</span><br><span class="line">D/TAG: emit 1</span><br><span class="line">D/TAG: Observer thread is:main</span><br><span class="line">D/TAG: onNext:1</span><br></pre></td></tr></table></figure><ul><li>这就验证了刚才所说，上下游默认是在同一个线程工作</li><li>这样肯定满足不了我们的需求，我们更多想要的是这么一种情况，在子线程中做耗时的操作，然后回到主线程中来操作UI，用图片来描述就是下面这个图片</li></ul><p><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava6.png" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava6.png"></div></p><ul><li>在这个图片中，我们用黄色水管表示子线程，深蓝色水管表示主线程</li><li>要达到这个目的，我们需要先改变上游发送事件的线程，让它去子线程中发送事件，然后再改变下游的线程，让它去主线程接收事件，通过Rxjava内置的线程调度器可以很轻松的做到这一点，接下来看一段代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_second2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">            Log.d(TAG, &quot;Observable thread is:&quot; + Thread.currentThread().getName());</span><br><span class="line">            Log.d(TAG, &quot;emit 1&quot;);</span><br><span class="line">            e.onNext(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Consumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">            Log.d(TAG, &quot;Observer thread is:&quot; + Thread.currentThread().getName());</span><br><span class="line">            Log.d(TAG, &quot;onNext:&quot; + integer);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    observable</span><br><span class="line">            //上游水管开启一个新的子线程</span><br><span class="line">            .subscribeOn(Schedulers.newThread())</span><br><span class="line">            //下游水管在主线程中接收</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(consumer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>还是刚才的例子，只不过添加了点东西，先来看看运行的效果:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D/TAG: Observable thread is:RxNewThreadScheduler-1</span><br><span class="line">D/TAG: emit 1</span><br><span class="line">D/TAG: Observer thread is:main</span><br><span class="line">D/TAG: onNext:1</span><br></pre></td></tr></table></figure><ul><li>可以看到，上游发送事件的线程的确改变了，是在一个叫<code>RxNewThreadScheduler-1</code>的线程中发送的事件，而下游仍然在主线程中接收事件，这说明我们的目的达成了，接下来看看如何做到的</li><li>和上一段代码相比，这段代码只不过是增加了两行代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> //上游水管开启一个新的子线程</span><br><span class="line">.subscribeOn(Schedulers.newThread())</span><br><span class="line">    //下游水管在主线程中接收</span><br><span class="line">.observeOn(AndroidSchedulers.mainThread())</span><br></pre></td></tr></table></figure><ul><li>简单来说，<code>subscribeOn()</code>指的是上游发送事件的线程，<code>observeOn()</code>指的是下游接收事件的线程</li><li>多次指定上游的线程只有第一次指定有效，也就是说多次调用<code>subscribeOn()</code>只有第一次有效，其余的会被忽略</li><li>多次指定下游的线程是可以的，也就是说每调用一次<code>observeOn()</code>下游的线程就会切换一次</li><li>在Rxjava中，已经内置了很多线程选项供我们选择，例如有<ul><li><code>Schedulers.io()</code>代表io操作的线程，通常用于网络，读写文件等io密集型的操作</li><li><code>Schedulers.computation()</code>代表CUP计算机密集型的操作，例如需要大量计算的操作</li><li><code>Schedulers.newThread()</code>代表一个常规的新线程</li><li><code>AndroidSchedulers.mainThread()</code>代表Android的主线程</li></ul></li><li>这些内置的Scheduler已经足够我们开发的需求，因此我们应该使用内置的这些选项，在Rxjava内部使用的是线程池来维护这些线程，所以效率也比较高</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ul><li>对于我们Android开发人员来说，经常会将一些耗时的操作放在后台，比如网络请求或者读取文件，操作数据库等等，等到操作完之后回到主线程中去更新UI,有了上面这些基础，那么现在我们就可以轻松的去做到这样一些操作。</li></ul><blockquote><p>该网络请求例子转载自简书，原文地址: <a href="https://www.jianshu.com/p/56f15db86ed3" target="_blank" rel="noopener">https://www.jianshu.com/p/56f15db86ed3</a></p></blockquote><h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><ul><li>下面用Retrofit2.0+Rxjava2.0实现一个网络请求的例子</li><li>(一)使用前Retrofit前，先添加Gradle配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;io.reactivex.rxjava2:rxjava:2.0.7&apos;</span><br><span class="line">compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;</span><br><span class="line">compile &apos;com.squareup.retrofit2:retrofit:2.2.0&apos;</span><br><span class="line">compile &apos;com.squareup.retrofit2:converter-gson:2.2.0&apos;</span><br><span class="line">compile &apos;com.squareup.retrofit2:adapter-rxjava2:2.2.0&apos;</span><br></pre></td></tr></table></figure><ul><li>api接口<a href="http://api.laifudao.com/open/xiaohua.json" target="_blank" rel="noopener">http://api.laifudao.com/open/xiaohua.json</a></li><li>(二) 获取api接口返回的json数据，用GsonFormat自动生成的一个实体类<code>MyJoke</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class MyJoke &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private String title;</span><br><span class="line">    private String content;</span><br><span class="line">    private String poster;</span><br><span class="line">    private String url;</span><br><span class="line"></span><br><span class="line">    public String getTitle() &#123;</span><br><span class="line">        return title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTitle(String title) &#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(String content) &#123;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPoster() &#123;</span><br><span class="line">        return poster;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPoster(String poster) &#123;</span><br><span class="line">        this.poster = poster;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUrl() &#123;</span><br><span class="line">        return url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUrl(String url) &#123;</span><br><span class="line">        this.url = url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(三)创建一个名为Api的接口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Api &#123;</span><br><span class="line"></span><br><span class="line">    @GET(&quot;xiaohua.json&quot;)</span><br><span class="line">    Observable&lt;List&lt;MyJoke&gt;&gt; getData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里需要注意的是，与Retrofit相比不再是<code>Call&lt;List&lt;MyJoke&gt;&gt;</code>，而是使用了Rxjava的<code>Observable&lt;List&lt;MyJoke&gt;&gt; getData();</code></li><li>接下来对网络请求进行一下简单的封装<code>HttpMethods.java</code>，如下:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class HttpMethods &#123;</span><br><span class="line"></span><br><span class="line">    private static final String BASE_URL = &quot;http://api.laifudao.com/open/&quot;;</span><br><span class="line"></span><br><span class="line">    private static final int TIME_OUT = 4;</span><br><span class="line"></span><br><span class="line">    private Retrofit retrofit;</span><br><span class="line"></span><br><span class="line">    private Api api;</span><br><span class="line"></span><br><span class="line">    private HttpMethods() &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 构造函数私有化</span><br><span class="line">         * 并在构造函数中进行retrofit的初始化</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        OkHttpClient client = new OkHttpClient();</span><br><span class="line">        client.newBuilder().connectTimeout(TIME_OUT, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 由于retrofit底层是通过okhttp实现的，所以可以通过okhttp来设置一些连接参数，如超时等</span><br><span class="line">         */</span><br><span class="line">        retrofit = new Retrofit.Builder()</span><br><span class="line">                .baseUrl(BASE_URL)</span><br><span class="line">                .client(client)</span><br><span class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line">        api = retrofit.create(Api.class);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class singleInstance &#123;</span><br><span class="line">        public static final HttpMethods instance = new HttpMethods();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static HttpMethods getInstance() &#123;</span><br><span class="line">        return singleInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void getJoke(Observer&lt;List&lt;MyJoke&gt;&gt; observer) &#123;</span><br><span class="line">        api.getData()</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .unsubscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(observer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在<code>HttpMethods</code>方法中，将构造函数私有化是为了实现单例，并向外提供一个请求方法<code>getJoke</code>，该方法的参数是一个观察者，接下来看一下MainActivity文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    private String TAG = &quot;TAG&quot;;</span><br><span class="line"></span><br><span class="line">    private List&lt;MyJoke&gt; jokes = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        getData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取网络请求</span><br><span class="line">     */</span><br><span class="line">    private void getData() &#123;</span><br><span class="line">        HttpMethods.getInstance().getJoke(new Observer&lt;List&lt;MyJoke&gt;&gt;() &#123;</span><br><span class="line">            Disposable d;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Disposable d) &#123;</span><br><span class="line">                this.d = d;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(List&lt;MyJoke&gt; myJokes) &#123;</span><br><span class="line">                jokes = myJokes;</span><br><span class="line">                Log.d(TAG, jokes.size() + &quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable e) &#123;</span><br><span class="line">                //切断下游水管</span><br><span class="line">                d.dispose();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">                //切断下游水管</span><br><span class="line">                d.dispose();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Rxjava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 转载 </tag>
            
            <tag> Rxjava </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rxjava2.0教程（一）</title>
      <link href="/2018/11/24/Rxjava2-0%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><blockquote><p>Rxjava作为近几年Android开发炙手可热的技术，哪怕面试也会被面试官问起，作为一个菜鸟，只有在网上苦苦搜索有关Rxjava的博客，奈何千篇一律的内容中晦涩的名词对于我来说理解起来实在困难，花了时间仍然不能理解到底什么是Rxjava?,Rxjava该如何具体应用？等等，最后，功夫不负有心人，在简书上看到了一位大神写的一个系列的Rxjava2.0文章，形象生动，诙谐幽默，通俗易懂，如沐春风。看了三遍，但觉得还是应该自己写个笔记下来，巩固、防止遗忘，本文只作为转载，<strong>著作权归原作者(Season_zlc)所有</strong>，原文地址:<a href="https://www.jianshu.com/p/464fa025229e" target="_blank" rel="noopener">https://www.jianshu.com/p/464fa025229e</a></p></blockquote><a id="more"></a><h2 id="第一步，Gradle中添加依赖"><a href="#第一步，Gradle中添加依赖" class="headerlink" title="第一步，Gradle中添加依赖"></a>第一步，Gradle中添加依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;io.reactivex.rxjava2:rxjava:2.0.1&apos;</span><br><span class="line">compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;</span><br></pre></td></tr></table></figure><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava1.png" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava1.png"></div></p><ul><li>如上图，假设有两根水管，上面一根水管为事件产生的水管，称作 <strong>上游</strong>，下面一根水管为事件接收的水管，称作 <strong>下游</strong>。</li><li>两根水管通过一定的方式连接起来，使得上游每产生一个事件，下游就能收到该事件。</li><li>这里的上游对应Rxjava中的<code>Observable</code>，下游对应Rxjava中的<code>Observer</code>，他们之间的连接就对应着<code>subscribe()</code>，因此这个关系用Rxjava表示就是:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        e.onNext(1);</span><br><span class="line">        e.onNext(2);</span><br><span class="line">        e.onNext(3);</span><br><span class="line">        e.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Observer&lt;Integer&gt; objectObserver = new Observer&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(Integer value) &#123;</span><br><span class="line">        Log.d(&quot;TAG&quot;, value + &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onError&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">observable.subscribe(objectObserver);</span><br></pre></td></tr></table></figure><ul><li>运行结果:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D/TAG: onSubscribe</span><br><span class="line">D/TAG: 1</span><br><span class="line">D/TAG: 2</span><br><span class="line">D/TAG: 3</span><br><span class="line">D/TAG: onComplete</span><br></pre></td></tr></table></figure><blockquote><p>上游向下游发送数据之前要先建立连接，也就是先调用<code>onSubscribe</code>方法，之后才开始发送数据</p></blockquote><ul><li>把这段代码连起来写就成了RxJava引以为傲的链式操作:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter e) throws Exception &#123;</span><br><span class="line">        e.onNext(1);</span><br><span class="line">        e.onNext(2);</span><br><span class="line">        e.onNext(3);</span><br><span class="line">        e.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Observer&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(Integer value) &#123;</span><br><span class="line">        Log.d(TAG, value + &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Log.d(TAG, &quot;error&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>接下来解释一下其中两个陌生的名词<code>ObservableEmitter</code>和<code>Disposable</code></li><li><code>ObservableEmitter</code>:<code>Emitter</code>是发射器的意思，那么<code>ObservableEmitter</code>就是用来发出事件的，它可以发出三种类型的事件，通过调用<code>ObservableEmitter</code>的<code>onNext(T value)</code>,<code>onComplete</code>,<code>onError(Throwable error)</code>就可以分别发出<code>next</code>事件、<code>complete</code>事件和<code>error</code>事件。</li><li>但是，请注意，并不意味着可以随意乱七八糟的发射事件，需要满足一定的规则:<ul><li>上游可以发送无限个<code>onNext</code>，下游也可以接收无限个<code>onNext</code></li><li>当上游发送了一个<code>onComplete</code>后，上游<code>onComplete</code>之后的事件将会继续发送，而下游收到<code>onComplete</code>事件之后将不再继续接收事件</li><li>当上游发送了一个<code>onError</code>后，上游<code>onError</code>之后的事件将继续发送，而下游收到<code>onError</code>事件之后将不再继续接收事件</li><li>最为关键的是<code>onComplete</code>和<code>onError</code>必须唯一并且互斥，即不能发多个<code>onComplete</code>,也不能发多个<code>onError</code>,也不能先发一个<code>onComplete</code>,然后再发一个<code>onError</code>,反之亦然.</li></ul></li></ul><ul><li>规则示意如下:</li></ul><table><thead><tr><th>事件名称</th><th>示意图</th></tr></thead><tbody><tr><td>只发送onNext事件</td><td><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava2.png" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava2.png"></div></td></tr><tr><td>发送onComplete事件</td><td><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava3.png" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava3.png"></div></td></tr><tr><td>发送onError事件</td><td><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava4.png" alt="https://raw.githubusercontent.com/dondurma/MygithubPic/master/Rxjava/rxjava4.png"></div></td></tr></tbody></table><ul><li>介绍完了<code>ObservableEmitter</code>，接下来介绍<code>Disposable</code>，这个单词的字面意思是一次性用品，用完即可丢弃的，那么在Rxjava中怎么去理解它呢？对应于上面水管的例子，我们可以把它理解成两根管道之间的一个机关，当调用它的<code>dispose()</code>方法时，它就会将两根管道切断，从而导致下游收不到事件。</li></ul><blockquote><p>注意:调用<code>dipose()</code>并不会导致上游不再继续发送事件，上游会继续发送剩余的事件</p></blockquote><ul><li>在来看个例子，我们让上游依次发送1,2,3，<code>complete</code>,4,在下游收到第二事件后，切断水管，看看运行结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, &quot;emit 1&quot;);</span><br><span class="line">        e.onNext(1);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit 2&quot;);</span><br><span class="line">        e.onNext(2);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit 3&quot;);</span><br><span class="line">        e.onNext(3);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit complete&quot;);</span><br><span class="line">        e.onComplete();</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;emit 4&quot;);</span><br><span class="line">        e.onNext(4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Observer&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private Disposable mDisposable;</span><br><span class="line">    private int i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">        mDisposable = d;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(Integer value) &#123;</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;onNext:&quot; + value);</span><br><span class="line">        i++;</span><br><span class="line">        if (i == 2) &#123;</span><br><span class="line">            Log.d(TAG, &quot;dispose&quot;);</span><br><span class="line">            mDisposable.dispose();</span><br><span class="line">            Log.d(TAG, &quot;isDispose&quot; + &quot;:&quot;+mDisposable.isDisposed());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Log.d(TAG, &quot;error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        Log.d(TAG, &quot;complete&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>运行结果为:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D/TAG: onSubscribe</span><br><span class="line">D/TAG: emit 1</span><br><span class="line">D/TAG: onNext:1</span><br><span class="line">D/TAG: emit 2</span><br><span class="line">D/TAG: onNext:2</span><br><span class="line">D/TAG: dispose</span><br><span class="line">D/TAG: isDispose:true</span><br><span class="line">D/TAG: emit 3</span><br><span class="line">D/TAG: emit complete</span><br><span class="line">D/TAG: emit 4</span><br></pre></td></tr></table></figure><ul><li>从运行结果看，在收到onNext 2这个事件之后，切断了水管，但是上游仍然发送了3，<code>complete</code>,4这几个事件，而且上游并没有因为发送了<code>onComplete</code>而停止，同时可以看到下游的<code>onSubscribe()</code>方法是最先调用的</li><li><code>Disposable</code>的用处不止这些，后面讲解到了线程的调度之后，我们会发现它的重要性，随着后续继续深入的讲解，我们会在更多的地方发现它的身影</li><li>另外<code>subscribe()</code>有多个重载的方法:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final Disposable subscribe() &#123;&#125; </span><br><span class="line">public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) &#123;&#125; </span><br><span class="line">public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError) &#123;&#125; </span><br><span class="line">public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete) &#123;&#125; </span><br><span class="line">public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) &#123;&#125; </span><br><span class="line">public final void subscribe(Observer&lt;? super T&gt; observer) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>最后一个带<code>Observer</code>参数的我们已经使用过了，这里对其他几个方法进行说明:<ul><li>不带任何参数的<code>subscribe()</code>表示下游不关心任何事件，你上游尽管发你的数据。</li><li>带有一个<code>Consumer</code>参数的方法表示下游只关心onNext事件，其他的事件我假装没看见，因此我们如果只需要onNext事件可以这么写:</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, &quot;emit 1&quot;);</span><br><span class="line">        e.onNext(1);</span><br><span class="line">        Log.d(TAG, &quot;emit 2&quot;);</span><br><span class="line">        e.onNext(2);</span><br><span class="line">        Log.d(TAG, &quot;emit 3&quot;);</span><br><span class="line">        Log.d(TAG, &quot;emit complete&quot;);</span><br><span class="line"></span><br><span class="line">        e.onComplete();</span><br><span class="line">        Log.d(TAG, &quot;emit 4&quot;);</span><br><span class="line">        e.onNext(4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">        Log.d(TAG, &quot;onNext:&quot; + integer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Rxjava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 转载 </tag>
            
            <tag> Rxjava </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写在二十七岁</title>
      <link href="/2018/11/16/%E5%86%99%E5%9C%A8%E4%BA%8C%E5%8D%81%E4%B8%83%E5%B2%81/"/>
      <content type="html"><![CDATA[<blockquote><p>今天，我27岁了，从25岁开始后，感觉30岁离自己越来越近了，以前30岁对自己而言遥不可及，对自己而言只是一个概念，而现在，每每过一个生日，切实的，自己离30岁又近了一步了……</p></blockquote><a id="more"></a><ul><li>早上醒来，打开手机，收到妈妈发来的生日祝福和一个红包，时间是凌晨5点，她上班很早，每天都是这个点起床，很辛苦。</li><li>不知不觉地，这已经是来杭州的第三个生日了，记得在什么地方看到的一篇文章上说，“年纪越大觉得时间过得越快”的确，记忆中，只有童年的时光总是那么悠闲又漫长。</li><li>年少时看《三国演义》其中有一段很有感触，说是有这个故事：‘玄德自知语失，遂起身如厕。因见己身髀肉复生，亦不觉潸然流涕。……玄德长叹曰：“备往常身不离鞍，髀肉皆散；分久不骑，髀里肉生。日月磋跎，老将至矣，而功业不建，是以悲耳！”……’想想自己也即将到了而立之年，可还是一事无成、孑然一身，这一行工作了两年多了，因为懒，自己的技术也没有太多实质性的提升。</li><li>二十七岁，留给自己的时间不多了，人生过了三分之一多，留给职业生涯的时间更少了，多读书，多学习，提升自己，善待他人，相信未来，把握住此时此刻。培养起基于自己对待事物的判断力和见解，提升的自己的写作能力和英语能力，以及与他人良好的沟通能力。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>棠梨煎雪</title>
      <link href="/2018/11/16/%E6%A3%A0%E6%A2%A8%E7%85%8E%E9%9B%AA/"/>
      <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28188427&auto=0&height=66"></iframe><p>作曲 : 灰原穷<br><br>作词 : 商连<br></p><a id="more"></a><p>青鲤来时遥闻春溪声声碎<br><br>嗅得手植棠梨初发轻黄蕊<br><br>待小暑悄过 新梨渐垂<br><br>来邀东邻女伴撷果缓缓归<br></p><p>旧岁采得枝头细雪<br><br>今朝飘落胭脂梨叶<br><br>轻挼草色二三入卷<br><br>细呷春酒淡始觉甜<br></p><p>依旧是<br><br>偏爱枕惊鸿二字入梦的时节<br><br>烛火惺忪却可与她漫聊彻夜<br><br>早春暮春 酒暖花深<br><br>便好似一生心事只得一人来解<br></p><p>岁岁花藻檐下共将棠梨煎雪<br><br>自总角至你我某日辗转天边<br><br>天淡天青 宿雨沾襟<br><br>一年一会信笺却只见寥寥数言<br></p><p>旧岁采得枝头细雪<br><br>今朝飘落胭脂梨叶<br><br>轻挼草色二三入卷<br><br>细呷春酒淡始觉甜<br></p><p>依旧是<br><br>偏爱枕惊鸿二字入梦的时节<br><br>烛火惺忪却可与她漫聊彻夜<br><br>早春暮春 酒暖花深<br><br>便好似一生心事只得一人来解<br></p><p>岁岁花藻檐下共将棠梨煎雪<br><br>自总角至你我某日辗转天边<br><br>天淡天青 宿雨沾襟<br><br>一年一会信笺却只见寥寥数言<br></p><p>雨中灯市欲眠 原已萧萧数年<br><br>似有故人轻叩 再将棠梨煎雪<br><br>能否消得<br><br>你一路而来的半生风雪<br></p>]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 歌词 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android开发中，实现对Home按键的监听</title>
      <link href="/2018/11/10/Android%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%AF%B9Home%E6%8C%89%E9%94%AE%E7%9A%84%E7%9B%91%E5%90%AC/"/>
      <content type="html"><![CDATA[<h1 id="Android开发中，实现Home按键的监听"><a href="#Android开发中，实现Home按键的监听" class="headerlink" title="Android开发中，实现Home按键的监听"></a>Android开发中，实现Home按键的监听</h1><blockquote><p>最近在项目中遇到需要监听用户点击Back以及Home按键，并作出相应操作。开始以为很简单，先实现了点击Back按键的监听，继而开始实现Home按键的监听，一次，二次都失败了，网上查看了多篇博客，都差强人意，实际运行后都实现不了，直到最后发现了一篇博客,特记录一下。<br>原文地址:<a href="https://blog.csdn.net/csdn_aiyang/article/details/76154374" target="_blank" rel="noopener">https://blog.csdn.net/csdn_aiyang/article/details/76154374</a></p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class Main2Activity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private InnerRecevier innerReceiver;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main2);</span><br><span class="line">        //在setContentView之前添加,未添加的话home键监听无效，设置窗体属性</span><br><span class="line">        this.getWindow().setFlags(0x80000000, 0x80000000);</span><br><span class="line"></span><br><span class="line">        //创建广播</span><br><span class="line">        innerReceiver = new InnerRecevier();</span><br><span class="line">        //动态注册广播</span><br><span class="line">        IntentFilter intentFilter = new IntentFilter(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);</span><br><span class="line">        //启动广播</span><br><span class="line">        registerReceiver(innerReceiver, intentFilter);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    class InnerRecevier extends BroadcastReceiver &#123;</span><br><span class="line">        final String SYSTEM_DIALOG_REASON_KEY = &quot;reason&quot;;</span><br><span class="line">        final String SYSTEM_DIALOG_REASON_RECENT_APPS = &quot;recentapps&quot;;</span><br><span class="line">        final String SYSTEM_DIALOG_REASON_HOME_KEY = &quot;homekey&quot;;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">            String action = intent.getAction();</span><br><span class="line">            if (Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action)) &#123;</span><br><span class="line">                String reason = intent.getStringExtra(SYSTEM_DIALOG_REASON_KEY);</span><br><span class="line">                if (reason != null) &#123;</span><br><span class="line">                    if (reason.equals(SYSTEM_DIALOG_REASON_HOME_KEY)) &#123;</span><br><span class="line">                        Toast.makeText(Main2Activity.this, &quot;Home键被监听&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125; else if (reason.equals(SYSTEM_DIALOG_REASON_RECENT_APPS)) &#123;</span><br><span class="line">                        Toast.makeText(Main2Activity.this, &quot;多任务键被监听&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        if (innerReceiver != null) &#123;</span><br><span class="line">            unregisterReceiver(innerReceiver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Android </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>相信未来</title>
      <link href="/2018/10/15/%E7%9B%B8%E4%BF%A1%E6%9C%AA%E6%9D%A5/"/>
      <content type="html"><![CDATA[<h1 id="相信未来"><a href="#相信未来" class="headerlink" title="相信未来"></a>相信未来</h1><p>现代·食指 <br></p><p>当蜘蛛网无情地查封了我的炉台<br></p><p>当灰烬的余烟叹息着贫困的悲哀<br></p><a id="more"></a><p>我依然固执地铺平失望的灰烬<br></p><p>用美丽的雪花写下：相信未来<br></p><p>当我的紫葡萄化为深秋的露水<br></p><p>当我的鲜花依偎在别人的情怀<br></p><p>我依然固执地用凝霜的枯藤<br></p><p>在凄凉的大地上写下：相信未来<br></p><p>我要用手指那涌向天边的排浪<br></p><p>我要用手掌那托住太阳的大海<br></p><p>摇曳着曙光那枝温暖漂亮的笔杆<br></p><p>用孩子的笔体写下：相信未来<br></p><p>我之所以坚定地相信未来<br></p><p>是我相信未来人们的眼睛<br></p><p>她有拨开历史风尘的睫毛<br></p><p>她有看透岁月篇章的瞳孔<br></p><p>不管人们对于我们腐烂的皮肉<br></p><p>那些迷途的惆怅、失败的苦痛<br></p><p>是寄予感动的热泪、深切的同情<br></p><p>还是给以轻蔑的微笑、辛辣的嘲讽<br></p><p>我坚信人们对于我们的脊骨<br></p><p>那无数次的探索、迷途、失败和成功<br></p><p>一定会给予热情、客观、公正的评定<br></p><p>是的，我焦急地等待着他们的评定<br></p><p>朋友，坚定地相信未来吧<br></p><p>相信不屈不挠的努力<br></p><p>相信战胜死亡的年轻<br></p><p>相信未来、热爱生命<br></p><p>1968年 北京<br></p>]]></content>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 现代诗 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『前端学习笔记（四）』</title>
      <link href="/2018/08/28/%E3%80%8E%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%8F/"/>
      <content type="html"><![CDATA[<h1 id="CSS篇-二"><a href="#CSS篇-二" class="headerlink" title="CSS篇(二)"></a>CSS篇(二)</h1><h2 id="样式表的书写位置"><a href="#样式表的书写位置" class="headerlink" title="样式表的书写位置"></a>样式表的书写位置</h2><h3 id="内嵌式写法"><a href="#内嵌式写法" class="headerlink" title="内嵌式写法"></a>内嵌式写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">样式表写法</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="外链式写法"><a href="#外链式写法" class="headerlink" title="外链式写法"></a>外链式写法</h3><ul><li><p>1.先常见一个.css样式文件，暂命名为1.css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">font: italic 700 54px microsoft yahei;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2.在需要引用的html中的head标签中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;1.css&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="行内样式写法"><a href="#行内样式写法" class="headerlink" title="行内样式写法"></a>行内样式写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 style=&quot;font-size&quot;:30px; color:red;&quot;&gt;Android开发&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h3 id="三种写法各自特点"><a href="#三种写法各自特点" class="headerlink" title="三种写法各自特点"></a>三种写法各自特点</h3><ul><li>内嵌式写法，样式只作用与当前文件，没有真正实现结构表现分离。</li><li>外链式写法，作用范围是当前站点，谁调用谁生效，范围广，真正实现结构(html)与表现(css)分离。</li><li>行内样式写法，作用范围仅限于当前标签，范围小，结构表现混在一起。(不推荐使用)</li></ul><h2 id="标签按显示方式的分类"><a href="#标签按显示方式的分类" class="headerlink" title="标签按显示方式的分类"></a>标签按显示方式的分类</h2><h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><ul><li>典型代表: <code>div,h1-h6,p,ul,li</code></li><li>特点:<ol><li>独占一行</li><li>可以设置宽高</li><li>嵌套(包含)下，子块元素宽度(没有定义情况下)和父块元素宽度默认一致</li></ol></li></ul><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><ul><li>典型代表: <code>span,a,strong,em,del,ins</code></li><li>特点:<ol><li>在一行上显示</li><li>不能直接设置宽高</li><li>元素的宽和高就是内容撑开的宽高</li></ol></li></ul><h3 id="行内块元素-内联元素"><a href="#行内块元素-内联元素" class="headerlink" title="行内块元素(内联元素)"></a>行内块元素(内联元素)</h3><ul><li>典型代表: <code>input,img</code></li><li>特点:<ol><li>在一行上显示</li><li>可以设置宽高</li></ol></li></ul><h3 id="块元素、行内元素"><a href="#块元素、行内元素" class="headerlink" title="块元素、行内元素"></a>块元素、行内元素</h3><h4 id="块元素转行内元素"><a href="#块元素转行内元素" class="headerlink" title="块元素转行内元素"></a>块元素转行内元素</h4><ul><li>显示在同一行</li><li><code>display: inline;</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div,p&#123;</span><br><span class="line">    display: inline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="行内元素转块元素"><a href="#行内元素转块元素" class="headerlink" title="行内元素转块元素"></a>行内元素转块元素</h4><ul><li>可以定义宽高</li><li><code>display: block;</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">span&#123;</span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="块和行内元素转行内块元素"><a href="#块和行内元素转行内块元素" class="headerlink" title="块和行内元素转行内块元素"></a>块和行内元素转行内块元素</h4><ul><li>所有元素都在一行显示，并且可以定义宽高</li><li><code>display:inline-block;</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div,a,span,strong&#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:200px;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS三大特征"><a href="#CSS三大特征" class="headerlink" title="CSS三大特征"></a>CSS三大特征</h2><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><ul><li>当多个样式作用与同一个(同一类)标签时，样式发生了冲突，总是执行后面的代码(后面的代码层叠前边的代码)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.box&#123;</span><br><span class="line">font-size: 100px;</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br><span class="line">.box2&#123;</span><br><span class="line">font-size: 200px;</span><br><span class="line">color: blue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p class=&quot;box box2&quot;&gt;Android开发&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;box&quot;&gt;iOS开发&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>“Android开发”字样会显示<code>.box2</code>的样式，也就是蓝色、200px字体</li><li>“iOS开发”字样因为只调用了<code>.box</code>样式，不存在层叠问题，所以显示<code>.box</code>属性，红色、100px字体</li></ul><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><ul><li>继承性发生的前提是包含(嵌套关系)<ul><li>文字颜色可以继承</li><li>文字大小可以继承</li><li>字体可以继承</li><li>字体粗细可以继承</li><li>文字风格可以继承</li><li>行高可以继承</li><li><strong>总结</strong>: 文字的所有属性都可以继承</li><li><strong>特殊情况:</strong><ul><li>h系列标签不能继承文字大小</li><li>a标签不能继承颜色</li></ul></li></ul></li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ul><li>默认样式(0)&lt;标签选择器(1)&lt;类选择器(10)&lt;id选择器(100)&lt;行内样式(1000)&lt;<code>!important</code>(1000以上)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">/*标签选择器*/</span><br><span class="line">div&#123;</span><br><span class="line">color: red;</span><br><span class="line">font-size: 10px;</span><br><span class="line">&#125;</span><br><span class="line">/*类选择器*/</span><br><span class="line">.box&#123;</span><br><span class="line">color:pink;</span><br><span class="line">font-size: 20px;</span><br><span class="line">&#125;</span><br><span class="line">/*id选择器*/</span><br><span class="line">#con&#123;</span><br><span class="line">color: yellow;</span><br><span class="line">font-size: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;box&quot; id=&quot;con&quot; style=&quot;font-size: 40px; color: green&quot;&gt;Android开发&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>“Android开发”字样显示为绿色、40px大小。</li></ul><h4 id="优先级特点"><a href="#优先级特点" class="headerlink" title="优先级特点"></a>优先级特点</h4><h5 id="继承的权重为0"><a href="#继承的权重为0" class="headerlink" title="继承的权重为0"></a>继承的权重为0</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.father&#123;</span><br><span class="line">font-size: 60px;</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">font-size: 20px;</span><br><span class="line">color:blue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">&lt;p&gt;Android开发&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>如上:当没有定义p标签样式时，”Android开发”字样显示为父标签的的样式<code>.father</code>，一旦加上p标签样式，就显示为p标签的样式。</li></ul><h5 id="权重会叠加"><a href="#权重会叠加" class="headerlink" title="权重会叠加"></a>权重会叠加</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">p.son&#123;</span><br><span class="line">font-size: 120px;</span><br><span class="line">color: yellow;</span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">font-size: 30px;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br><span class="line">.son&#123;</span><br><span class="line">font-size: 60px;</span><br><span class="line">color: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">&lt;p class=&quot;son&quot;&gt;Android开发&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>运行效果最终显示的是交集选择器<code>p.son</code>的样式</li><li>原理分析:<ul><li>标签选择器p的权重=1</li><li>类选择器<code>.son</code>的权重=10</li><li>根据CSS权重会叠加特性，故交集选择器<code>p.son</code>的权重=1+10，大于其他选择器权重，所以显示为该选择器属性</li></ul></li></ul><h2 id="连接伪类"><a href="#连接伪类" class="headerlink" title="连接伪类"></a>连接伪类</h2><ul><li>语法: <code>a:link{属性:值;}</code>或<code>a{属性:值;}</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a:link &#123;属性:值;&#125;      链接默认状态</span><br><span class="line">a:visited &#123;属性:值;&#125;   链接访问之后的状态</span><br><span class="line">a:hover &#123;属性:值;&#125;     鼠标放到链接上显示的状态</span><br><span class="line">a:active &#123;属性:值;&#125;    连接激活的状态(鼠标一直按着)</span><br><span class="line">: focus &#123;属性:值;&#125;     获取焦点</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">/*连接的默认状态*/</span><br><span class="line">a:link&#123;</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br><span class="line">/*连接访问之后的状态（要想恢复需要先清除浏览器缓存）*/</span><br><span class="line">a:visited&#123;</span><br><span class="line">color:green;</span><br><span class="line">&#125;</span><br><span class="line">/*鼠标放在链接上的状态*/</span><br><span class="line">a:hover&#123;</span><br><span class="line">color:yellow;</span><br><span class="line">&#125;</span><br><span class="line">/*链接激活的状态*/</span><br><span class="line">a:active&#123;</span><br><span class="line">color: pink;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;Android开发&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="文本修饰"><a href="#文本修饰" class="headerlink" title="文本修饰"></a>文本修饰</h3><ul><li>Text-decoration:none(无下划线) | underline(有下划线) | line-through(删除线)</li></ul><h2 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h2><ul><li>background-color  背景颜色</li><li>background-image  背景图片</li><li>background-repeat:  背景平铺<ul><li>repeat 默认平铺</li><li>no-repeat  不平铺</li><li>repeat-x 沿x轴平铺</li><li>repeat-y 沿y轴平铺</li></ul></li><li>background-position 背景的定位<ul><li>left</li><li>right</li><li>center</li><li>top</li><li>bottom</li><li>背景定位的特点:<ul><li><code>background-position:right;</code>方位值只写一个的时候，另外一个值默认居中</li><li><code>background-position:right bottom;</code>写两个方位值的时候，顺序没有要求</li><li><code>background-position:20px 30px;</code>写2个具体值的时候，第一个代表水平方向，第二个代表垂直方向</li></ul></li></ul></li><li>background-attachment 背景是否滚动<ul><li>scroll 滚动</li><li>fixed 固定</li></ul></li><li>背景属性连写<ul><li><code>background:red url(1.jpg) no-repeat 30px 40px scroll;</code></li><li>连写的时候没有顺序要求，url为必填项</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Web前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『前端学习笔记（三）』</title>
      <link href="/2018/08/22/%E3%80%8E%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%8F/"/>
      <content type="html"><![CDATA[<h1 id="CSS篇-一"><a href="#CSS篇-一" class="headerlink" title="CSS篇(一)"></a>CSS篇(一)</h1><h2 id="CSS概念"><a href="#CSS概念" class="headerlink" title="CSS概念"></a>CSS概念</h2><ul><li>CSS 指层叠样式表 (Cascading Style Sheets)(级联样式表)</li><li>CSS是用来美化html标签的，相当于页面化妆。</li><li>样式表书写位置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">样式表内容</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul><li>选择器是一个选择谁（标签）的过程。</li><li><code>标签{属性:值;}</code></li><li>相关属性</li></ul><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>Width:20px;</td><td>宽</td></tr><tr><td>Height:20px;</td><td>高</td></tr><tr><td>Background-color:red;</td><td>背景颜色</td></tr><tr><td>font-size:24px;</td><td>文字大小</td></tr><tr><td>text-align:left,center,right</td><td>内容的水平对齐方式</td></tr><tr><td>text-indent:2em;</td><td>首行缩进</td></tr><tr><td>Color:red;</td><td>文字颜色</td></tr></tbody></table><h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><h4 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h4><ul><li><code>标签{属性:值;}</code></li><li>特点:标签选择器定义之后，会将页面所有的元素都执行这个标签样式。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">p&#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 20px;</span><br><span class="line">background-color: yellow;</span><br><span class="line">font-size: 20px;</span><br><span class="line">color: 20px;</span><br><span class="line">&#125;</span><br><span class="line">div&#123;</span><br><span class="line">background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;Android&lt;/p&gt;</span><br><span class="line">&lt;div&gt;IOS&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><ul><li>写法:<code>.自定义类名{属性:值;  属性:值;}</code></li><li><p>特点:</p><ol><li>谁调用，谁生效</li><li>一个标签可以调用多个类选择器</li><li>多个标签可以调用同一个类选择器</li></ol></li><li><p>命名规则:</p><ol><li>不能用纯数字或数字开头来定义类名</li><li>不能使用特殊符号或者是特殊符号开头来定义类名</li><li>不建议使用汉字来定义类名</li><li>不推荐使用属性或者属性的值来定义类名</li></ol></li><li><p>常用命名的单词</p><ol><li>头:head</li><li>内容:content/container</li><li>尾:footer</li><li>导航:nav</li><li>侧栏:sidebar   </li><li>栏目:column</li><li>页面外围控制整体布局宽度:wrapper</li><li>左右中:left right center</li><li>登录条:loginbar</li><li>标志:logo</li><li>广告:banner</li><li>页面主体:main</li><li>热点:hot</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.box&#123;</span><br><span class="line">text-align: right;</span><br><span class="line">background-color: green</span><br><span class="line">&#125;</span><br><span class="line">.egg&#123;</span><br><span class="line">width: 500px;</span><br><span class="line">height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p class=&quot;box egg&quot;&gt;Android&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h4 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h4><ul><li>写法 <code>#自定义名称{属性:值;}</code></li><li>特点: <ol><li>一个ID选择器在一个页面只能调用一次。如果使用2次或者2次以上，不符合w3c规范，JS调用会出问题</li><li>一个标签只能调用一个ID选择器</li><li>一个标签可以同时调用类选择器和ID选择器</li></ol></li><li>示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">#ega&#123;</span><br><span class="line">background-color: red;</span><br><span class="line">width: 500px;</span><br><span class="line">height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p id=&quot;ega&quot;&gt;Android&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Android&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h4><ul><li>写法: <code>*{属性:值;}</code></li><li>特点: 给所有的标签都使用相同的样式，不推荐使用，会增加浏览器和服务器的负担。</li></ul><h4 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h4><ul><li>概念: 两个或者两个以上的基础选择器通过不同的方式连接在一起</li><li>分类<ol><li>交集选择器</li><li>后代选择器</li><li>子代选择器</li><li>并集选择器</li></ol></li></ul><h5 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h5><ul><li>写法: <code>标签+类（ID）选择器{属性：值；}</code></li><li>特点: 即要满足使用了某个标签，还要满足使用了类(ID)选择器。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.box&#123;</span><br><span class="line">font-size: 100px;</span><br><span class="line">color: yellow;</span><br><span class="line">&#125;</span><br><span class="line">#egg&#123;</span><br><span class="line">background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">span.box&#123;</span><br><span class="line">width: 1000px;</span><br><span class="line">height: 500px;</span><br><span class="line">&#125;</span><br><span class="line">h1#weather&#123;</span><br><span class="line">background-color: blue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;Android开发&lt;/div&gt;</span><br><span class="line">&lt;p id=&quot;egg&quot;&gt;ios开发&lt;/p&gt;</span><br><span class="line">&lt;span class=&quot;box&quot;&gt;Web前端开发&lt;/span&gt; </span><br><span class="line">&lt;h1 id=&quot;weather&quot;&gt;java Web后台开发&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h5 id="后代选择器-重点"><a href="#后代选择器-重点" class="headerlink" title="后代选择器(重点)"></a>后代选择器(重点)</h5><ul><li>写法: <code>选择器+空格+选择器{属性:值;}</code></li><li>含义: 后代选择器首选要满足包含(嵌套)关系。父集元素在前边，子集元素在后边。</li><li>特点: 无限制隔代。只要能代表标签，标签、类选择器、ID选择器自由组合。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.box&#123;</span><br><span class="line">font-size: 100px;</span><br><span class="line">&#125;</span><br><span class="line">#miss&#123;</span><br><span class="line">background-color: yellow;</span><br><span class="line">&#125;</span><br><span class="line">.box p&#123;</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;p&gt;&lt;span&gt;Android开发&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;span&gt;iOS开发&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;&lt;span id=&quot;miss&quot;&gt;iOS开发&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h5 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h5><ul><li>写法: <code>选择器&gt;选择器{属性:值;}</code></li><li>特点: 选中直接下一代元素。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">div&gt;p&#123;</span><br><span class="line">color: red;</span><br><span class="line">font-size: 50px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;span&gt;&lt;p&gt;Android开发&lt;/p&gt;&lt;/span&gt;</span><br><span class="line">&lt;p&gt;iOS开发&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h5 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h5><ul><li>写法: <code>选择器+，+选择器+，选择器{属性:值;}</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.box,#miss,span,h1&#123;</span><br><span class="line">font-size: 100px;</span><br><span class="line">color: #fff;</span><br><span class="line">background-color: green;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;Android开发&lt;/div&gt;</span><br><span class="line">&lt;p id=&quot;miss&quot;&gt;iOS开发&lt;/p&gt;</span><br><span class="line">&lt;span&gt;Web开发&lt;/span&gt;</span><br><span class="line">&lt;h1&gt;java 后端开发&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="文本元素"><a href="#文本元素" class="headerlink" title="文本元素"></a>文本元素</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>font-size:16px; 文字大小</li><li>font-weight:700; (100-900)，文字粗细，不推荐使用font-weight:bold;</li><li>font-family:微软雅黑; 文本的字体</li><li>font-style:normal | italic; normal 默认值 italic 斜体</li><li>line-height: 行高</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">div&#123;</span><br><span class="line">font-size: 16px;</span><br><span class="line">font-weight:700;</span><br><span class="line">font-family:微软雅黑;</span><br><span class="line">font-style:italic;</span><br><span class="line">line-height:40px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;Android开发&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="文本属性连写"><a href="#文本属性连写" class="headerlink" title="文本属性连写"></a>文本属性连写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font: font-style font-weight  font-size/line-height  font-family;</span><br></pre></td></tr></table></figure><ul><li>注意:font:后面写属性的，一定要按照书写顺序，文本属性连写文字大小和字体为必写项。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Font:italic 700 16px/40px  微软雅黑;</span><br></pre></td></tr></table></figure><h3 id="文字的表达方式"><a href="#文字的表达方式" class="headerlink" title="文字的表达方式"></a>文字的表达方式</h3><ul><li><p>直接写中文名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">font-family: 微软雅黑;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>写字体的英文名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">font-family: microsoft yahei;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>写unicode编码</p></li></ul><p><img src="http://p9uaajhtk.bkt.clouddn.com/unicode%E7%BC%96%E7%A0%81.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Web前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『前端学习笔记（二）』</title>
      <link href="/2018/08/21/%E3%80%8E%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%8F/"/>
      <content type="html"><![CDATA[<h1 id="Html篇-二"><a href="#Html篇-二" class="headerlink" title="Html篇(二)"></a>Html篇(二)</h1><h2 id="关键字（head标签中）"><a href="#关键字（head标签中）" class="headerlink" title="关键字（head标签中）"></a>关键字（head标签中）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;文本内容&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="网页描述（head标签中）"><a href="#网页描述（head标签中）" class="headerlink" title="网页描述（head标签中）"></a>网页描述（head标签中）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;description&quot; content=&quot;文本内容&quot;/&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="网页重定向（head标签中）"><a href="#网页重定向（head标签中）" class="headerlink" title="网页重定向（head标签中）"></a>网页重定向（head标签中）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5; http://www.example.com&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="连接外部样式表（head标签中）"><a href="#连接外部样式表（head标签中）" class="headerlink" title="连接外部样式表（head标签中）"></a>连接外部样式表（head标签中）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;1.css&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="设置icon图标（head标签中）"><a href="#设置icon图标（head标签中）" class="headerlink" title="设置icon图标（head标签中）"></a>设置icon图标（head标签中）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul><li>展示数据，是对网页重构的一个有益补充</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot; width=&quot;500&quot; height=&quot;300&quot; cellspacing=&quot;0&quot; cellpadding=&quot;10&quot; align=&quot;center&quot; bgcolor=&quot;yellow&quot;&gt;             表格</span><br><span class="line">    &lt;tr&gt;            行</span><br><span class="line">    &lt;td&gt;&lt;/td&gt;       列</span><br><span class="line">    &lt;td&gt;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><ul><li>属性<ul><li>border=”1” 边框</li><li>width=”500”宽度</li><li>height=”300”高</li><li>cellspacing=”2”单元格与单元格的距离</li><li>cellpadding=”2”内容边框的距离</li><li>align=”left | right | center”</li><li>如果直接给表格用align=”center”,表格居中</li><li>如果给tr或者td使用，tr或者td内容居中</li><li>bgcolor=”red” 背景颜色</li></ul></li></ul><h3 id="表格的标准结构"><a href="#表格的标准结构" class="headerlink" title="表格的标准结构"></a>表格的标准结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/thead&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">    &lt;tfoot&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/tfoot&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h3 id="表头和单元格的合并"><a href="#表头和单元格的合并" class="headerlink" title="表头和单元格的合并"></a>表头和单元格的合并</h3><h4 id="添加表头"><a href="#添加表头" class="headerlink" title="添加表头"></a>添加表头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;caption&gt;表头名&lt;/caption&gt;</span><br></pre></td></tr></table></figure><h4 id="单元格的合并"><a href="#单元格的合并" class="headerlink" title="单元格的合并"></a>单元格的合并</h4><ul><li><p>原表如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot; width=&quot;500&quot; height=&quot;300&quot; align=&quot;left&quot;&gt;</span><br><span class="line">&lt;caption&gt;表头&lt;/caption&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">      &lt;td&gt;张三&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;22&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;前端工程师&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">      &lt;td&gt;李四&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;20&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;Android开发工程师&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">      &lt;td&gt;王五&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;18&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;java后台开发工程师&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></li><li><p>预览效果</p></li></ul><p><img src="http://p9uaajhtk.bkt.clouddn.com/%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC1.png" alt="合并单元格1"></p><h5 id="合并同一行上的单元格-colspan"><a href="#合并同一行上的单元格-colspan" class="headerlink" title="合并同一行上的单元格(colspan)"></a>合并同一行上的单元格(colspan)</h5><ul><li><p>合并第一行“张三”、“22”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot; width=&quot;500&quot; height=&quot;300&quot; align=&quot;left&quot;&gt;</span><br><span class="line">&lt;caption&gt;表头&lt;/caption&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">      &lt;td colspan=&quot;2&quot;&gt;张三 22&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">      &lt;td&gt;前端工程师&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">      &lt;td&gt;李四&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;20&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;Android开发工程师&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">      &lt;td&gt;王五&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;18&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;java后台开发工程师&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></li><li><p>预览效果如下<br><img src="http://p9uaajhtk.bkt.clouddn.com/%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC2.png" alt="合并单元格2"></p></li></ul><h5 id="合并同一列上的单元格-rowspan"><a href="#合并同一列上的单元格-rowspan" class="headerlink" title="合并同一列上的单元格(rowspan)"></a>合并同一列上的单元格(rowspan)</h5><ul><li><p>合并第三列的的职位单元格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot; width=&quot;500&quot; height=&quot;300&quot; align=&quot;left&quot;&gt;</span><br><span class="line">&lt;caption&gt;表头&lt;/caption&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">      &lt;td colspan=&quot;2&quot;&gt;张三 22&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">      &lt;td rowspan=&quot;3&quot;&gt;前端工程师&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">      &lt;td&gt;李四&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;20&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">      &lt;td&gt;王五&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;18&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></li><li><p>效果如下</p></li></ul><p><img src="http://p9uaajhtk.bkt.clouddn.com/%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC3.png" alt="合并单元格3"></p><h4 id="表格标题"><a href="#表格标题" class="headerlink" title="表格标题"></a>表格标题</h4><ul><li><code>&lt;th&gt;&lt;/th&gt;</code></li><li><p>给上表添加标题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot; width=&quot;500&quot; height=&quot;300&quot; align=&quot;left&quot;&gt;</span><br><span class="line">&lt;caption&gt;表头&lt;/caption&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">      &lt;th&gt;姓名&lt;/th&gt;</span><br><span class="line">      &lt;th&gt;年龄&lt;/th&gt;</span><br><span class="line">      &lt;th&gt;职位&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">      &lt;td&gt;张三&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;22&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;前端工程师&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">      &lt;td&gt;李四&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;20&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;Android开发工程师&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">      &lt;td&gt;王五&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;18&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;java后台开发工程师&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></li><li><p>预览效果</p></li></ul><p><img src="http://p9uaajhtk.bkt.clouddn.com/%E6%B7%BB%E5%8A%A0%E6%A0%87%E9%A2%98.png" alt="添加标题"></p><h4 id="边框颜色"><a href="#边框颜色" class="headerlink" title="边框颜色"></a>边框颜色</h4><ul><li><code>bordercolor=&quot;red&quot;</code></li></ul><h4 id="内容垂直显示"><a href="#内容垂直显示" class="headerlink" title="内容垂直显示"></a>内容垂直显示</h4><ul><li><code>&lt;td valign=&quot;bottom&quot;&gt;张三&lt;/td&gt;</code><ul><li>valign=”top | middle | bottom”</li></ul></li></ul><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><ul><li>表单的作用是收集信息</li></ul><h3 id="表单的组成"><a href="#表单的组成" class="headerlink" title="表单的组成"></a>表单的组成</h3><ul><li>提示信息</li><li>表单控件</li><li>表单域</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li><code>&lt;form action=&quot;1.php&quot; method=&quot;get&quot;&gt;&lt;/form&gt;</code><ul><li>属性:action处理信息</li><li>method=”get|post”</li><li>get通过地址栏提供(传输)信息，安全性差</li><li>post通过1.php来处理信息，安全性高</li></ul></li></ul><h4 id="文本输入框"><a href="#文本输入框" class="headerlink" title="文本输入框"></a>文本输入框</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名:&lt;input type=&quot;text&quot; maxlength=&quot;6&quot; readonly=&quot;readonly&quot; disabled=&quot;disabled&quot; name=&quot;username&quot; value=&quot;大前端&quot;/&gt;</span><br></pre></td></tr></table></figure><ul><li>maxlength=”6” 限制输入字符长度</li><li>readonly=”readonly” 将输入框设置为只读状态(不能编辑)</li><li>disabled=”disabled” 输入框未激活状态</li><li>name=”username” 输入框的名称</li><li>value=”前端” 将输入框的内容传给处理文件</li></ul><h4 id="密码输入框"><a href="#密码输入框" class="headerlink" title="密码输入框"></a>密码输入框</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">密码:&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;radio&quot; name=&quot;gender&quot; checked=&quot;checked&quot;&gt;男</span><br></pre></td></tr></table></figure><ul><li>只有将name的值设置相同的时候，才能实现单选效果</li><li>checked=”checked”设置默认选择项</li></ul><h4 id="下拉列表"><a href="#下拉列表" class="headerlink" title="下拉列表"></a>下拉列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;select multiple=&quot;multiple&quot;&gt;</span><br><span class="line">&lt;option&gt;下拉列表选项&lt;/option&gt;</span><br><span class="line">&lt;option selected=&quot;selected&quot;&gt;下拉列表选项&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li>Multiple=”multiple”将下拉列表设置为多选项</li><li>selected=”selected”设置默认选中项目</li></ul><h4 id="对下拉列表进行分组"><a href="#对下拉列表进行分组" class="headerlink" title="对下拉列表进行分组"></a>对下拉列表进行分组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;optgroup label=&quot;北京市&quot;&gt;</span><br><span class="line">    &lt;option&gt;朝阳区&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;昌平区&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;海淀区&lt;/option&gt;</span><br><span class="line">&lt;/optgroup&gt;</span><br></pre></td></tr></table></figure><h4 id="多选框"><a href="#多选框" class="headerlink" title="多选框"></a>多选框</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;抽烟</span><br><span class="line">&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;喝酒</span><br><span class="line">&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;烫头</span><br></pre></td></tr></table></figure><ul><li>checked=”checked”设置默认选中项</li></ul><h4 id="多行文本框"><a href="#多行文本框" class="headerlink" title="多行文本框"></a>多行文本框</h4><ul><li><code>&lt;textarea cols=&quot;130&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;</code><ul><li>cols 控制输入字符的长度</li><li>rows 控制输入的行数</li></ul></li></ul><h4 id="文件上传控件"><a href="#文件上传控件" class="headerlink" title="文件上传控件"></a>文件上传控件</h4><ul><li><code>&lt;input type=&quot;file&quot;&gt;</code></li></ul><h4 id="文件提交按钮"><a href="#文件提交按钮" class="headerlink" title="文件提交按钮"></a>文件提交按钮</h4><ul><li><code>&lt;input type=&quot;submit&quot;&gt;</code> 可实现信息提交功能</li></ul><h4 id="普通按钮"><a href="#普通按钮" class="headerlink" title="普通按钮"></a>普通按钮</h4><ul><li><code>&lt;input type=&quot;button&quot; value=&quot;普通按钮&quot;&gt;</code><ul><li>不能提交信息，配合js使用</li></ul></li></ul><h4 id="图片按钮"><a href="#图片按钮" class="headerlink" title="图片按钮"></a>图片按钮</h4><ul><li><code>&lt;input type=&quot;image&quot; src=&quot;pic.jpg&quot;&gt;</code><ul><li>图片按钮可实现信息提交功能</li></ul></li></ul><h4 id="重置按钮"><a href="#重置按钮" class="headerlink" title="重置按钮"></a>重置按钮</h4><ul><li><code>&lt;input type=&quot;reset&quot;&gt;</code><ul><li>将信息重置到默认状态</li></ul></li></ul><h4 id="表单信息分组"><a href="#表单信息分组" class="headerlink" title="表单信息分组"></a>表单信息分组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;1.php&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;分组信息&lt;/legend&gt;    </span><br><span class="line">    &lt;/fieldset&gt;</span><br><span class="line">&lt;form&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;fieldset&gt;&lt;/fieldset&gt;</code>对表单信息分组</li><li><code>&lt;legend&gt;&lt;/legend&gt;</code> 表单信息分组名称</li></ul><h4 id="Html5补充表单控件"><a href="#Html5补充表单控件" class="headerlink" title="Html5补充表单控件"></a>Html5补充表单控件</h4><ul><li>网址控件<ul><li><code>&lt;input type=&quot;url&quot;&gt;</code></li></ul></li><li>日期控件<ul><li><code>&lt;input type=&quot;date&quot;&gt;</code></li></ul></li><li>时间控件<ul><li><code>&lt;input type=&quot;time&quot;&gt;</code></li></ul></li><li>数字控件<ul><li><code>&lt;input type=&quot;number&quot;&gt;</code></li></ul></li><li>滑块控件<ul><li><code>&lt;input type=&quot;range&quot;&gt;</code></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Web前端 </tag>
            
            <tag> Html </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『前端学习笔记（一）』</title>
      <link href="/2018/08/20/%E3%80%8E%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%8F/"/>
      <content type="html"><![CDATA[<h1 id="Html篇-一"><a href="#Html篇-一" class="headerlink" title="Html篇(一)"></a>Html篇(一)</h1><h2 id="Windows常用快捷键"><a href="#Windows常用快捷键" class="headerlink" title="Windows常用快捷键"></a>Windows常用快捷键</h2><table><thead><tr><th>快捷键</th><th>含义</th></tr></thead><tbody><tr><td>Ctrl+c</td><td>复制</td></tr><tr><td>Ctrl+v</td><td>粘贴</td></tr><tr><td>Ctrl+x</td><td>剪切</td></tr><tr><td>Ctrl+a</td><td>全选</td></tr><tr><td>Ctrl+s</td><td>保存</td></tr><tr><td>Ctrl+z</td><td>撤销</td></tr><tr><td>Windows+d</td><td>返回桌面</td></tr><tr><td>Windows+e</td><td>我的电脑</td></tr><tr><td>Windows+r</td><td>打开运行</td></tr><tr><td>Alt+tab</td><td>切换软件</td></tr><tr><td>Ctrl+tab</td><td>软件内文档之间切换</td></tr><tr><td>F2</td><td>重命名</td></tr><tr><td>F5</td><td>刷新页面</td></tr></tbody></table><a id="more"></a><h2 id="Sublime快捷键"><a href="#Sublime快捷键" class="headerlink" title="Sublime快捷键"></a>Sublime快捷键</h2><table><thead><tr><th>快捷键</th><th>含义</th></tr></thead><tbody><tr><td>Html:xt+tab</td><td>Html结构代码</td></tr><tr><td>!+tab</td><td>Html5的标签结构</td></tr><tr><td>tab</td><td>补全标签代码</td></tr><tr><td>Ctrl+shift+d</td><td>快速复制一行</td></tr><tr><td>Ctrl+shift+k</td><td>快速删除一行</td></tr><tr><td>Ctrl+鼠标左键单击</td><td>集体输入</td></tr><tr><td>Ctrl+h</td><td>查找替换</td></tr><tr><td>Ctrl+f</td><td>查找</td></tr><tr><td>Ctrl+/</td><td>注释</td></tr><tr><td>Ctrl+L</td><td>快速选择一行</td></tr><tr><td>Ctrl+shift+↑（↓）</td><td>快速上移(下移)一行</td></tr><tr><td>F11</td><td>全屏</td></tr></tbody></table><h2 id="Html结构标准"><a href="#Html结构标准" class="headerlink" title="Html结构标准"></a>Html结构标准</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;     声明文档类型</span><br><span class="line">&lt;html&gt;                 根标签</span><br><span class="line">&lt;head&gt;                 头标签</span><br><span class="line">&lt;title&gt;&lt;/title&gt;         标题标签</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;&lt;/body&gt;           主体标签</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="单标签"><a href="#单标签" class="headerlink" title="单标签"></a>单标签</h3><ul><li>注释标签 <code>&lt;!--注释标签--&gt;</code></li><li>换行标签 <code>&lt;br/&gt;</code></li><li>水平线标签 <code>&lt;hr/&gt;</code></li></ul><h3 id="双标签"><a href="#双标签" class="headerlink" title="双标签"></a>双标签</h3><ul><li><p>段落标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;文本内容&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>标题标签</p><ul><li>h1-h6</li><li>h1标签在一个页面里只能出现一次<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;段落1&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;段落2&lt;/h2&gt;</span><br><span class="line">&lt;h3&gt;段落3&lt;/h3&gt;</span><br><span class="line">&lt;h4&gt;段落4&lt;/h4&gt;</span><br><span class="line">&lt;h5&gt;段落5&lt;/h5&gt;</span><br><span class="line">&lt;h6&gt;段落6&lt;/h6&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>文本标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;font size=6 color=&quot;red&quot;&gt;文本内容&lt;/font&gt;</span><br></pre></td></tr></table></figure></li><li><p>文本加粗标签</p><ul><li>工作尽量用strong</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;strong&gt;文本&lt;/strong&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;文本&lt;/b&gt;</span><br></pre></td></tr></table></figure><ul><li>文本倾斜标签<ul><li>工作尽量用em</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;em&gt;文本&lt;/em&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i&gt;文本&lt;/i&gt;</span><br></pre></td></tr></table></figure><ul><li>删除线标签<ul><li>工作尽量使用del</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;del&gt;文本&lt;/del&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;s&gt;文本&lt;/s&gt;</span><br></pre></td></tr></table></figure><ul><li>下划线标签<ul><li>工作里尽量用用ins</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ins&gt;文本&lt;/ins&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;u&gt;文本&lt;/u&gt;</span><br></pre></td></tr></table></figure><h3 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;pic.jpg&quot; alt=&quot;替换文本&quot; title=&quot;提示文本&quot; width=&quot;300&quot; height=&quot;500&quot;/&gt;</span><br></pre></td></tr></table></figure><ul><li>src:图片的来源，必写属性</li><li>alt:替换文本，图片不显示的时候显示的文字</li><li>title:提示文本，鼠标放到图片上显示的文字</li><li>width:图片宽度</li><li>height:图片高度</li><li><strong>注</strong>:图片没有定义宽高的时候，图片按照百分之百比例显示，如果只是改变了图片的宽或高，图片等比例缩放</li></ul><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><h4 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h4><ul><li>相对于文件自身出发，就是相对路径</li></ul><h5 id="文件和图片-html文档-在同一个目录-文件夹-，直接写文件名"><a href="#文件和图片-html文档-在同一个目录-文件夹-，直接写文件名" class="headerlink" title="文件和图片(html文档)在同一个目录(文件夹)，直接写文件名"></a>文件和图片(html文档)在同一个目录(文件夹)，直接写文件名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;pic.jpg&quot; alt=&quot;替换文本&quot; title=&quot;提示文本&quot;/&gt;</span><br></pre></td></tr></table></figure><h5 id="图片-html文档-在文件的下一级目录里，文件夹名称-”-“-图片-html文档-名称"><a href="#图片-html文档-在文件的下一级目录里，文件夹名称-”-“-图片-html文档-名称" class="headerlink" title="图片(html文档)在文件的下一级目录里，文件夹名称+”/“+图片(html文档)名称"></a>图片(html文档)在文件的下一级目录里，文件夹名称+”/“+图片(html文档)名称</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;文件夹名/pic.jpg&quot; alt=&quot;替换文本&quot; title=&quot;提示文本&quot;/&gt;</span><br></pre></td></tr></table></figure><h5 id="图片-html-在文件的上一级目录里，-”-“-图片-html-名称"><a href="#图片-html-在文件的上一级目录里，-”-“-图片-html-名称" class="headerlink" title="图片(html)在文件的上一级目录里，..+”/“+图片(html)名称"></a>图片(html)在文件的上一级目录里，..+”/“+图片(html)名称</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;../pic.jpg&quot; alt=&quot;替换文本&quot; title=&quot;提示文本&quot;/&gt;</span><br></pre></td></tr></table></figure><h5 id="图片在文件的上一级的其他目录里，-”-“-文件夹名称-”-“-图片名称"><a href="#图片在文件的上一级的其他目录里，-”-“-文件夹名称-”-“-图片名称" class="headerlink" title="图片在文件的上一级的其他目录里，..+”/“+文件夹名称+”/“+图片名称"></a>图片在文件的上一级的其他目录里，..+”/“+文件夹名称+”/“+图片名称</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;../文件夹名称/pic.jpg&quot; alt=&quot;替换文本&quot; title=&quot;提示文本&quot;/&gt;</span><br></pre></td></tr></table></figure><h4 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;F:\文件夹\pic.jpg&quot; alt=&quot;替换文本&quot; title=&quot;提示文本&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;文件.html&quot; title=&quot;图片标签&quot; target=&quot;_self&quot;&gt;超链接&lt;/a&gt;</span><br></pre></td></tr></table></figure><ul><li>href:跳转的路径(跳转的页面)，必写属性</li><li>title:提示文本，鼠标放到链接上显示的文字</li><li>target=”_self” 默认值，在自身页面打开(关闭自身页面，打开链接页面)</li><li>target=”_blank”打开新页面(自身页面不关闭，打开一个新的页面)</li></ul><h4 id="锚链接"><a href="#锚链接" class="headerlink" title="锚链接"></a>锚链接</h4><ol><li>先定义一个锚点 <code>&lt;p id=&quot;sd&quot;&gt;</code></li><li>超链接到锚点 <code>&lt;a href=&quot;#sd&quot;&gt;回到顶部&lt;/a&gt;</code></li></ol><h4 id="空链"><a href="#空链" class="headerlink" title="空链"></a>空链</h4><ul><li>不知道链接到哪个页面的时候，用空链<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#&quot;&gt;空链&lt;/a&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="压缩文件下载-不推荐使用"><a href="#压缩文件下载-不推荐使用" class="headerlink" title="压缩文件下载(不推荐使用)"></a>压缩文件下载(不推荐使用)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;../../文件.rar&quot;&gt;压缩包&lt;/a&gt;</span><br></pre></td></tr></table></figure><h4 id="超链接优化写法"><a href="#超链接优化写法" class="headerlink" title="超链接优化写法"></a>超链接优化写法</h4><ul><li>让所有的超链接都在新窗口打开<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base target=&quot;_blank&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p><img src="http://p9uaajhtk.bkt.clouddn.com/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6.png" alt="特殊字符"></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul type=&quot;disc&quot;&gt;</span><br><span class="line">&lt;li&gt;文本&lt;/li&gt;    列表项</span><br><span class="line">&lt;li&gt;文本&lt;/li&gt;</span><br><span class="line">&lt;li&gt;文本&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><ul><li>type=”square” 小方块</li><li>type=”disc” 实心小圆圈(默认)</li><li>type=”circle” 空心小圆圈</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol type=&quot;1&quot; start=&quot;3&quot;&gt;</span><br><span class="line">&lt;li&gt;文本&lt;/li&gt;    列表项</span><br><span class="line">&lt;li&gt;文本&lt;/li&gt;</span><br><span class="line">&lt;li&gt;文本&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><ul><li>type=”1、a、A、i、I” </li><li>start决定了开始的位置</li></ul><h4 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dl&gt;</span><br><span class="line">  &lt;dt&gt;&lt;/dt&gt;</span><br><span class="line">  &lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">  &lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure><h3 id="音乐标签"><a href="#音乐标签" class="headerlink" title="音乐标签"></a>音乐标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;embed src=&quot;1.mp3&quot; hidden=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><p><img src="http://p9uaajhtk.bkt.clouddn.com/%E6%BB%9A%E5%8A%A8.png" alt="滚动"></p>]]></content>
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Web前端 </tag>
            
            <tag> Html </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TextView显示html文本</title>
      <link href="/2018/07/26/TextView%E6%98%BE%E7%A4%BAhtml%E6%96%87%E6%9C%AC/"/>
      <content type="html"><![CDATA[<blockquote><p>以前在项目中遇到一个需求就是，在Activity要展示后台返回的html文本，网上找了下相关方法并测试可行，不久就发现了新问题，显示的图片太小了，并且比例不协调。最后经过一番折腾解决了…</p></blockquote><a id="more"></a><h1 id="后台返回的html数据"><a href="#后台返回的html数据" class="headerlink" title="后台返回的html数据"></a>后台返回的html数据</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style=&quot;text-align: center;&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;http://cdn.image.51-ck.com/forum%2F3be4a7f53bc44e43830667ff206e936f&quot; alt=&quot;三重礼.jpg&quot;&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p style=&quot;text-align: center;&quot;&gt;百日创客培养计划开始啦！&lt;/p&gt;</span><br><span class="line">&lt;p style=&quot;text-align: center;&quot;&gt;活动期间，登录平台完善用户信息，并充值100元以上，即可参与“百日创客培养计划”&lt;/p&gt;</span><br><span class="line">&lt;p style=&quot;text-align: center;&quot;&gt;我们为你精心准备了创客3重礼&lt;/p&gt;</span><br><span class="line">&lt;p style=&quot;text-align: center;&quot;&gt;一重礼 创客幸运礼：</span><br><span class="line">    &lt;span&gt;活动结束后，每个地区的线下体验中心将组织抽奖活动，从该地区所有参加活动的用户中分别抽取一等奖、二等奖、三等奖！&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p style=&quot;text-align: center;&quot;&gt;</span><br><span class="line">    &lt;span&gt;二重礼 创客成长礼：&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;活动结束后，平台将会在每所学校中抽取1名用户，授予“&lt;/span&gt;</span><br><span class="line">    &lt;span lang=&quot;EN-US&quot;&gt;3D&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;创客大使”称号，将有机会以学校创客代表的身份参加51-创客平台及学校举办的多项活动&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;，丰富您的创客经历！&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p style=&quot;text-align: center;&quot;&gt;</span><br><span class="line">    &lt;span&gt;三重礼 创客打印礼：充多少送多少，每天发放充值金额1%作为激励基金，持续100天，为您的创作打印提供坚定力量！&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p style=&quot;text-align: center;&quot;&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p style=&quot;text-align: center;&quot;&gt;活动辣么劲爆！！！还不赶快来参与，活动地址：</span><br><span class="line">    &lt;b&gt;</span><br><span class="line">        &lt;u&gt;</span><br><span class="line">            &lt;a target=&quot;_blank&quot; href=&quot;http://www.51-ck.com/pc_activity/topUp&quot;&gt;点我就可以啦~&lt;/a&gt;</span><br><span class="line">        &lt;/u&gt;</span><br><span class="line">    &lt;/b&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><h1 id="解析html的方法"><a href="#解析html的方法" class="headerlink" title="解析html的方法"></a>解析html的方法</h1><ul><li>因为html文本数据量大，需要开启一个子线程来执行该操作</li><li>htmlContent即为传入的html数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void htmlWebPic(final String htmlContent) &#123;</span><br><span class="line">        Thread t = new Thread(new Runnable() &#123;</span><br><span class="line">            Message msg = handler.obtainMessage();</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Html.ImageGetter imageGetter = new Html.ImageGetter() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Drawable getDrawable(String source) &#123;</span><br><span class="line">                        URL url = null;</span><br><span class="line">                        Drawable drawable = null;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            url = new URL(source);</span><br><span class="line">                            drawable = Drawable.createFromStream(url.openStream(), null);</span><br><span class="line"></span><br><span class="line">                            WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">                            int width = wm.getDefaultDisplay().getWidth();</span><br><span class="line">                            int intrinsicWidth = drawable.getIntrinsicWidth();</span><br><span class="line">                            int intrinsicHeight = drawable.getIntrinsicHeight();</span><br><span class="line">                            if (intrinsicWidth &lt; 10) &#123;</span><br><span class="line">                                drawable.setBounds(0, 0, 50, 50);</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                int height = (width * intrinsicHeight) / intrinsicWidth;</span><br><span class="line">                                drawable.setBounds(0, 0, width, height);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125; catch (MalformedURLException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125; catch (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        return drawable;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                CharSequence result = Html.fromHtml(htmlContent, imageGetter, null);</span><br><span class="line">                msg.what = 0x12;</span><br><span class="line">                msg.obj = result;</span><br><span class="line">                handler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="在UI线程中接收处理好的数据并显示"><a href="#在UI线程中接收处理好的数据并显示" class="headerlink" title="在UI线程中接收处理好的数据并显示"></a>在UI线程中接收处理好的数据并显示</h1><ul><li>tvContent即为要显现该html的TextView控件名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private Handler handler = new Handler(new Handler.Callback() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public boolean handleMessage(Message msg) &#123;</span><br><span class="line">         if (msg.what == 0x12) &#123;</span><br><span class="line">             tvContent.setText((CharSequence) msg.obj);</span><br><span class="line">             tvContent.setMovementMethod(LinkMovementMethod.getInstance());</span><br><span class="line">         &#125;</span><br><span class="line">         return false;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h1 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h1><h2 id="解析html中的图片用到的方法，并得到该图片的drawable"><a href="#解析html中的图片用到的方法，并得到该图片的drawable" class="headerlink" title="解析html中的图片用到的方法，并得到该图片的drawable :"></a>解析html中的图片用到的方法，并得到该图片的drawable :</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Drawable drawable = Drawable.createFromStream(url.openStream(), null);</span><br></pre></td></tr></table></figure><h2 id="获取手机屏幕的宽度width"><a href="#获取手机屏幕的宽度width" class="headerlink" title="获取手机屏幕的宽度width"></a>获取手机屏幕的宽度width</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">int width = wm.getDefaultDisplay().getWidth();</span><br></pre></td></tr></table></figure><h2 id="得到html中当前图片的宽和高"><a href="#得到html中当前图片的宽和高" class="headerlink" title="得到html中当前图片的宽和高"></a>得到html中当前图片的宽和高</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int intrinsicWidth = drawable.getIntrinsicWidth();</span><br><span class="line">int intrinsicHeight = drawable.getIntrinsicHeight();</span><br></pre></td></tr></table></figure><h2 id="过滤是否是表情符"><a href="#过滤是否是表情符" class="headerlink" title="过滤是否是表情符"></a>过滤是否是表情符</h2><blockquote><p>经测试，当图片的宽小于10的时候，多半都是表情符，所以增加一个判断是否是表情符，并将该表情符的宽高均设置为50</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (intrinsicWidth &lt; 10) &#123;</span><br><span class="line"> drawable.setBounds(0, 0, 50, 50);</span><br><span class="line">&#125; else &#123;</span><br><span class="line"> //(略)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对图片进行比例设置"><a href="#对图片进行比例设置" class="headerlink" title="对图片进行比例设置"></a>对图片进行比例设置</h2><ul><li>让图片的宽和手机屏幕一致</li><li>$\frac{intrinsicHeight}{intrinsicWidth}$得出一个单位的intrinsicWidth需要多少个单位的intrinsicHeight</li><li>因为让图片的宽和手机屏幕一致，即有intrinsicWidth*width单位的宽</li><li>即图片实际高度为$\frac{intrinsicHeight}{intrinsicWidth}*width$</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (intrinsicWidth &lt; 10) &#123;</span><br><span class="line">//(略)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">int height = (width * intrinsicHeight) / intrinsicWidth;</span><br><span class="line">drawable.setBounds(0, 0, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> TextView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android开发中的一些小技巧</title>
      <link href="/2018/07/24/Android%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <content type="html"><![CDATA[<blockquote><p>日常开发过程中常用到的一些方法或属性</p></blockquote><a id="more"></a><h1 id="去掉Android5-0以后button自带阴影效果"><a href="#去掉Android5-0以后button自带阴影效果" class="headerlink" title="去掉Android5.0以后button自带阴影效果"></a>去掉Android5.0以后button自带阴影效果</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">style=&quot;?android:attr/borderlessButtonStyle&quot;</span><br></pre></td></tr></table></figure><h1 id="改变editttext光标的颜色"><a href="#改变editttext光标的颜色" class="headerlink" title="改变editttext光标的颜色"></a>改变editttext光标的颜色</h1><ul><li>在资源文件drawable文件夹下新建一个光标控件color_cursor.xml</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt;</span><br><span class="line">    &lt;size android:width=&quot;1dp&quot; /&gt;</span><br><span class="line">    &lt;solid android:color=&quot;#008000&quot;  /&gt;</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure><ul><li>设置EditText:android:textCursorDrawable=”@drawable/color_cursor”</li></ul><h1 id="取消listview点击的背景颜色"><a href="#取消listview点击的背景颜色" class="headerlink" title="取消listview点击的背景颜色"></a>取消listview点击的背景颜色</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:listSelector=&quot;#00000000&quot;</span><br></pre></td></tr></table></figure><h1 id="一个简单的json格式文件"><a href="#一个简单的json格式文件" class="headerlink" title="一个简单的json格式文件"></a>一个简单的json格式文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">    &quot;job&quot;: &quot;总经理&quot;,</span><br><span class="line">    &quot;phone&quot;: &quot;13987654321&quot;,</span><br><span class="line">    &quot;email&quot;: &quot;13245@163.com&quot;,</span><br><span class="line">    &quot;Companyname&quot;: &quot;杭州阿狸科技有限公司&quot;,</span><br><span class="line">    &quot;commpanyaddress&quot;: &quot;杭州市西湖区&quot;,</span><br><span class="line">    &quot;industry&quot;: &quot;IT软件&quot;,</span><br><span class="line">    &quot;hobby&quot;: &quot;爬山&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="获取屏幕状态栏的高度的方法"><a href="#获取屏幕状态栏的高度的方法" class="headerlink" title="获取屏幕状态栏的高度的方法"></a>获取屏幕状态栏的高度的方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void onWindowFocusChanged(boolean hasFocus) &#123;</span><br><span class="line">       super.onWindowFocusChanged(hasFocus);</span><br><span class="line">       Rect frame = new Rect();</span><br><span class="line">       getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);</span><br><span class="line">       // 状态栏高度</span><br><span class="line">       statusBarHeight = frame.top;</span><br><span class="line">       View v = getWindow().findViewById(Window.ID_ANDROID_CONTENT);</span><br><span class="line">       int contentTop = v.getTop();</span><br><span class="line">       // statusBarHeight是上面所求的状态栏的高度</span><br><span class="line">       int titleBarHeight = contentTop - statusBarHeight;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="将dp转换为像素的方法"><a href="#将dp转换为像素的方法" class="headerlink" title="将dp转换为像素的方法"></a>将dp转换为像素的方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static int dip2px(Context context, float dpValue) &#123;</span><br><span class="line">       final float scale = context.getResources().getDisplayMetrics().density;</span><br><span class="line">       return (int) (dpValue * scale + 0.5f);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="解决-在scrollview与嵌套listview的页面中-一进入不是最上面-在最外层布局添加该属性"><a href="#解决-在scrollview与嵌套listview的页面中-一进入不是最上面-在最外层布局添加该属性" class="headerlink" title="解决 在scrollview与嵌套listview的页面中 一进入不是最上面 在最外层布局添加该属性"></a>解决 在scrollview与嵌套listview的页面中 一进入不是最上面 在最外层布局添加该属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android:descendantFocusability=&quot;blocksDescendants&quot;</span><br></pre></td></tr></table></figure><h1 id="解决ScorllView嵌套ListView只显示一行的问题-注意：该方法调用要“listview-setAdapter-适配器-”之后"><a href="#解决ScorllView嵌套ListView只显示一行的问题-注意：该方法调用要“listview-setAdapter-适配器-”之后" class="headerlink" title="解决ScorllView嵌套ListView只显示一行的问题(注意：该方法调用要“listview.setAdapter(适配器)”之后)"></a>解决ScorllView嵌套ListView只显示一行的问题(注意：该方法调用要“listview.setAdapter(适配器)”之后)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void setListViewHeightBasedOnChildren(ListView listView) &#123;</span><br><span class="line">       ListAdapter listAdapter = listView.getAdapter();</span><br><span class="line">       if (listAdapter == null) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       int totalHeight = 0;</span><br><span class="line">       for (int i = 0; i &lt; listAdapter.getCount(); i++) &#123;</span><br><span class="line">           View listItem = listAdapter.getView(i, null, listView);</span><br><span class="line">           listItem.measure(0, 0);</span><br><span class="line">           totalHeight += listItem.getMeasuredHeight();</span><br><span class="line">       &#125;</span><br><span class="line">       ViewGroup.LayoutParams params = listView.getLayoutParams();</span><br><span class="line">       params.height = totalHeight + (listView.getDividerHeight() * (listAdapter.getCount() - 1));</span><br><span class="line">       listView.setLayoutParams(params);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="去掉edittext的获取焦点（禁止已进入有edittext的activity中-自动弹出输入法）"><a href="#去掉edittext的获取焦点（禁止已进入有edittext的activity中-自动弹出输入法）" class="headerlink" title="去掉edittext的获取焦点（禁止已进入有edittext的activity中 自动弹出输入法）"></a>去掉edittext的获取焦点（禁止已进入有edittext的activity中 自动弹出输入法）</h1><ul><li>在最外层布局中加上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:focusable=&quot;true&quot;     </span><br><span class="line">android:focusableInTouchMode=&quot;true&quot;</span><br></pre></td></tr></table></figure><h1 id="解决-listview的item的长按监听与点击监听的冲突"><a href="#解决-listview的item的长按监听与点击监听的冲突" class="headerlink" title="解决 listview的item的长按监听与点击监听的冲突"></a>解决 listview的item的长按监听与点击监听的冲突</h1><ul><li>listveiew 的长按监听事件返回值有false 改为true</li></ul><h1 id="将bitmap转化为二进制流"><a href="#将bitmap转化为二进制流" class="headerlink" title="将bitmap转化为二进制流"></a>将bitmap转化为二进制流</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public byte[] getBitmapByte(Bitmap bitmap)&#123;</span><br><span class="line">       ByteArrayOutputStream out = new ByteArrayOutputStream();</span><br><span class="line">       bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out);</span><br><span class="line">       try &#123;</span><br><span class="line">           out.flush();</span><br><span class="line">           out.close();</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       return out.toByteArray();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="图片转成string"><a href="#图片转成string" class="headerlink" title="图片转成string"></a>图片转成string</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static String convertIconToString(Bitmap bitmap)  </span><br><span class="line">    &#123;  </span><br><span class="line">        ByteArrayOutputStream baos = new ByteArrayOutputStream();// outputstream  </span><br><span class="line">        bitmap.compress(CompressFormat.PNG, 100, baos);  </span><br><span class="line">        byte[] appicon = baos.toByteArray();// 转为byte数组  </span><br><span class="line">        return Base64.encodeToString(appicon, Base64.DEFAULT);  </span><br><span class="line">  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="string转成bitmap"><a href="#string转成bitmap" class="headerlink" title="string转成bitmap"></a>string转成bitmap</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static Bitmap convertStringToIcon(String st)  </span><br><span class="line">    &#123;  </span><br><span class="line">        // OutputStream out;  </span><br><span class="line">        Bitmap bitmap = null;  </span><br><span class="line">        try  </span><br><span class="line">        &#123;  </span><br><span class="line">            // out = new FileOutputStream(&quot;/sdcard/aa.jpg&quot;);  </span><br><span class="line">            byte[] bitmapArray;  </span><br><span class="line">            bitmapArray = Base64.decode(st, Base64.DEFAULT);  </span><br><span class="line">            bitmap =  </span><br><span class="line">                    BitmapFactory.decodeByteArray(bitmapArray, 0,  </span><br><span class="line">                            bitmapArray.length);  </span><br><span class="line">            // bitmap.compress(Bitmap.CompressFormat.PNG, 100, out);  </span><br><span class="line">            return bitmap;  </span><br><span class="line">        &#125;  </span><br><span class="line">        catch (Exception e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            return null;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="将dp转换为像素的方法-1"><a href="#将dp转换为像素的方法-1" class="headerlink" title="将dp转换为像素的方法"></a>将dp转换为像素的方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static int dip2px(Context context, float dpValue) &#123;</span><br><span class="line">       final float scale = context.getResources().getDisplayMetrics().density;</span><br><span class="line">       return (int) (dpValue * scale + 0.5f);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="返回按钮的监听事件"><a href="#返回按钮的监听事件" class="headerlink" title="返回按钮的监听事件"></a>返回按钮的监听事件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">    public boolean onKeyDown(int keyCode, KeyEvent event) &#123;</span><br><span class="line">        if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.getRepeatCount() == 0) &#123;</span><br><span class="line">     </span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="生成随机数字和字母"><a href="#生成随机数字和字母" class="headerlink" title="生成随机数字和字母"></a>生成随机数字和字母</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static String getStringRandom(int length) &#123;  </span><br><span class="line">          </span><br><span class="line">        String val = &quot;&quot;;  </span><br><span class="line">        Random random = new Random();  </span><br><span class="line">          </span><br><span class="line">        //参数length，表示生成几位随机数  </span><br><span class="line">        for(int i = 0; i &lt; length; i++) &#123;  </span><br><span class="line">              </span><br><span class="line">            String charOrNum = random.nextInt(2) % 2 == 0 ? &quot;char&quot; : &quot;num&quot;;  </span><br><span class="line">            //输出字母还是数字  </span><br><span class="line">            if( &quot;char&quot;.equalsIgnoreCase(charOrNum) ) &#123;  </span><br><span class="line">                //输出是大写字母还是小写字母  </span><br><span class="line">                int temp = random.nextInt(2) % 2 == 0 ? 65 : 97;  </span><br><span class="line">                val += (char)(random.nextInt(26) + temp);  </span><br><span class="line">            &#125; else if( &quot;num&quot;.equalsIgnoreCase(charOrNum) ) &#123;  </span><br><span class="line">                val += String.valueOf(random.nextInt(10));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return val;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="将bitmap转换为-png格式的图片"><a href="#将bitmap转换为-png格式的图片" class="headerlink" title="将bitmap转换为.png格式的图片"></a>将bitmap转换为.png格式的图片</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void savePNG_After(Bitmap bitmap, String name) &#123;</span><br><span class="line">        File file = new File(name);</span><br><span class="line">        try &#123;</span><br><span class="line">            FileOutputStream out = new FileOutputStream(file);</span><br><span class="line">            if (bitmap.compress(Bitmap.CompressFormat.PNG, 30, out)) &#123;</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="将dp转换为像素的方法-2"><a href="#将dp转换为像素的方法-2" class="headerlink" title="将dp转换为像素的方法"></a>将dp转换为像素的方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static int dip2px(Context context, float dpValue) &#123;</span><br><span class="line">        final float scale = context.getResources().getDisplayMetrics().density;</span><br><span class="line">        return (int) (dpValue * scale + 0.5f);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void delFile(String fileName)&#123;</span><br><span class="line">        File file = new File(&quot;sdcard/&quot; + fileName);</span><br><span class="line">        if(file.isFile())&#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        file.exists();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="判断当前指定路径中的指定某个文件是否存在的方法"><a href="#判断当前指定路径中的指定某个文件是否存在的方法" class="headerlink" title="判断当前指定路径中的指定某个文件是否存在的方法"></a>判断当前指定路径中的指定某个文件是否存在的方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public boolean fileIsExists()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            File f=new File(&quot;storage/emulated/0/bluetooth/baojia.xls&quot;);</span><br><span class="line">            if(!f.exists())&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="将从list集合中获得的数据以逗号拼接字符串"><a href="#将从list集合中获得的数据以逗号拼接字符串" class="headerlink" title="将从list集合中获得的数据以逗号拼接字符串"></a>将从list集合中获得的数据以逗号拼接字符串</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public String ListToString(List&lt;String&gt; tempSelcetGoodsList) &#123;</span><br><span class="line">        if (tempSelcetGoodsList == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        boolean flag = false;</span><br><span class="line">        for (String string : tempSelcetGoodsList) &#123;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                sb.append(&quot;，&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                flag = true;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(string);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="将以逗号拼接的字符串，以逗号切割-并加到List集合中"><a href="#将以逗号拼接的字符串，以逗号切割-并加到List集合中" class="headerlink" title="将以逗号拼接的字符串，以逗号切割 并加到List集合中"></a>将以逗号拼接的字符串，以逗号切割 并加到List集合中</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;a,b,c,d&quot;;</span><br><span class="line"></span><br><span class="line">String strs[] = str.split(&quot;,&quot;);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; strList = Arrays.asList(strs);</span><br></pre></td></tr></table></figure><h1 id="可以让textView上的字可以被选中-复制-等操作"><a href="#可以让textView上的字可以被选中-复制-等操作" class="headerlink" title="可以让textView上的字可以被选中 复制 等操作"></a>可以让textView上的字可以被选中 复制 等操作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:textIsSelectable=&quot;true&quot;</span><br></pre></td></tr></table></figure><h1 id="JAVA截取字符串后几位"><a href="#JAVA截取字符串后几位" class="headerlink" title="JAVA截取字符串后几位"></a>JAVA截取字符串后几位</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String str = &quot;1234567890111&quot;;</span><br><span class="line">int n = 4;</span><br><span class="line">System.out.println(str.substring(str.length()-n));</span><br></pre></td></tr></table></figure><h1 id="EditText多行输入"><a href="#EditText多行输入" class="headerlink" title="EditText多行输入"></a>EditText多行输入</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:inputType=&quot;textMultiLine&quot;//可以显示多行</span><br><span class="line">android:gravity=&quot;left|top&quot;//输入时光标左上角</span><br><span class="line">android:minLines=&quot;6&quot; //最小显示6行</span><br></pre></td></tr></table></figure><h1 id="Activity去掉状态栏"><a href="#Activity去掉状态栏" class="headerlink" title="Activity去掉状态栏"></a>Activity去掉状态栏</h1><ul><li>在styles.xml文件中添加样式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;style name=&quot;AppTheme.NoBar&quot;&gt;  </span><br><span class="line">        &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;  </span><br><span class="line">        &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;  </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>在需要去掉状态栏的acitivity的Manifest文件中添加</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:theme=&quot;@style/AppTheme.NoBar&quot;</span><br></pre></td></tr></table></figure><ul><li>Glide加载时等比例缩放图片至屏幕宽度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(activity).load(yourUrl).asBitmap().into(new SimpleTarget&lt;Bitmap&gt;(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL) &#123;  </span><br><span class="line">                    @Override  </span><br><span class="line">                    public void onResourceReady(Bitmap resource, GlideAnimation&lt;? super Bitmap&gt; glideAnimation) &#123;  </span><br><span class="line">                        int imageWidth = resource.getWidth();  </span><br><span class="line">                        int imageHeight = resource.getHeight();  </span><br><span class="line">                        int height = ScreenUtils.getScreenWidth() * imageHeight / imageWidth;  </span><br><span class="line">                        ViewGroup.LayoutParams para = imageView.getLayoutParams();  </span><br><span class="line">                        para.height = height;  </span><br><span class="line">                        para.width = ScreenUtils.getScreenWidth();  </span><br><span class="line">                        imageView.setImageBitmap(resource);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TextView中部分文本点击可跳转</title>
      <link href="/2018/07/24/TextView%E4%B8%AD%E9%83%A8%E5%88%86%E6%96%87%E6%9C%AC%E7%82%B9%E5%87%BB%E5%8F%AF%E8%B7%B3%E8%BD%AC/"/>
      <content type="html"><![CDATA[<blockquote><p>以前在项目中遇到了一个需求就是，在一段文段的最后加上“查看图片”四个字，并点击该字可以进行查看图片的相应操作，解决方案如下…</p></blockquote><a id="more"></a><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p><img src="http://p9uaajhtk.bkt.clouddn.com/textView.png" alt="textView"></p><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><ul><li>s1为从后台获取的数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s1 = bean.getContent();</span><br><span class="line">final String content = s1 + &quot;查看图片&gt;&quot;;</span><br><span class="line">Spannable spannable = Spannable.Factory.getInstance().newSpannable(content);</span><br><span class="line">          spannable.setSpan(new ClickableSpan() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onClick(View widget) &#123;</span><br><span class="line">              //相关跳转操作</span><br><span class="line">             &#125;</span><br><span class="line">    &#125;, content.length() - 5, content.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">tvText.setText(spannable);</span><br><span class="line">tvText.setMovementMethod(LinkMovementMethod.getInstance());</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Android </tag>
            
            <tag> TextView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>json数据转换成数组</title>
      <link href="/2018/07/24/json%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B0%E7%BB%84/"/>
      <content type="html"><![CDATA[<blockquote><p>最近在优化项目，之前是手写的popupWindow弹框，不是特别美观，看到了别人写的更好的，想拿来用，于是问题来了，他接收的数据是数组类型，有一维数组和二维数组，而公司项目后台是返回的json格式的数据，怎么将json格式转换成他要的数组呢？最后经过一番折腾，解决了…</p></blockquote><a id="more"></a><h1 id="后台返回的json数据"><a href="#后台返回的json数据" class="headerlink" title="后台返回的json数据"></a>后台返回的json数据</h1><ul><li>如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;head&quot;: &#123;</span><br><span class="line">&quot;respCode&quot;: &quot;0000000&quot;,</span><br><span class="line">&quot;respContent&quot;: &quot;执行成功&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;body&quot;: &#123;</span><br><span class="line">&quot;sortList&quot;: [&#123;</span><br><span class="line">&quot;name&quot;: &quot;最新&quot;,</span><br><span class="line">&quot;value&quot;: 1</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;name&quot;: &quot;点赞&quot;,</span><br><span class="line">&quot;value&quot;: 2</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;name&quot;: &quot;销量&quot;,</span><br><span class="line">&quot;value&quot;: 3</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;name&quot;: &quot;热度&quot;,</span><br><span class="line">&quot;value&quot;: 4</span><br><span class="line">&#125;],</span><br><span class="line">&quot;bigCategorys&quot;: [&#123;</span><br><span class="line">&quot;smallCategorys&quot;: [&#123;</span><br><span class="line">&quot;id&quot;: &quot;196B759A8E2B11E7AB4600163E0EB16B&quot;,</span><br><span class="line">&quot;name&quot;: &quot;动物模型&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;id&quot;: &quot;1F2FCFD18E2B11E7AB4600163E0EB16B&quot;,</span><br><span class="line">&quot;name&quot;: &quot;植物模型&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;id&quot;: &quot;2DADE1FF8E2B11E7AB4600163E0EB16B&quot;,</span><br><span class="line">&quot;name&quot;: &quot;飞禽&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;id&quot;: &quot;3300833A8E2B11E7AB4600163E0EB16B&quot;,</span><br><span class="line">&quot;name&quot;: &quot;奇异生物&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;id&quot;: &quot;E827044F8E2B11E7AB4600163E0EB16B&quot;,</span><br><span class="line">&quot;name&quot;: &quot;水生生物&quot;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;name&quot;: &quot;动物植物&quot;,</span><br><span class="line">&quot;id&quot;: &quot;E3BAF9708E2A11E7AB4600163E0EB16B&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;smallCategorys&quot;: [&#123;</span><br><span class="line">&quot;id&quot;: &quot;4A21F21A8E2B11E7AB4600163E0EB16B&quot;,</span><br><span class="line">&quot;name&quot;: &quot;办公工具&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;id&quot;: &quot;156AC3D98E3111E7AB4600163E0EB16B&quot;,</span><br><span class="line">&quot;name&quot;: &quot;机械工具&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;id&quot;: &quot;1B02B2EF8E3111E7AB4600163E0EB16B&quot;,</span><br><span class="line">&quot;name&quot;: &quot;手工工具&quot;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;name&quot;: &quot;工具用具&quot;,</span><br><span class="line">&quot;id&quot;: &quot;F0A71C2A8E2A11E7AB4600163E0EB16B&quot;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="通过GsonFromt生成一个名为DesignClassBean的类"><a href="#通过GsonFromt生成一个名为DesignClassBean的类" class="headerlink" title="通过GsonFromt生成一个名为DesignClassBean的类"></a>通过GsonFromt生成一个名为DesignClassBean的类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DesignClassBean designClassBean = new Gson().fromJson(response, DesignClassBean.class);</span><br></pre></td></tr></table></figure><h1 id="将Json数据转换成一维数组"><a href="#将Json数据转换成一维数组" class="headerlink" title="将Json数据转换成一维数组"></a>将Json数据转换成一维数组</h1><ul><li><p>一维数组的list集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;DesignClassBean.BodyBean.SortListBean&gt; oneList = designClassBean.getBody().getSortList();</span><br></pre></td></tr></table></figure></li><li><p>创建一个ArrayList集合，并遍历得到其中的name字段值，并加到ArrayList集合中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; oneArrayList = new ArrayList&lt;String&gt;();</span><br><span class="line">for (int i = 0; i &lt; oneList.size(); i++) &#123;</span><br><span class="line">     String name = oneList.get(i).getName();</span><br><span class="line">     oneArrayList.add(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将ArrayList集合转换成一维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] oneArrays = oneArrayList.toArray(new String[oneArrayList.size()]);</span><br></pre></td></tr></table></figure></li><li><p>即oneArrays就是我们要得到的一维数组</p></li></ul><h1 id="将Json数据转换成二维数组"><a href="#将Json数据转换成二维数组" class="headerlink" title="将Json数据转换成二维数组"></a>将Json数据转换成二维数组</h1><ul><li><p>二维数组的list集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;DesignClassBean.BodyBean.BigCategorysBean&gt; twoList = designClassBean.getBody().getBigCategorys();</span><br></pre></td></tr></table></figure></li><li><p>创建一个ArrayList集合twoArrayList</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; twoArrayList = new ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure></li><li><p>创建一个空二维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[][] twoArray = new String[twoList.size()][];</span><br></pre></td></tr></table></figure></li><li><p>嵌套for循环将值放入二维数组中</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; twoList.size(); i++) &#123;</span><br><span class="line">            String name = twoList.get(i).getName();</span><br><span class="line">            twoArrayList.add(name);</span><br><span class="line">            ArrayList&lt;String&gt; threeArrayList = new ArrayList&lt;String&gt;();</span><br><span class="line">            List&lt;DesignClassBean.BodyBean.BigCategorysBean.SmallCategorysBean&gt; smallCategorys = bigCategorys.get(i).getSmallCategorys();</span><br><span class="line">            for (int j = 0; j &lt; smallCategorys.size(); j++) &#123;</span><br><span class="line">                String smallname = smallCategorys.get(j).getName();</span><br><span class="line">                threeArrayList.add(smallname);</span><br><span class="line">            &#125;</span><br><span class="line">            twoArray[i] = threeArrayList.toArray(new String[threeArrayList.size()]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>twoArray即为我们需要的二维数组</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> java </tag>
            
            <tag> 数组 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>未选择的路</title>
      <link href="/2018/07/19/%E6%9C%AA%E9%80%89%E6%8B%A9%E7%9A%84%E8%B7%AF/"/>
      <content type="html"><![CDATA[<p>罗伯特·弗洛斯特<br></p><p>黄色的树林里分出两条路，<br></p><p>可惜我不能同时去涉足， <br></p><p>我向那路口久久伫立，<br><br><a id="more"></a><br>我向着一条路极目望去，<br></p><p>直到它消失在丛林深处。<br></p><p>但我却选了另外一条路，<br></p><p>它荒草萋萋，十分幽寂，<br></p><p>显得更诱人，更美丽；<br></p><p>虽然在这条小路上，<br></p><p>很少留下旅人的足迹。<br></p><p>那天清晨落叶满地，<br></p><p>两条路都未经脚印污染。<br></p><p>啊，留下一条路等改日再见！<br></p><p>但我知道路径延绵无尽头，<br></p><p>恐怕我难以再回返。<br></p><p>也许多少年后在某个地方，<br></p><p>我将轻声叹息将往事回顾：<br></p><p>我将轻声叹息将往事回顾：<br></p><p>一片树林里分出两条路<br></p><p>而我选择了人迹更少的一条，<br></p><p>从此决定了我一生的道路。<br></p>]]></content>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 诗歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android横竖屏切换时不销毁当前Activity</title>
      <link href="/2018/07/18/Android%E6%A8%AA%E7%AB%96%E5%B1%8F%E5%88%87%E6%8D%A2%E6%97%B6%E4%B8%8D%E9%94%80%E6%AF%81%E5%BD%93%E5%89%8DActivity/"/>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;日常开发中经常会遇到横竖屏切换的问题，一般的做法是让其强制横屏或强制竖屏<br><br><a id="more"></a></p><ul><li>例如 : 强制竖屏<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">            android:name=&quot;.MainActivity&quot;</span><br><span class="line">            android:screenOrientation=&quot;portrait&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;我们知道当横竖屏切换时，会重新执行一遍生命周期的方法，所以导致了每当横竖屏切换的时候当前页面被销毁，那有没有在既可以横竖屏切换又不销毁当前Activity的方法呢？答案是肯定的，在网上找了下，并亲测可行的方法，很简单如下 :<br></p><ul><li>同样是在Manifest.xml中在对应的Activity中添加 <code>android:configChanges=&quot;orientation|keyboardHidden&quot;</code>属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">            android:name=&quot;.MainActivity&quot;</span><br><span class="line">            android:configChanges=&quot;orientation|keyboardHidden /&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Android </tag>
            
            <tag> 基础 </tag>
            
            <tag> 横竖屏切换 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WebView小结</title>
      <link href="/2018/07/13/WebView%E5%B0%8F%E7%BB%93/"/>
      <content type="html"><![CDATA[<blockquote><p>Android日常开发中一些业务经常是嵌套Web端页面来实现，就是我们日常用到的WebView,WebView加载前端开发人员写好的页面的URL。下面是工作过程中遇到过的一些问题以及解决办法。</p></blockquote><a id="more"></a><h1 id="WebView小结"><a href="#WebView小结" class="headerlink" title="WebView小结"></a>WebView小结</h1><h2 id="Android5-0以后的手机点击Web页面无法拍照或选择图片？"><a href="#Android5-0以后的手机点击Web页面无法拍照或选择图片？" class="headerlink" title="Android5.0以后的手机点击Web页面无法拍照或选择图片？"></a>Android5.0以后的手机点击Web页面无法拍照或选择图片？</h2><ul><li><p>针对Android版本号，重写onShowFileChooser方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">webview.setWebChromeClient(new WebChromeClient() &#123;</span><br><span class="line"></span><br><span class="line">           // For Android &lt; 3.0</span><br><span class="line">           public void openFileChooser(ValueCallback&lt;Uri&gt; valueCallback) &#123;</span><br><span class="line">               uploadMessage = valueCallback;</span><br><span class="line">               openImageChooserActivity();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // For Android  &gt;= 3.0</span><br><span class="line">           public void openFileChooser(ValueCallback valueCallback, String acceptType) &#123;</span><br><span class="line">               uploadMessage = valueCallback;</span><br><span class="line">               openImageChooserActivity();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //For Android  &gt;= 4.1</span><br><span class="line">           @Override</span><br><span class="line">           public void openFileChooser(ValueCallback&lt;Uri&gt; valueCallback, String acceptType, </span><br><span class="line">           String capture) &#123;</span><br><span class="line">               uploadMessage = valueCallback;</span><br><span class="line">               openImageChooserActivity();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // For Android &gt;= 5.0</span><br><span class="line">           @Override</span><br><span class="line">           public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt;    filePathCallback, WebChromeClient.FileChooserParams fileChooserParams) &#123;</span><br><span class="line">               uploadMessageAboveL = filePathCallback;</span><br><span class="line">               openImageChooserActivity();</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></li><li><p>openImageChooserActivity方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void openImageChooserActivity() &#123;</span><br><span class="line">    Intent i = new Intent(Intent.ACTION_GET_CONTENT);</span><br><span class="line">    i.addCategory(Intent.CATEGORY_OPENABLE);</span><br><span class="line">    i.setType(&quot;image/*&quot;);</span><br><span class="line">    startActivityForResult(Intent.createChooser(i, &quot;Image Chooser&quot;), FILE_CHOOSER_RESULT_CODE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>onActivityResult方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">    super.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    if (requestCode == FILE_CHOOSER_RESULT_CODE) &#123;</span><br><span class="line">        if (null == uploadMessage &amp;&amp; null == uploadMessageAboveL) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Uri result = data == null || resultCode != RESULT_OK ? null : data.getData();</span><br><span class="line">        if (uploadMessageAboveL != null) &#123;</span><br><span class="line">            onActivityResultAboveL(requestCode, resultCode, data);</span><br><span class="line">        &#125; else if (uploadMessage != null) &#123;</span><br><span class="line">            uploadMessage.onReceiveValue(result);</span><br><span class="line">            uploadMessage = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>onActivityResultAboveL方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@TargetApi(Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line">private void onActivityResultAboveL(int requestCode, int resultCode, Intent intent) &#123;</span><br><span class="line">    if (requestCode != FILE_CHOOSER_RESULT_CODE || uploadMessageAboveL == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Uri[] results = null;</span><br><span class="line">    if (resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line">        if (intent != null) &#123;</span><br><span class="line">            String dataString = intent.getDataString();</span><br><span class="line">            ClipData clipData = intent.getClipData();</span><br><span class="line">            if (clipData != null) &#123;</span><br><span class="line">                results = new Uri[clipData.getItemCount()];</span><br><span class="line">                for (int i = 0; i &lt; clipData.getItemCount(); i++) &#123;</span><br><span class="line">                    ClipData.Item item = clipData.getItemAt(i);</span><br><span class="line">                    results[i] = item.getUri();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dataString != null) &#123;</span><br><span class="line">                results = new Uri[]&#123;Uri.parse(dataString)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    uploadMessageAboveL.onReceiveValue(results);</span><br><span class="line">    uploadMessageAboveL = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="当前WebView页面的Activity中，点击跳转了多个Web页面，而点击返回，一次返回，而不是一层一层的返回？"><a href="#当前WebView页面的Activity中，点击跳转了多个Web页面，而点击返回，一次返回，而不是一层一层的返回？" class="headerlink" title="当前WebView页面的Activity中，点击跳转了多个Web页面，而点击返回，一次返回，而不是一层一层的返回？"></a>当前WebView页面的Activity中，点击跳转了多个Web页面，而点击返回，一次返回，而不是一层一层的返回？</h2><ul><li>解决办法 webView.goBack()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">public boolean onKeyDown(int keyCode, KeyEvent event) &#123;  </span><br><span class="line">    if(keyCode == KeyEvent.KEYCODE_BACK&amp;&amp;webView.canGoBack())&#123;  </span><br><span class="line">        webView.goBack();//返回上个页面  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return super.onKeyDown(keyCode, event);//退出整个应用程序  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取当前Web页面中的标题"><a href="#获取当前Web页面中的标题" class="headerlink" title="获取当前Web页面中的标题"></a>获取当前Web页面中的标题</h2><ul><li>getTitle()方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WebView mWebView = (WebView) findViewById(R.id.mwebview);</span><br><span class="line">   mWebView.setWebViewClient(new WebViewClient() &#123; </span><br><span class="line">       @Override </span><br><span class="line">       public void onPageFinished(WebView view, String url) &#123;</span><br><span class="line">           //tvTitle为原生标题栏的标题控件</span><br><span class="line">           tvTitle.setTitle(view.getTitle());</span><br><span class="line">       &#125; </span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="视频无法全屏播放"><a href="#视频无法全屏播放" class="headerlink" title="视频无法全屏播放"></a>视频无法全屏播放</h2><ul><li>在Manifest清单文件中，对应的Activity中添加</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:configChanges=&quot;orientation|screenSize|keyboardHidden&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Android </tag>
            
            <tag> 基础 </tag>
            
            <tag> WebView相关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记一次Android8.0安装更新遇到的坑</title>
      <link href="/2018/07/02/%E8%AE%B0%E4%B8%80%E6%AC%A1Android8-0%E5%AE%89%E8%A3%85%E6%9B%B4%E6%96%B0%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;公司的项目最近上线了一个活动，为提高参与度，需要推送到旧版本用户上提示更新。于是在测试服务器上先例常测试，却发现有的手机可以正常下载并跳转安装apk页面安装，有的手机却不行，下载成功后，一闪而过，也没有log报错日志，奇怪了，这部分更新的代码没有更新过啊？什么原因呢？<br></p><a id="more"></a><p>&nbsp;&nbsp;经分析，发现都是Android8.0的机型出了问题，会不会是Android8.0的某些权限问题呢？于是在网上搜索，发现了许多和我一样的问题，原来是Android8.0以后移除了“允许位置来源”的开关，需要在每次安装的时候手动授予安装权限，解决方法是在Manifest中添加一句权限:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;经测试，OK !<br></p><p>&nbsp;&nbsp;后记<br><br>&nbsp;&nbsp;以前也在Android7.0的手机出现过类似的问题，解决android7.0以上版本安装不成功的方法如下 :<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(filePath);</span><br><span class="line">Uri uri = Uri.fromFile(file);</span><br><span class="line">Intent intent = new Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">//判断是否是Android7.0以及更高的版本</span><br><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">FileProvider7.setIntentDataAndType(context, intent, &quot;application/vnd.android.package-archive&quot;, file, true);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">intent.setDataAndType(uri, &quot;application/vnd.android.package-archive&quot;);</span><br><span class="line">&#125;</span><br><span class="line">context.startActivity(intent);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 基础 </tag>
            
            <tag> Android8.0适配 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>EventBus使用笔记</title>
      <link href="/2018/06/25/EventBus%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <content type="html"><![CDATA[<h1 id="关于EventBus"><a href="#关于EventBus" class="headerlink" title="关于EventBus"></a>关于EventBus</h1><ul><li>EventBus是一款针对Android优化发布/订阅事件的总线，通俗的来说就是各个activity之间或activity与fragment之间消息的传递，主要功能替换了Intent,Handler,Brodcast在activity，service,线程之间传递消息，优点是在某些复杂情况下的数据传递，并且开销小，代码更优雅，以及将发送者和接收者解耦。</li></ul><a id="more"></a><ul><li>github地址：<ul><li><code>https://github.com/greenrobot/EventBus</code></li></ul></li></ul><h1 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h1><h2 id="一，添加依赖"><a href="#一，添加依赖" class="headerlink" title="一，添加依赖"></a>一，添加依赖</h2><ul><li>在app的build.gradle中添加依赖<ul><li><code>compile &#39;org.greenrobot:eventbus:3.0.0&#39;</code></li></ul></li></ul><h2 id="二，自定义一个类，可以是空类"><a href="#二，自定义一个类，可以是空类" class="headerlink" title="二，自定义一个类，可以是空类"></a>二，自定义一个类，可以是空类</h2><ul><li>例如：发送一个String类型的消息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class EventMsg &#123;</span><br><span class="line"></span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    public EventMsg(String msg) &#123;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMsg() &#123;</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三，在接收消息页面注册与注销"><a href="#三，在接收消息页面注册与注销" class="headerlink" title="三，在接收消息页面注册与注销"></a>三，在接收消息页面注册与注销</h2><ul><li><p>在onCreate方法中注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(this);</span><br></pre></td></tr></table></figure></li><li><p>在onDestroy方法中注销</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().unregister(this);</span><br></pre></td></tr></table></figure></li></ul><h2 id="四，发送消息"><a href="#四，发送消息" class="headerlink" title="四，发送消息"></a>四，发送消息</h2><ul><li>在发送消息的Activity中发送消息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(new EventMsg(&quot;This is a message!&quot;));</span><br></pre></td></tr></table></figure><h2 id="五，接收消息"><a href="#五，接收消息" class="headerlink" title="五，接收消息"></a>五，接收消息</h2><ul><li>在接收消息的Activity中创建一个接收消息的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe</span><br><span class="line">public void getEventMsg(EventMsg msg)&#123;</span><br><span class="line">    String msg1 = msg.getMsg();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Android </tag>
            
            <tag> 基础 </tag>
            
            <tag> EventBus </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ButterKnife依赖注入框架配置</title>
      <link href="/2018/06/25/ButterKnife%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6%E9%85%8D%E7%BD%AE/"/>
      <content type="html"><![CDATA[<h1 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h1><ol><li>在项目的build.gradle的dependencies中添加<code>classpath&#39;com.neenbedankt.gradle.plugins:android-apt:1.8&#39;</code></li><li>在app的build.gradle文件中的顶部添加<code>apply plugin:&#39;android-apt&#39;</code>，dependencies中配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.jakewharton:butterknife:8.0.1&apos;</span><br><span class="line">apt &apos;com.jakewharton:butterknife-compiler:8.0.1&apos;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><blockquote><p>说明：由于Android Studio升级到3.0以后，原有配置ButterKnife会报错，以下是新的配置ButterKnife步骤</p></blockquote><ol><li>在app的build.gradle中的dependencies中配置如下依赖即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.jakewharton:butterknife:8.0.1&apos;</span><br><span class="line">annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.0.1&apos;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Android </tag>
            
            <tag> 基础 </tag>
            
            <tag> ButterKnife </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ARouter使用笔记</title>
      <link href="/2018/06/25/ARouter%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <content type="html"><![CDATA[<h1 id="ARouter使用笔记"><a href="#ARouter使用笔记" class="headerlink" title="ARouter使用笔记"></a>ARouter使用笔记</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>ARouter是阿里在github上面的一个开源项目，github地址为：<a href="https://github.com/alibaba/ARouter" target="_blank" rel="noopener">https://github.com/alibaba/ARouter</a>。官方给出的解释是<code>Android平台中对页面、服务提供路由功能的中间件，我的目标是 —— 简单且够用。</code></li></ul><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>ARouter详细使用方式官方已经给出，这里只是摘取部分，供日常开放使用。</li></ul><a id="more"></a><h2 id="使用前配置"><a href="#使用前配置" class="headerlink" title="使用前配置"></a>使用前配置</h2><ul><li><p>在app的build.gradle中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">...</span><br><span class="line">javaCompileOptions &#123;</span><br><span class="line">    annotationProcessorOptions &#123;</span><br><span class="line">arguments = [ moduleName : project.getName() ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.alibaba:arouter-api:1.2.1.1&apos;</span><br><span class="line">    annotationProcessor &apos;com.alibaba:arouter-compiler:1.1.2.1&apos;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Application类中初始化SDK</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (isDebug()) &#123; </span><br><span class="line">    ARouter.openLog();</span><br><span class="line">    ARouter.openDebug();</span><br><span class="line">&#125;</span><br><span class="line">ARouter.init(mApplication);</span><br></pre></td></tr></table></figure></li><li><p>在需要跳转的目标Activity中，添加注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在支持路由的页面上添加注解(必选)</span><br><span class="line">// 这里的路径需要注意的是至少需要有两级，/xx/xx</span><br><span class="line">@Route(path = &quot;/test/activity&quot;)</span><br><span class="line">public class YourActivity extend Activity &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发起路由跳转操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1. 应用内简单的跳转(通过URL跳转在&apos;进阶用法&apos;中)</span><br><span class="line">ARouter.getInstance().build(&quot;/test/activity&quot;).navigation();</span><br><span class="line"></span><br><span class="line">// 2. 跳转并携带参数</span><br><span class="line">ARouter.getInstance().build(&quot;/test/1&quot;)</span><br><span class="line">.withLong(&quot;key1&quot;, 666L)</span><br><span class="line">.withString(&quot;key3&quot;, &quot;888&quot;)</span><br><span class="line">.withObject(&quot;key4&quot;, new Test(&quot;Jack&quot;, &quot;Rose&quot;))</span><br><span class="line">.navigation();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Android </tag>
            
            <tag> 基础 </tag>
            
            <tag> ARouter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>范式说明（转载）</title>
      <link href="/2018/06/23/%E8%8C%83%E5%BC%8F%E8%AF%B4%E6%98%8E%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
      <content type="html"><![CDATA[<blockquote><p>原文转载自<a href="https://blog.csdn.net/htq__/article/details/50926836" target="_blank" rel="noopener">https://blog.csdn.net/htq__/article/details/50926836</a></p></blockquote><a id="more"></a><h1 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h1><p>&nbsp;&nbsp;无重复的列<br></p><p>&nbsp;&nbsp;所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能同时有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。<br></p><p>&nbsp;&nbsp;在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。在当前的任何关系数据库管理系统（DBMS）中，不可能做出不符合第一范式的数据库，因为这些DBMS不允许你把数据库表的一列再分成二列或多列。因此，你想在现有的DBMS中设计出不符合第一范式的数据库都是不可能的。<br></p><p>&nbsp;&nbsp;举个栗子：<br></p><p>&nbsp;&nbsp;一张学生表Student(stuNo,stuName,age,age,sex)是不符合第一范式的，因为有重复列age属性。去除重复列age以后的Student(stuNo,stuName,age,sex)是符合第一范式的。<br></p><h1 id="第二范式-3NF"><a href="#第二范式-3NF" class="headerlink" title="第二范式(3NF)"></a>第二范式(3NF)</h1><p>&nbsp;&nbsp;属性完全依赖于主键（消除部分子函数依赖）<br></p><p>&nbsp;&nbsp;第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是唯一的，因此每个员工可以被唯一区分。这个唯一属性列被称为主关键字或主键、主码。<br></p><p>&nbsp;&nbsp;第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是属性完全依赖于主键。<br></p><p>&nbsp;&nbsp;这里说的主关键字可能不只有一个，有些情况下是存在联合主键的，就是主键有多个属性。<br></p><p>&nbsp;&nbsp;举个栗子：<br></p><p>&nbsp;&nbsp;以学生选课为例，每个学生都可以选课，并且有这一门课程的成绩，那么如果将这些信息都放在一张表StuGrade(stuNo,stuName,age,sex,courseNo,courseName,credit,score)。<br></p><p><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/%E8%8C%83%E5%BC%8F/fs1.png" alt="第二范式举例"></div></p><p>&nbsp;&nbsp;如果不仔细看，我们会以为这张表的主键是stuNo，但是当我们看到最后一个score属性以后，在想想如果没有课程信息，那么哪里有学生成绩信息呢。所以这张表的主键是一个联合主键(stuNo,corseNo)，这个联合属性能够唯一确定score属性。那么再看其他信息，比如stuName只需要stuNo就能够唯一确定，courseName只需要courseNo就能够唯一确定，因此这样就存在了部分依赖，不符合第二范式。如果要让学生课程成绩信息满足第二范式，那么久需要将这张表拆分成多张表，一张学生表Studnet(stuNo,stuName,age,sex)，一张课程表Course(courseNo,courseName,credit)，还有最后一张学生课程成绩表StuGrade(stuNo,courseNo,score)。<br></p><p><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/%E8%8C%83%E5%BC%8F/fs2.png" alt="第二范式举例2"></div></p><p>&nbsp;&nbsp;这样就符合第二范式了。<br></p><h1 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF)"></a>第三范式(3NF)</h1><p>&nbsp;&nbsp;属性不依赖于其它非主属性（消除传递依赖）<br></p><p>&nbsp;&nbsp;满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。<br></p><p>&nbsp;&nbsp;举个栗子：<br></p><p>&nbsp;&nbsp;每一个员工都有一个所属部门，假如有一个员工信息表Employee(emp_id,emp_name,emp_age,dept_id,dept_name,dept_info)。<br></p><p><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/%E8%8C%83%E5%BC%8F/fs3.png" alt="第三范式举例"></div></p><p>&nbsp;&nbsp;这张员工信息表的主键是emp_id，因为这个属性能够唯一确定其他所有属性，比如知道员工编号emp_id以后，肯定能够知道员工姓名，所属部门编号，部门名称和部门介绍。所以这里dept_id不是主属性，而是非主属性。但是，我们又可以发现dept_name,dept_info这两个属性也可以由dept_id这个非主属性决定，即dept_name依赖dept_id，而dept_id依赖emp_id，这样就存在了传递依赖。而且我们可以看出传递依赖的一个明显缺点就是数据冗余非常严重。<br></p><p>&nbsp;&nbsp;那么如何解决传递依赖问题，其实非常简单，我们只需要将dept_name,dept_info这连个属性删除就可以了，即Employee(emp_id,emp_name,emp_age,dept_id)，然后再创建一个部门表Dept(dept_id,dept_name,dept_info)。<br></p><p><div align="center"><img src="https://raw.githubusercontent.com/dondurma/MygithubPic/master/%E8%8C%83%E5%BC%8F/fs4.png" alt="第三范式举例2"></div></p><p>&nbsp;&nbsp;这样如果要搜索某一个员工的部门信息dept_info，可以通过数据库连接来实现，查询语句如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_id,e.emp_name,d.dept_name from Employee e,Dept d where e.dept_id=d.dept_id</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;注意点：</p><ol><li>数据库连接会带来一部分的性能损失</li><li>并不是数据库范式越高越好</li><li>有时会在数据冗余与范式之间做出权衡，在实际的数据库开发过程中，往往会允许一部分的数据冗余来减少数据库连接。</li></ol>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 范式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>往事如烟</title>
      <link href="/2018/06/21/%E5%BE%80%E4%BA%8B%E5%A6%82%E7%83%9F/"/>
      <content type="html"><![CDATA[<blockquote><p>缘由:无意间打开了我的loft博客，竟然发现了一篇以前的博客，时间是2011年的高考前后，内容是摘取当时的数篇日记，文章有浓浓的应试作文风格…</p></blockquote><a id="more"></a><p>&nbsp;&nbsp;岁月伴随着迷茫来到了二十岁来到了一个新的驿站，伴随又一个彷徨又相思又迷茫的暑假的结束，仰望星空不仅为时光匆匆而哀叹，过去的事，过去的人，“物是人非事事休，欲与泪先流”。<br></p><ul><li>2011年6月4日 星期六   阴 高考倒计时2天</li></ul><p>&nbsp;&nbsp;时光匆匆，坐在书桌前，看着手中的毕业相片感慨万千，在高考压力之余不禁又想到要毕业了。 三年高中时光，弹指一挥间，匆匆流逝。词人说：“多情自古伤离别”。<br><br>&nbsp;&nbsp;三年中，只是平凡众人中的一个，不是老师家长们眼中的佼佼者。不突出，不平庸，不善表达。下一次写周记的时候，已经是人生的转折点了，那将是面临另一个人生，珍惜现在，沉着应对，把握每分每秒。明天也是在学校的最后一天了，回忆起往昔，有快乐，有痛苦，有成功，有挫折，有风雨，有彩虹，生活像一杯酒，品他，才能体会人生苦辣，是一扇窗，打开他，才能自由的飞翔。“青春不是年华而是心境，青春不是桃面、丹唇、柔膝而是深沉的意志，恢弘的想象，炙热的情感…青春气贯长虹。勇气压倒怯弱，进取压倒苟安”喜欢这句名言，就像每个人年轻过，年轻给人以锐气，给人以蓬勃。当年届花甲之时，也许会在某些时候，或在蒙蒙的细雨中，或在寂静的夜里，暮然回想起，曾在自己的岁月记忆之中，有过这样一段时光，或许有冲动无畏、鲁莽、无知、轻率。生命之光在这一刻涌动，成长岁月中，美好的回忆在这一刻封存，伤感情结交织着人生的挑战，即将走向人生另一条更广阔的路。前方的路会怎样，迷茫又充满希望，遥远又尽在咫尺，只因为“凡是遥远的地方，对我们都有一种诱惑，不是诱惑于美丽就是诱惑于传说”我们都在寻找，哪怕这远方的风景并不尽如人意，哪怕那是一片子虚乌有的桃花源。天下没有不散的宴席，就让这段时光留到回忆的岁月吧！“月下飞仙境湖渡，踏踏波声似白鹭。欲把愁心与明月，谁人解的浔阳处。”我欲乘风归去转朱阁，照无眠，高考似战场，“醉卧沙场君莫笑，古来征战几人回”面对后天的高考，沉着应对，在考场中发挥自己，书写自己！<br></p><ul><li>2011年6月5日  星期天  阴    倒计时1天</li></ul><p>&nbsp;&nbsp;今天是高考前的最后一天，同学们陆陆续续回到教室去搬自己的课桌椅回去，昨天,自己已经将课本都带回家了，来到了教室，人走的走，桌子搬的搬，已不再是像往日的那个坐满人的教室了，不再显得拥挤，地上随处的纸屑，只有墙上的值日表、课程表，墙上依稀可见的字迹是被坐在靠墙壁的同学无聊之时留下的，头上的电风扇此时停止了转动，仿佛为陪伴过我们那个刚刚过去的炎热又压抑的六月而此时此刻得到满意的休息，为下一个六月作好着准备。从学校到家十几分钟的路途，可是从学校回到了家里，课座椅搬回家的那一刻，内心的思绪就整个的变化了，才真实的感觉到了毕业，内心就涌现出一个个念头，我想，昔日的三年级八班不再有我了，那个教室里再也没有属于我的一角了，思绪随着记忆展开…这里曾经是学习的地方，这里曾经让我欢喜，让我忧，而从现在开始，这里的所有属于我的将变得一无所有了，随着时间的流逝，不久后，连自己也会忘得干干净净吧，为了不让岁月的尘土掩盖了美好的回忆，以将他记录封存下来，也许多少年后，或亦将有感于斯文吧！人生路漫漫，美好的中学时光一去不返了，没有谁值得思恋，但就是内心不免些许感伤吧，哪怕只为昔日校园洒过汗水的操场、昔日食堂坐过的椅子，昔日校园走过的小道。物是人非事事休，欲与泪先流，时光太匆匆，过去的日子像风抖落的枫叶，落叶无情而人有情，落叶萧萧，人生如梦。轻轻的我走了，正如我轻轻的来，挥一挥衣袖，不带走一片云彩。此情可待成追忆，只是当时已惘然！路在脚下，背起三年的行囊，去接受人生的洗礼吧，问君能有几多愁，恰似一江春水向东流。晓来谁染霜林醉，总是离人泪，此去今年，前方路途迷茫，雾太浓…<br></p><ul><li>2011年6月11日    星期六   天气 阴</li></ul><p>&nbsp;&nbsp;转眼间，高考已经过去九天了，在这漫长的九天里，每天晚上都睡不着，内心有种说不出的感觉，怅然若失，不知道为什么这么痛苦，晚上就算睡着了也在做梦，做的全部都是上学的梦，有初中，有高中，其中有一个梦场地是初中，而人物却是高中的，毕竟这两个学校自己一共呆过七年吧，翻翻初中写过的日记，从零七年到如今，让自己有对年少时光的幼稚的想法及思想说不出的感觉，是痛恨？是想笑？是回忆？还是感伤？而现在，这九天时间里，可以说是虚度青春，每天晚上睡不着，而白天十一点起来，有时下午还要睡，其他时间就是吃饭了，总之、吃、睡，加上看电视就是我生活的全部，有时夜晚睡不着之时，又不想这么浑浑噩噩的过，而想有所作为，有所计划，但是到了第二天又是老样子了，每天都不出门，呆在家，在家呆着实在无聊就决定出去走走，记得这天下着雨，自己勇敢的出了家门，在县里书店，超市，以及这么多天没来过的学校，徘徊在院墙外，转了一圈回来。走在街上自己提心吊胆的貌似怕见到同学，因为自己也不知道说什么好。正因为这样，自己才会选择雨天出来，因为人少的缘故。回到家，自己又到屋前面的网吧上网，这个离家几十米之遥的网吧，以前因为上学没来过，但高考过后，爸妈就同意我来了，生平第一次来网吧，第一次上网，连开机还是网管鄙视而又不耐烦教的（开玩笑）。回到现在，只是希望高考分数早点出来，六月二十五，既激动又害怕，希望有一个相对理想点的分数吧。每天这样的日子，没有目标，没有计划，惰性占据着全身心，内心一股无名的惆怅和失落，像突然离开学校的失落折磨着内心，自己究竟思恋着什么呢？虽然曾经的上学时光并不快乐，并不时常美好，更多的是苦楚和压力，剪不断、理还乱、是离愁，别是一番滋味在心头！久久难眠，醒来又重复着梦中的思恋苦楚，反反复复，无休无止，衣带渐宽终不悔，为伊消得人憔悴！ <br></p><ul><li>2011年6月30日   星期四       晴</li></ul><p>&nbsp;&nbsp;今天中午，妈妈在超市上班，恰逢里面的水果打折，就称了水果叫我带回去，下午烈日炎炎的太阳，烤的街上的行人纷纷避之而不及，路过二中，看到高一、二的都还在上课，不禁感慨回忆，进而想到我的高中呢？转瞬即逝，许多东西往往是过去后，才知道后悔，流逝后才知道珍惜，以前，唉！只能说没有好好的珍惜，“沉舟侧畔千帆过，病树前头万木春”过去就让过去吧，一届一届的走过，新的高三代替旧的高三，并且总是在不断的重复着，时间总是在流逝的，不会因为个人而停止匆匆的脚步，学校是每个我们的人生中留下过的一个瞬间短促的驿站，留下过最美好回忆的驿站。那么何处是停泊的港湾？时间啊！你为什么流逝的如此之快，子在川上日；不舍昼夜，天若有情天亦老，流星划过的一瞬，历史长河，留给我们的只是那“古今多少事，都付笑谈中”对月当空，洒脱如“对酒当歌，人生几何，思念如“但愿人长久，千里共婵娟”的思念， 惆怅如“无言独上西楼，月如钩”。古往今来，高挂天空的月亮是唯一没有变的，我们所看到的月亮是不是某时某刻古人他们所看到的呢？冥冥之中，是否我们与他们双目对视呢？“江畔何人初见月？江月何年初照人？人生代代无穷已，江月年年只相似。不知江月待何人，但见长江送流水。白云一片去悠悠，春枫浦上不胜愁。”当处在过程之中，只想着结果，当结果来到时，却发现结果并不是那么的迷人，于是倍加怀恋曾经的过程，曾经的岁月！<br></p><ul><li>2011年8月1日    7月31日        阴</li></ul><p>&nbsp;&nbsp;夜未眠，看看以前写过的零碎回忆，当翻开12月29日这篇周记的时候，往事历历在目。那个寒冷的冬天，路灯下的操场上，我仿佛看到了一个在寒风中，围绕着操场一圈又一圈跑过的倔强的的身影。昏黄的路灯照在跑道上的情景，看到了初中部教学楼顶上在那个灯光的映忖下，一阵阵寒风吹过枫树沙沙作响的声音，在那个人的耳际徘徊，至今留在那个人的海里，久久不能忘怀，那个寒冬天未亮，霜未落，只有与影子相伴的操场上，那种过往一排排的枫树的一瞬，那样的时间里光景里，给他留下了最为宝贵的思绪。<br><br>&nbsp;&nbsp;寂寞伴随着他走过那段青春的岁月，他只能惆怅，无能为力，抓不住时间的尾巴，谁道人生无再少，门前流水尚能西。流水无情，而人有情，回忆叠着感伤并着时间的洗涤随风而散，此去今年，往事如烟……</p>]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 回忆 </tag>
            
            <tag> 高中 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
