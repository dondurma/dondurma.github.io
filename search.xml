<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Android横竖屏切换时不销毁当前Activity</title>
      <link href="/2018/07/18/Android%E6%A8%AA%E7%AB%96%E5%B1%8F%E5%88%87%E6%8D%A2%E6%97%B6%E4%B8%8D%E9%94%80%E6%AF%81%E5%BD%93%E5%89%8DActivity/"/>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;日常开发中经常会遇到横竖屏切换的问题，一般的做法是让其强制横屏或强制竖屏<br><br><a id="more"></a></p><ul><li>例如 : 强制竖屏<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">            android:name=&quot;.MainActivity&quot;</span><br><span class="line">            android:screenOrientation=&quot;portrait&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;我们知道当横竖屏切换时，会重新执行一遍生命周期的方法，所以导致了每当横竖屏切换的时候当前页面被销毁，那有没有在既可以横竖屏切换又不销毁当前Activity的方法呢？答案是肯定的，在网上找了下，并亲测可行的方法，很简单如下 :<br></p><ul><li>同样是在Manifest.xml中在对应的Activity中添加 <code>android:configChanges=&quot;orientation|keyboardHidden&quot;</code>属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">            android:name=&quot;.MainActivity&quot;</span><br><span class="line">            android:configChanges=&quot;orientation|keyboardHidden /&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Android </tag>
            
            <tag> 基础 </tag>
            
            <tag> 横竖屏切换 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WebView小结</title>
      <link href="/2018/07/13/WebView%E5%B0%8F%E7%BB%93/"/>
      <content type="html"><![CDATA[<blockquote><p>Android日常开发中一些业务经常是嵌套Web端页面来实现，就是我们日常用到的WebView,WebView加载前端开发人员写好的页面的URL。下面是工作过程中遇到过的一些问题以及解决办法。</p></blockquote><a id="more"></a><h1 id="Android5-0以后的手机点击Web页面无法拍照或选择图片？"><a href="#Android5-0以后的手机点击Web页面无法拍照或选择图片？" class="headerlink" title="Android5.0以后的手机点击Web页面无法拍照或选择图片？"></a>Android5.0以后的手机点击Web页面无法拍照或选择图片？</h1><ul><li><p>针对Android版本号，重写onShowFileChooser方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">webview.setWebChromeClient(new WebChromeClient() &#123;</span><br><span class="line"></span><br><span class="line">           // For Android &lt; 3.0</span><br><span class="line">           public void openFileChooser(ValueCallback&lt;Uri&gt; valueCallback) &#123;</span><br><span class="line">               uploadMessage = valueCallback;</span><br><span class="line">               openImageChooserActivity();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // For Android  &gt;= 3.0</span><br><span class="line">           public void openFileChooser(ValueCallback valueCallback, String acceptType) &#123;</span><br><span class="line">               uploadMessage = valueCallback;</span><br><span class="line">               openImageChooserActivity();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //For Android  &gt;= 4.1</span><br><span class="line">           @Override</span><br><span class="line">           public void openFileChooser(ValueCallback&lt;Uri&gt; valueCallback, String acceptType, </span><br><span class="line">           String capture) &#123;</span><br><span class="line">               uploadMessage = valueCallback;</span><br><span class="line">               openImageChooserActivity();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // For Android &gt;= 5.0</span><br><span class="line">           @Override</span><br><span class="line">           public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt;    filePathCallback, WebChromeClient.FileChooserParams fileChooserParams) &#123;</span><br><span class="line">               uploadMessageAboveL = filePathCallback;</span><br><span class="line">               openImageChooserActivity();</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></li><li><p>openImageChooserActivity方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void openImageChooserActivity() &#123;</span><br><span class="line">    Intent i = new Intent(Intent.ACTION_GET_CONTENT);</span><br><span class="line">    i.addCategory(Intent.CATEGORY_OPENABLE);</span><br><span class="line">    i.setType(&quot;image/*&quot;);</span><br><span class="line">    startActivityForResult(Intent.createChooser(i, &quot;Image Chooser&quot;), FILE_CHOOSER_RESULT_CODE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>onActivityResult方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">    super.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    if (requestCode == FILE_CHOOSER_RESULT_CODE) &#123;</span><br><span class="line">        if (null == uploadMessage &amp;&amp; null == uploadMessageAboveL) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Uri result = data == null || resultCode != RESULT_OK ? null : data.getData();</span><br><span class="line">        if (uploadMessageAboveL != null) &#123;</span><br><span class="line">            onActivityResultAboveL(requestCode, resultCode, data);</span><br><span class="line">        &#125; else if (uploadMessage != null) &#123;</span><br><span class="line">            uploadMessage.onReceiveValue(result);</span><br><span class="line">            uploadMessage = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>onActivityResultAboveL方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@TargetApi(Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line">private void onActivityResultAboveL(int requestCode, int resultCode, Intent intent) &#123;</span><br><span class="line">    if (requestCode != FILE_CHOOSER_RESULT_CODE || uploadMessageAboveL == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Uri[] results = null;</span><br><span class="line">    if (resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line">        if (intent != null) &#123;</span><br><span class="line">            String dataString = intent.getDataString();</span><br><span class="line">            ClipData clipData = intent.getClipData();</span><br><span class="line">            if (clipData != null) &#123;</span><br><span class="line">                results = new Uri[clipData.getItemCount()];</span><br><span class="line">                for (int i = 0; i &lt; clipData.getItemCount(); i++) &#123;</span><br><span class="line">                    ClipData.Item item = clipData.getItemAt(i);</span><br><span class="line">                    results[i] = item.getUri();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dataString != null) &#123;</span><br><span class="line">                results = new Uri[]&#123;Uri.parse(dataString)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    uploadMessageAboveL.onReceiveValue(results);</span><br><span class="line">    uploadMessageAboveL = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="当前WebView页面的Activity中，点击跳转了多个Web页面，而点击返回，一次返回，而不是一层一层的返回？"><a href="#当前WebView页面的Activity中，点击跳转了多个Web页面，而点击返回，一次返回，而不是一层一层的返回？" class="headerlink" title="当前WebView页面的Activity中，点击跳转了多个Web页面，而点击返回，一次返回，而不是一层一层的返回？"></a>当前WebView页面的Activity中，点击跳转了多个Web页面，而点击返回，一次返回，而不是一层一层的返回？</h1><ul><li>解决办法 webView.goBack()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">public boolean onKeyDown(int keyCode, KeyEvent event) &#123;  </span><br><span class="line">    if(keyCode == KeyEvent.KEYCODE_BACK&amp;&amp;webView.canGoBack())&#123;  </span><br><span class="line">        webView.goBack();//返回上个页面  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return super.onKeyDown(keyCode, event);//退出整个应用程序  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="获取当前Web页面中的标题"><a href="#获取当前Web页面中的标题" class="headerlink" title="获取当前Web页面中的标题"></a>获取当前Web页面中的标题</h1><ul><li>getTitle()方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WebView mWebView = (WebView) findViewById(R.id.mwebview);</span><br><span class="line">   mWebView.setWebViewClient(new WebViewClient() &#123; </span><br><span class="line">       @Override </span><br><span class="line">       public void onPageFinished(WebView view, String url) &#123;</span><br><span class="line">           //tvTitle为原生标题栏的标题控件</span><br><span class="line">           tvTitle.setTitle(view.getTitle());</span><br><span class="line">       &#125; </span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Android </tag>
            
            <tag> 基础 </tag>
            
            <tag> WebView相关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记一次Android8.0安装更新遇到的坑</title>
      <link href="/2018/07/02/%E8%AE%B0%E4%B8%80%E6%AC%A1Android8-0%E5%AE%89%E8%A3%85%E6%9B%B4%E6%96%B0%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;公司的项目最近上线了一个活动，为提高参与度，需要推送到旧版本用户上提示更新。于是在测试服务器上先例常测试，却发现有的手机可以正常下载并跳转安装apk页面安装，有的手机却不行，下载成功后，一闪而过，也没有log报错日志，奇怪了，这部分更新的代码没有更新过啊？什么原因呢？<br></p><a id="more"></a><p>&nbsp;&nbsp;经分析，发现都是Android8.0的机型出了问题，会不会是Android8.0的某些权限问题呢？于是在网上搜索，发现了许多和我一样的问题，原来是Android8.0以后移除了“允许位置来源”的开关，需要在每次安装的时候手动授予安装权限，解决方法是在Manifest中添加一句权限:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;经测试，OK !<br></p><p>&nbsp;&nbsp;后记<br><br>&nbsp;&nbsp;以前也在Android7.0的手机出现过类似的问题，解决android7.0以上版本安装不成功的方法如下 :<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(filePath);</span><br><span class="line">                     Uri uri = Uri.fromFile(file);</span><br><span class="line">                     Intent intent = new Intent(Intent.ACTION_VIEW);</span><br><span class="line">                     intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">                     //判断是否是Android7.0以及更高的版本</span><br><span class="line">                     if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">                         intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">                         FileProvider7.setIntentDataAndType(context, intent, &quot;application/vnd.android.package-archive&quot;, file, true);</span><br><span class="line">                     &#125; else &#123;</span><br><span class="line">                         intent.setDataAndType(uri, &quot;application/vnd.android.package-archive&quot;);</span><br><span class="line">                     &#125;</span><br><span class="line">                     context.startActivity(intent);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 基础 </tag>
            
            <tag> Android8.0适配 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>EventBus使用笔记</title>
      <link href="/2018/06/25/EventBus%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <content type="html"><![CDATA[<h1 id="关于EventBus"><a href="#关于EventBus" class="headerlink" title="关于EventBus"></a>关于EventBus</h1><ul><li>EventBus是一款针对Android优化发布/订阅事件的总线，通俗的来说就是各个activity之间或activity与fragment之间消息的传递，主要功能替换了Intent,Handler,Brodcast在activity，service,线程之间传递消息，优点是在某些复杂情况下的数据传递，并且开销小，代码更优雅，以及将发送者和接收者解耦。</li></ul><a id="more"></a><ul><li>github地址：<ul><li><code>https://github.com/greenrobot/EventBus</code></li></ul></li></ul><h1 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h1><h2 id="一，添加依赖"><a href="#一，添加依赖" class="headerlink" title="一，添加依赖"></a>一，添加依赖</h2><ul><li>在app的build.gradle中添加依赖<ul><li><code>compile &#39;org.greenrobot:eventbus:3.0.0&#39;</code></li></ul></li></ul><h2 id="二，自定义一个类，可以是空类"><a href="#二，自定义一个类，可以是空类" class="headerlink" title="二，自定义一个类，可以是空类"></a>二，自定义一个类，可以是空类</h2><ul><li>例如：发送一个String类型的消息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class EventMsg &#123;</span><br><span class="line"></span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    public EventMsg(String msg) &#123;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMsg() &#123;</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三，在接收消息页面注册与注销"><a href="#三，在接收消息页面注册与注销" class="headerlink" title="三，在接收消息页面注册与注销"></a>三，在接收消息页面注册与注销</h2><ul><li><p>在onCreate方法中注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(this);</span><br></pre></td></tr></table></figure></li><li><p>在onDestroy方法中注销</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().unregister(this);</span><br></pre></td></tr></table></figure></li></ul><h2 id="四，发送消息"><a href="#四，发送消息" class="headerlink" title="四，发送消息"></a>四，发送消息</h2><ul><li>在发送消息的Activity中发送消息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(new EventMsg(&quot;This is a message!&quot;));</span><br></pre></td></tr></table></figure></li></ul><h2 id="五，接收消息"><a href="#五，接收消息" class="headerlink" title="五，接收消息"></a>五，接收消息</h2><ul><li>在接收消息的Activity中创建一个接收消息的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe</span><br><span class="line">public void getEventMsg(EventMsg msg)&#123;</span><br><span class="line">    String msg1 = msg.getMsg();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Android </tag>
            
            <tag> 基础 </tag>
            
            <tag> EventBus </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ButterKnife依赖注入框架配置</title>
      <link href="/2018/06/25/ButterKnife%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6%E9%85%8D%E7%BD%AE/"/>
      <content type="html"><![CDATA[<h1 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h1><ol><li>在项目的build.gradle的dependencies中添加<code>classpath&#39;com.neenbedankt.gradle.plugins:android-apt:1.8&#39;</code></li><li>在app的build.gradle文件中的顶部添加<code>apply plugin:&#39;android-apt&#39;</code>，dependencies中配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.jakewharton:butterknife:8.0.1&apos;</span><br><span class="line">apt &apos;com.jakewharton:butterknife-compiler:8.0.1&apos;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><blockquote><p>说明：由于Android Studio升级到3.0以后，原有配置ButterKnife会报错，以下是新的配置ButterKnife步骤</p></blockquote><ol><li>在app的build.gradle中的dependencies中配置如下依赖即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.jakewharton:butterknife:8.0.1&apos;</span><br><span class="line">annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.0.1&apos;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Android </tag>
            
            <tag> 基础 </tag>
            
            <tag> ButterKnife </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ARouter使用笔记</title>
      <link href="/2018/06/25/ARouter%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <content type="html"><![CDATA[<h1 id="ARouter使用笔记"><a href="#ARouter使用笔记" class="headerlink" title="ARouter使用笔记"></a>ARouter使用笔记</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>ARouter是阿里在github上面的一个开源项目，github地址为：<a href="https://github.com/alibaba/ARouter" target="_blank" rel="noopener">https://github.com/alibaba/ARouter</a>。官方给出的解释是<code>Android平台中对页面、服务提供路由功能的中间件，我的目标是 —— 简单且够用。</code></li></ul><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>ARouter详细使用方式官方已经给出，这里只是摘取部分，共日常开放使用。</li></ul><a id="more"></a><h2 id="使用前配置"><a href="#使用前配置" class="headerlink" title="使用前配置"></a>使用前配置</h2><ul><li><p>在app的build.gradle中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">...</span><br><span class="line">javaCompileOptions &#123;</span><br><span class="line">    annotationProcessorOptions &#123;</span><br><span class="line">arguments = [ moduleName : project.getName() ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.alibaba:arouter-api:1.2.1.1&apos;</span><br><span class="line">    annotationProcessor &apos;com.alibaba:arouter-compiler:1.1.2.1&apos;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Application类中初始化SDK</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (isDebug()) &#123; </span><br><span class="line">    ARouter.openLog();</span><br><span class="line">    ARouter.openDebug();</span><br><span class="line">&#125;</span><br><span class="line">ARouter.init(mApplication);</span><br></pre></td></tr></table></figure></li><li><p>在需要跳转的目标Activity中，添加注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在支持路由的页面上添加注解(必选)</span><br><span class="line">// 这里的路径需要注意的是至少需要有两级，/xx/xx</span><br><span class="line">@Route(path = &quot;/test/activity&quot;)</span><br><span class="line">public class YourActivity extend Activity &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发起路由跳转操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1. 应用内简单的跳转(通过URL跳转在&apos;进阶用法&apos;中)</span><br><span class="line">ARouter.getInstance().build(&quot;/test/activity&quot;).navigation();</span><br><span class="line"></span><br><span class="line">// 2. 跳转并携带参数</span><br><span class="line">ARouter.getInstance().build(&quot;/test/1&quot;)</span><br><span class="line">.withLong(&quot;key1&quot;, 666L)</span><br><span class="line">.withString(&quot;key3&quot;, &quot;888&quot;)</span><br><span class="line">.withObject(&quot;key4&quot;, new Test(&quot;Jack&quot;, &quot;Rose&quot;))</span><br><span class="line">.navigation();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Android </tag>
            
            <tag> 基础 </tag>
            
            <tag> ARouter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>范式说明（转载）</title>
      <link href="/2018/06/23/%E8%8C%83%E5%BC%8F%E8%AF%B4%E6%98%8E%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
      <content type="html"><![CDATA[<blockquote><p>原文转载自<a href="https://blog.csdn.net/htq__/article/details/50926836" target="_blank" rel="noopener">https://blog.csdn.net/htq__/article/details/50926836</a></p></blockquote><a id="more"></a><h1 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h1><p>&nbsp;&nbsp;无重复的列<br></p><p>&nbsp;&nbsp;所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能同时有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。<br></p><p>&nbsp;&nbsp;在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。在当前的任何关系数据库管理系统（DBMS）中，不可能做出不符合第一范式的数据库，因为这些DBMS不允许你把数据库表的一列再分成二列或多列。因此，你想在现有的DBMS中设计出不符合第一范式的数据库都是不可能的。<br></p><p>&nbsp;&nbsp;举个栗子：<br></p><p>&nbsp;&nbsp;一张学生表Student(stuNo,stuName,age,age,sex)是不符合第一范式的，因为有重复列age属性。去除重复列age以后的Student(stuNo,stuName,age,sex)是符合第一范式的。<br></p><h1 id="第二范式-3NF"><a href="#第二范式-3NF" class="headerlink" title="第二范式(3NF)"></a>第二范式(3NF)</h1><p>&nbsp;&nbsp;属性完全依赖于主键（消除部分子函数依赖）<br></p><p>&nbsp;&nbsp;第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是唯一的，因此每个员工可以被唯一区分。这个唯一属性列被称为主关键字或主键、主码。<br></p><p>&nbsp;&nbsp;第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是属性完全依赖于主键。<br></p><p>&nbsp;&nbsp;这里说的主关键字可能不只有一个，有些情况下是存在联合主键的，就是主键有多个属性。<br></p><p>&nbsp;&nbsp;举个栗子：<br></p><p>&nbsp;&nbsp;以学生选课为例，每个学生都可以选课，并且有这一门课程的成绩，那么如果将这些信息都放在一张表StuGrade(stuNo,stuName,age,sex,courseNo,courseName,credit,score)。<br></p><p><img src="http://p9uaajhtk.bkt.clouddn.com/%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%E4%B8%BE%E4%BE%8B.png" alt="第二范式举例"></p><p>&nbsp;&nbsp;如果不仔细看，我们会以为这张表的主键是stuNo，但是当我们看到最后一个score属性以后，在想想如果没有课程信息，那么哪里有学生成绩信息呢。所以这张表的主键是一个联合主键(stuNo,corseNo)，这个联合属性能够唯一确定score属性。那么再看其他信息，比如stuName只需要stuNo就能够唯一确定，courseName只需要courseNo就能够唯一确定，因此这样就存在了部分依赖，不符合第二范式。如果要让学生课程成绩信息满足第二范式，那么久需要将这张表拆分成多张表，一张学生表Studnet(stuNo,stuName,age,sex)，一张课程表Course(courseNo,courseName,credit)，还有最后一张学生课程成绩表StuGrade(stuNo,courseNo,score)。<br></p><p><img src="http://p9uaajhtk.bkt.clouddn.com/%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%E4%B8%BE%E4%BE%8B2.png" alt="第二范式举例2"></p><p>&nbsp;&nbsp;这样就符合第二范式了。<br></p><h1 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF)"></a>第三范式(3NF)</h1><p>&nbsp;&nbsp;属性不依赖于其它非主属性（消除传递依赖）<br></p><p>&nbsp;&nbsp;满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。<br></p><p>&nbsp;&nbsp;举个栗子：<br></p><p>&nbsp;&nbsp;每一个员工都有一个所属部门，假如有一个员工信息表Employee(emp_id,emp_name,emp_age,dept_id,dept_name,dept_info)。<br></p><p><img src="http://p9uaajhtk.bkt.clouddn.com/%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%E4%B8%BE%E4%BE%8B.png" alt="第三范式举例"></p><p>&nbsp;&nbsp;这张员工信息表的主键是emp_id，因为这个属性能够唯一确定其他所有属性，比如知道员工编号emp_id以后，肯定能够知道员工姓名，所属部门编号，部门名称和部门介绍。所以这里dept_id不是主属性，而是非主属性。但是，我们又可以发现dept_name,dept_info这两个属性也可以由dept_id这个非主属性决定，即dept_name依赖dept_id，而dept_id依赖emp_id，这样就存在了传递依赖。而且我们可以看出传递依赖的一个明显缺点就是数据冗余非常严重。<br></p><p>&nbsp;&nbsp;那么如何解决传递依赖问题，其实非常简单，我们只需要将dept_name,dept_info这连个属性删除就可以了，即Employee(emp_id,emp_name,emp_age,dept_id)，然后再创建一个部门表Dept(dept_id,dept_name,dept_info)。<br></p><p><img src="http://p9uaajhtk.bkt.clouddn.com/%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%E4%B8%BE%E4%BE%8B2.png" alt="第三范式举例2"></p><p>&nbsp;&nbsp;这样如果要搜索某一个员工的部门信息dept_info，可以通过数据库连接来实现，查询语句如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_id,e.emp_name,d.dept_name from Employee e,Dept d where e.dept_id=d.dept_id</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;注意点：</p><ol><li>数据库连接会带来一部分的性能损失</li><li>并不是数据库范式越高越好</li><li>有时会在数据冗余与范式之间做出权衡，在实际的数据库开发过程中，往往会允许一部分的数据冗余来减少数据库连接。</li></ol>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 范式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>往事如烟</title>
      <link href="/2018/06/21/%E5%BE%80%E4%BA%8B%E5%A6%82%E7%83%9F/"/>
      <content type="html"><![CDATA[<blockquote><p>缘由:无意间打开了我的loft博客，竟然发现了一篇以前的博客，时间是2011年的高考前后，内容是摘取当时的数篇日记，文章有浓浓的应试作文风格…</p></blockquote><a id="more"></a><p>&nbsp;&nbsp;岁月伴随着迷茫来到了二十岁来到了一个新的驿站，伴随又一个彷徨又相思又迷茫的暑假的结束，仰望星空不仅为时光匆匆而哀叹，过去的事，过去的人，“物是人非事事休，欲与泪先流”。<br></p><ul><li>2011年6月4日 星期六   阴 高考倒计时2天</li></ul><p>&nbsp;&nbsp;时光匆匆，坐在书桌前，看着手中的毕业相片感慨万千，在高考压力之余不禁又想到要毕业了。 三年高中时光，弹指一挥间，匆匆流逝。词人说：“多情自古伤离别”。<br><br>&nbsp;&nbsp;三年中，只是平凡众人中的一个，不是老师家长们眼中的佼佼者。不突出，不平庸，不善表达。下一次写周记的时候，已经是人生的转折点了，那将是面临另一个人生，珍惜现在，沉着应对，把握每分每秒。明天也是在学校的最后一天了，回忆起往昔，有快乐，有痛苦，有成功，有挫折，有风雨，有彩虹，生活像一杯酒，品他，才能体会人生苦辣，是一扇窗，打开他，才能自由的飞翔。“青春不是年华而是心境，青春不是桃面、丹唇、柔膝而是深沉的意志，恢弘的想象，炙热的情感…青春气贯长虹。勇气压倒怯弱，进取压倒苟安”喜欢这句名言，就像每个人年轻过，年轻给人以锐气，给人以蓬勃。当年届花甲之时，也许会在某些时候，或在蒙蒙的细雨中，或在寂静的夜里，暮然回想起，曾在自己的岁月记忆之中，有过这样一段时光，或许有冲动无畏、鲁莽、无知、轻率。生命之光在这一刻涌动，成长岁月中，美好的回忆在这一刻封存，伤感情结交织着人生的挑战，即将走向人生另一条更广阔的路。前方的路会怎样，迷茫又充满希望，遥远又尽在咫尺，只因为“凡是遥远的地方，对我们都有一种诱惑，不是诱惑于美丽就是诱惑于传说”我们都在寻找，哪怕这远方的风景并不尽如人意，哪怕那是一片子虚乌有的桃花源。天下没有不散的宴席，就让这段时光留到回忆的岁月吧！“月下飞仙境湖渡，踏踏波声似白鹭。欲把愁心与明月，谁人解的浔阳处。”我欲乘风归去转朱阁，照无眠，高考似战场，“醉卧沙场君莫笑，古来征战几人回”面对后天的高考，沉着应对，在考场中发挥自己，书写自己！<br></p><ul><li>2011年6月5日  星期天  阴    倒计时1天</li></ul><p>&nbsp;&nbsp;今天是高考前的最后一天，同学们陆陆续续回到教室去搬自己的课桌椅回去，昨天,自己已经将课本都带回家了，来到了教室，人走的走，桌子搬的搬，已不再是像往日的那个坐满人的教室了，不再显得拥挤，地上随处的纸屑，只有墙上的值日表、课程表，墙上依稀可见的字迹是被坐在靠墙壁的同学无聊之时留下的，头上的电风扇此时停止了转动，仿佛为陪伴过我们那个刚刚过去的炎热又压抑的六月而此时此刻得到满意的休息，为下一个六月作好着准备。从学校到家十几分钟的路途，可是从学校回到了家里，课座椅搬回家的那一刻，内心的思绪就整个的变化了，才真实的感觉到了毕业，内心就涌现出一个个念头，我想，昔日的三年级八班不再有我了，那个教室里再也没有属于我的一角了，思绪随着记忆展开…这里曾经是学习的地方，这里曾经让我欢喜，让我忧，而从现在开始，这里的所有属于我的将变得一无所有了，随着时间的流逝，不久后，连自己也会忘得干干净净吧，为了不让岁月的尘土掩盖了美好的回忆，以将他记录封存下来，也许多少年后，或亦将有感于斯文吧！人生路漫漫，美好的中学时光一去不返了，没有谁值得思恋，但就是内心不免些许感伤吧，哪怕只为昔日校园洒过汗水的操场、昔日食堂坐过的椅子，昔日校园走过的小道。物是人非事事休，欲与泪先流，时光太匆匆，过去的日子像风抖落的枫叶，落叶无情而人有情，落叶萧萧，人生如梦。轻轻的我走了，正如我轻轻的来，挥一挥衣袖，不带走一片云彩。此情可待成追忆，只是当时已惘然！路在脚下，背起三年的行囊，去接受人生的洗礼吧，问君能有几多愁，恰似一江春水向东流。晓来谁染霜林醉，总是离人泪，此去今年，前方路途迷茫，雾太浓…<br></p><ul><li>2011年6月11日    星期六   天气 阴</li></ul><p>&nbsp;&nbsp;转眼间，高考已经过去九天了，在这漫长的九天里，每天晚上都睡不着，内心有种说不出的感觉，怅然若失，不知道为什么这么痛苦，晚上就算睡着了也在做梦，做的全部都是上学的梦，有初中，有高中，其中有一个梦场地是初中，而人物却是高中的，毕竟这两个学校自己一共呆过七年吧，翻翻初中写过的日记，从零七年到如今，让自己有对年少时光的幼稚的想法及思想说不出的感觉，是痛恨？是想笑？是回忆？还是感伤？而现在，这九天时间里，可以说是虚度青春，每天晚上睡不着，而白天十一点起来，有时下午还要睡，其他时间就是吃饭了，总之、吃、睡，加上看电视就是我生活的全部，有时夜晚睡不着之时，又不想这么浑浑噩噩的过，而想有所作为，有所计划，但是到了第二天又是老样子了，每天都不出门，呆在家，在家呆着实在无聊就决定出去走走，记得这天下着雨，自己勇敢的出了家门，在县里书店，超市，以及这么多天没来过的学校，徘徊在院墙外，转了一圈回来。走在街上自己提心吊胆的貌似怕见到同学，因为自己也不知道说什么好。正因为这样，自己才会选择雨天出来，因为人少的缘故。回到家，自己又到屋前面的网吧上网，这个离家几十米之遥的网吧，以前因为上学没来过，但高考过后，爸妈就同意我来了，生平第一次来网吧，第一次上网，连开机还是网管鄙视而又不耐烦教的（开玩笑）。回到现在，只是希望高考分数早点出来，六月二十五，既激动又害怕，希望有一个相对理想点的分数吧。每天这样的日子，没有目标，没有计划，惰性占据着全身心，内心一股无名的惆怅和失落，像突然离开学校的失落折磨着内心，自己究竟思恋着什么呢？虽然曾经的上学时光并不快乐，并不时常美好，更多的是苦楚和压力，剪不断、理还乱、是离愁，别是一番滋味在心头！久久难眠，醒来又重复着梦中的思恋苦楚，反反复复，无休无止，衣带渐宽终不悔，为伊消得人憔悴！ <br></p><ul><li>2011年6月30日   星期四       晴</li></ul><p>&nbsp;&nbsp;今天中午，妈妈在超市上班，恰逢里面的水果打折，就称了水果叫我带回去，下午烈日炎炎的太阳，烤的街上的行人纷纷避之而不及，路过二中，看到高一、二的都还在上课，不禁感慨回忆，进而想到我的高中呢？转瞬即逝，许多东西往往是过去后，才知道后悔，流逝后才知道珍惜，以前，唉！只能说没有好好的珍惜，“沉舟侧畔千帆过，病树前头万木春”过去就让过去吧，一届一届的走过，新的高三代替旧的高三，并且总是在不断的重复着，时间总是在流逝的，不会因为个人而停止匆匆的脚步，学校是每个我们的人生中留下过的一个瞬间短促的驿站，留下过最美好回忆的驿站。那么何处是停泊的港湾？时间啊！你为什么流逝的如此之快，子在川上日；不舍昼夜，天若有情天亦老，流星划过的一瞬，历史长河，留给我们的只是那“古今多少事，都付笑谈中”对月当空，洒脱如“对酒当歌，人生几何，思念如“但愿人长久，千里共婵娟”的思念， 惆怅如“无言独上西楼，月如钩”。古往今来，高挂天空的月亮是唯一没有变的，我们所看到的月亮是不是某时某刻古人他们所看到的呢？冥冥之中，是否我们与他们双目对视呢？“江畔何人初见月？江月何年初照人？人生代代无穷已，江月年年只相似。不知江月待何人，但见长江送流水。白云一片去悠悠，春枫浦上不胜愁。”当处在过程之中，只想着结果，当结果来到时，却发现结果并不是那么的迷人，于是倍加怀恋曾经的过程，曾经的岁月！<br></p><ul><li>2011年8月1日    7月31日        阴</li></ul><p>&nbsp;&nbsp;夜未眠，看看以前写过的零碎回忆，当翻开12月29日这篇周记的时候，往事历历在目。那个寒冷的冬天，路灯下的操场上，我仿佛看到了一个在寒风中，围绕着操场一圈又一圈跑过的倔强的的身影。昏黄的路灯照在跑道上的情景，看到了初中部教学楼顶上在那个灯光的映忖下，一阵阵寒风吹过枫树沙沙作响的声音，在那个人的耳际徘徊，至今留在那个人的海里，久久不能忘怀，那个寒冬天未亮，霜未落，只有与影子相伴的操场上，那种过往一排排的枫树的一瞬，那样的时间里光景里，给他留下了最为宝贵的思绪。<br><br>&nbsp;&nbsp;寂寞伴随着他走过那段青春的岁月，他只能惆怅，无能为力，抓不住时间的尾巴，谁道人生无再少，门前流水尚能西。流水无情，而人有情，回忆叠着感伤并着时间的洗涤随风而散，此去今年，往事如烟……</p>]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 回忆 </tag>
            
            <tag> 高中 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>杂感</title>
      <link href="/2015/01/12/%E6%9D%82%E6%84%9F/"/>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;岁月匆匆过，仰望星空，天际浩淼，每一个的我们是多么的渺小，生活与理想，打击与煎熬，历史长河，繁心灿烂，一颗转瞬划过的流星，灰暗而落寞，有谁会记得？<br><br><a id="more"></a><br>&nbsp;&nbsp;小禾苗伴着生养他的土壤，从幼苗到稻穗，从出生到死亡，也许匆匆短暂的这一生，没有见过高山大海的磅礴，没有听过海誓山盟的诺言，也许他的视野永远只是咫尺之地，春夏秋冬，岁月更迭，从葱绿走向金黄，走向微笑，土壤才是他一生的根与意义。<br><br>&nbsp;&nbsp;我常想生活是什么？平凡才是唯一的答案吗？<br><br>&nbsp;&nbsp;我常常想人生的意义是什么？不过是孤独的来，又孤独的走罢了。<br></p>]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
